{"title":"Introdu√ß√£o √† fun√ß√µes","markdown":{"yaml":{"title":"Introdu√ß√£o √† fun√ß√µes","toc":true,"toc-title":"Conte√∫dos da p√°gina"},"headingText":"Exemplo motivacional","containsRefs":false,"markdown":"\n\n\nDesde a antiguidade, matem√°ticos do mundo inteiro buscaram maneiras cada vez mais eficientes de calcular o valor de $\\pi$. Esse n√∫mero, que nasce da geometria dos c√≠rculos, acabou se tornando essencial em √°reas como f√≠sica, computa√ß√£o, engenharia, astronomia e estat√≠stica. A busca por m√©todos r√°pidos e precisos para calcular $\\pi$ √© t√£o antiga quanto a pr√≥pria matem√°tica, e evoluiu de formas surpreendentes ao longo da hist√≥ria.\n\nPrimeiro vieram as aproxima√ß√µes geom√©tricas, como as de Arquimedes. Mais tarde surgiram s√©ries matem√°ticas que, ao somar infinitos termos, aproximavam $\\pi$ com cada vez mais precis√£o. Algumas dessas s√©ries funcionam, mas convergem t√£o lentamente que seriam impratic√°veis para c√°lculos modernos que exigem milh√µes ou bilh√µes de casas decimais.\n\nO grande salto veio no s√©culo XX. O matem√°tico indiano Srinivasa Ramanujan descobriu f√≥rmulas extraordin√°rias, capazes de calcular $\\pi$ com rapidez impressionante. D√©cadas depois, inspirado em seu trabalho, os irm√£os David e Gregory Chudnovsky desenvolveram uma f√≥rmula ainda mais eficiente. Ela se tornou a base dos recordes modernos de c√°lculo de $\\pi$. V√°rios dos maiores valores j√° calculados ‚Äî contendo trilh√µes de d√≠gitos ‚Äî foram obtidos usando essa f√≥rmula.\n\nO motivo? A f√≥rmula de Chudnovsky converge incrivelmente r√°pido. Cada termo adicionado √† s√©rie j√° √© suficiente para somar dezenas de casas decimais corretas.\n\nA f√≥rmula de Chudnovsky √© a seguinte:\n\n$$\n\\frac{1}{\\pi} = 12 \\sum_{n = 0}^{\\infty} \\frac{(-1)^n (6n)! (545140134n+13591409)}{(3n)!(n!)^3 640320^{3n + \\frac{3}{2}}}\n$$\n\nCada novo termo depende de algumas opera√ß√µes:\n\n- um sinal alternado: $(-1)^n$\n\n- um polin√¥mio: $545140134ùëõ +13591409$\n\n- e, principalmente, fatoriais grandes, como\n\n  * $(6n)!$\n\n  * $(3n)!$\n\n  * $(n!)^3$\n\nAgora vamos tentar montar um programa simples para calcular um √∫nico termo desta s√©rie, utilizando somente os conhecimentos que possu√≠mos at√© o momento.\n\n::: {.callout-note title=\"Tente fazer! (clique para revelar a solu√ß√£o)\" collapse=\"true\"}\n\n```{python}\n#| eval: false\n# declara√ß√£o de n (como 0 para o primeiro termo da s√©rie)\nn: int = 0\n\n# C√°lculo do fatorial de 6n\nfatorial_6n = 1\nfor i in range(1, 6 * n + 1):\n    fatorial_6n *= i\n\n# C√°lculo do fatorial de 3n\nfatorial_3n = 1\nfor i in range(1, 3 * n + 1):\n    fatorial_3n *= i\n\n# C√°lculo do fatorial de n\nfatorial_n = 1\nfor i in range(1, n + 1):\n    fatorial_n *= i\n\n# calcular o numerador do termo da s√©rie\nnumerador: float = ((-1) ** n) * fatorial_6n * ((545140134 * n) + 13591409)\n\n# calcular o denominador do termo da s√©rie\ndenominador: float = fatorial_3n * (fatorial_n ** 3) * (640320 ** (3 * n)) * (640320 ** (1.5))\n\n# calcular a divis√£o dos dois\ntermo_da_serie: float = numerador / denominador\n\n# lembrando que 1/pi = 12 * termo_da_serie -> pi = 1/(12 * termo_da_serie)\nprint(1/(12 * termo_da_serie))\n```\n\nCaso n√£o tenha conseguido implementar este c√≥digo, **execute esta implementa√ß√£o na sua m√°quina** e busque entender o que est√° acontecendo exatamente.\n\n\nH√° tamb√©m, um detalhe importante no c√°lcuo do denominador, onde foi utilizado a propriedade que $a^{b + c} = a^b \\times a^c$ para reescrever $640320^{3n + \\frac{3}{2}}$ como $640320^{3n} \\times 640320^{\\frac{3}{2}}$, para melhorar a precis√£o do resultado no computador.\n:::\n\nAo escrever o c√≥digo dessa forma, percebemos uma situa√ß√£o curiosa: para calcular apenas um termo da s√©rie, tivemos que repetir v√°rias vezes exatamente o mesmo tipo de processo ‚Äî calcular o fatorial de um n√∫mero.\n\nVeja que:\n\no c√°lculo de $(6n)!$ segue um passo a passo, o c√°lculo de $(3n)!$ segue o mesmo passo a passo e o c√°lculo de $n!$ tamb√©m segue o mesmo passo a passo!\n\nA √∫nica coisa que muda entre eles √© qual n√∫mero estamos utilizando, mas o que est√° sendo calculado √© a mesma coisa: o fatorial.\n\nIsso significa que estamos copiando e colando o mesmo racioc√≠nio v√°rias vezes, mudando s√≥ um detalhe.\nOu seja, estamos fazendo trabalho repetido, manual e desnecess√°rio.\n\nE nos leva a duas reflex√µes:\n\n#### 1. Estamos repetindo a mesma l√≥gica v√°rias vezes\n\nEssa repeti√ß√£o j√° √© um problema por si s√≥, pois deixa o c√≥digo:\n\n* mais longo\n\n* mais dif√≠cil de ler\n\n* mais cansativo de escrever\n\n#### 2. Se algo estivesse errado, ter√≠amos que consertar em v√°rios lugares\n\nImagine agora que, por algum motivo, cometemos um erro na forma como escrevemos o c√°lculo do fatorial. Talvez tenhamos come√ßado o loop no n√∫mero errado, ou multiplicado na ordem incorreta, ou simplesmente esquecido um detalhe importante. (No c√≥digo acima tudo est√° correto ‚Äî estamos apenas imaginando um cen√°rio em que houvesse um erro.)\n\nComo copiamos esse c√°lculo tr√™s vezes, esse erro estaria:\n\n  * no fatorial de $6n$\n\n  * no fatorial de $3n$\n\n  * no fatorial de $n$\n\nE ent√£o, para corrigir esse erro, precisar√≠amos:\n\n  * lembrar de procurar cada trecho repetido\n\n  * corrigir todos eles manualmente\n\n  * garantir que n√£o esquecemos nenhum\n\nEsse tipo de repeti√ß√£o √© uma grande fonte de bugs em programas reais.\nQuanto mais partes iguais espalhadas pelo c√≥digo, maior a chance de:\n\n  * esquecer de atualizar uma delas\n\n  * corrigir uma vers√£o e deixar outra errada\n\n  * criar inconsist√™ncias dif√≠ceis de rastrear\n\n  * Ou seja: al√©m de trabalhoso, √© arriscado.\n\n#### O que fazer?\n\nSer√° que precisamos reescrever todo esse processo sempre que quisermos calcular um fatorial diferente?\n\nSeria muito mais pr√°tico se pud√©ssemos descrever esse processo uma √∫nica vez, de forma correta, e depois simplesmente pedir ao computador que o execute para qualquer n√∫mero.\n\nComo se diss√©ssemos ao computador:\n\n > ‚ÄúEste √© o procedimento para calcular um fatorial. Sempre que eu precisar, eu te digo o n√∫mero e voc√™ faz isso pra mim.‚Äù\n\nA programa√ß√£o oferece exatamente esse mecanismo:\na possibilidade de guardar um procedimento e reutiliz√°-lo sempre que necess√°rio, mudando apenas a informa√ß√£o de entrada.\n\nIsso melhora tudo:\n\n* evita repeti√ß√£o\n\n* evita erros de manuten√ß√£o\n\n* deixa o c√≥digo mais curto\n\n* deixa o programa mais organizado\n\n* diminui a chance de bugs\n\nEsse mecanismo recebe um nome muito importante: **fun√ß√£o**.\n\n## Introdu√ß√£o a fun√ß√µes\n\nAp√≥s ver o exemplo motivacional sobre o c√°lculo do fatorial, voc√™ provavelmente percebeu que, ao repetir o mesmo processo v√°rias vezes, estamos criando um c√≥digo dif√≠cil de manter, suscet√≠vel a erros e redundante. Uma solu√ß√£o muito poderosa para esse problema √© a utiliza√ß√£o de fun√ß√µes. As fun√ß√µes s√£o um dos conceitos mais importantes na programa√ß√£o, permitindo que voc√™ organize melhor o c√≥digo, evite repeti√ß√µes e torne o programa mais leg√≠vel.\n\nMas, o que s√£o fun√ß√µes exatamente? Como elas funcionam? Como voc√™ as usa de forma eficiente? Para responder a essas perguntas, vamos explorar os principais conceitos por tr√°s das fun√ß√µes, como entradas, sa√≠das, par√¢metros e retorno.\n\n### O que √© uma fun√ß√£o (\"formaliza√ß√£o\")?\n\nUma fun√ß√£o √© um bloco de c√≥digo que realiza uma tarefa espec√≠fica. Podemos v√™-la como um pequeno algoritmo dentro do programa, que voc√™ pode usar v√°rias vezes, sempre que necess√°rio. Funciona da seguinte maneira:\n\n* Entrada: A fun√ß√£o recebe alguns valores de entrada (chamados de par√¢metros).\n\n* Processamento: A fun√ß√£o realiza um processo interno com esses valores (como um c√°lculo ou qualquer outra opera√ß√£o).\n\n* Sa√≠da: A fun√ß√£o devolve um resultado (chamado de retorno), ou ent√£o realiza uma a√ß√£o sem devolver nada.\n\nVamos agora olhar mais a fundo para os diferentes componentes de uma fun√ß√£o, come√ßando pelas entradas, que s√£o essenciais para que a fun√ß√£o saiba o que fazer.\n\n### Entradas de uma fun√ß√£o\n\nQuando chamamos uma fun√ß√£o, passamos dados para ela. Esses dados s√£o chamados de par√¢metros. Eles s√£o valores que a fun√ß√£o usa para realizar seu trabalho. Pense nos par√¢metros como ingredientes que voc√™ passa para a fun√ß√£o, para que ela possa gerar um resultado. A principal vantagem dos par√¢metros √© que eles permitem que uma mesma fun√ß√£o seja usada de maneiras diferentes, dependendo do que voc√™ fornecer.\n\nExemplos do mundo real:\n\n * Receita de bolo:\n\n    Ingredientes como a√ß√∫car, ovos e farinha s√£o os par√¢metros da receita. Se voc√™ quiser fazer um bolo diferente, basta alterar a quantidade de um ou mais ingredientes.\n\n    A mesma receita pode ser usada para diferentes bolos, mudando apenas os par√¢metros (quantidade de a√ß√∫car, farinha, etc.).\n\n* Aplicativo de mapas:\n\n  Quando voc√™ pede para o app calcular a rota de ponto A at√© o ponto B, os endere√ßos de origem e destino s√£o os par√¢metros. O algoritmo de navega√ß√£o √© o mesmo, mas o ponto de partida e chegada que s√£o alterados.\n\n* M√°quina de caf√©:\n\n  Se voc√™ passar o par√¢metro \"tipo de caf√©\", a m√°quina pode preparar um caf√© espresso, um cappuccino ou um latte, dependendo do que voc√™ escolher. O processo de fazer o caf√© (aquecer a √°gua, misturar o p√≥ de caf√©, etc.) √© sempre o mesmo, mas o tipo de caf√© que voc√™ recebe vai depender do par√¢metro que voc√™ forneceu.\n\nNo contexto da programa√ß√£o, os par√¢metros permitem que uma fun√ß√£o tenha flexibilidade. A mesma fun√ß√£o pode ser chamada v√°rias vezes com valores diferentes e produzir resultados diferentes a partir dos mesmos passos internos.\n\nNo nosso exemplo do fatorial, o n√∫mero que queremos calcular o fatorial √© o par√¢metro. Em vez de escrever o c√°lculo de fatorial v√°rias vezes, com o n√∫mero alterando de vez em quando, passamos o n√∫mero como par√¢metro para a fun√ß√£o e ela faz o trabalho para n√≥s.\n\n### Sa√≠das de uma fun√ß√£o: o retorno\n\nDepois de executar o processo, a fun√ß√£o geralmente devolve um resultado. Esse resultado √© chamado de retorno. Dependendo do tipo de tarefa que a fun√ß√£o realiza, ela pode retornar:\n\n* Um valor espec√≠fico, como um n√∫mero ou texto\n\n* Nada (ou seja, ela realiza uma a√ß√£o mas n√£o retorna nenhum valor).\n\n#### Fun√ß√µes com retorno:\n\nUma fun√ß√£o com retorno vai calcular algo com base nas entradas e devolver o resultado. Exemplos disso incluem:\n\n* Calcular a soma de dois n√∫meros.\n\n* Converter temperatura de Celsius para Fahrenheit.\n\n* Calcular o fatorial de um n√∫mero.\n\nPor exemplo, a fun√ß√£o que calcula o fatorial de um n√∫mero deve retornar o resultado do c√°lculo, para que possamos us√°-lo em outra parte do c√≥digo.\n\nFun√ß√µes sem retorno:\n\nJ√° uma fun√ß√£o sem retorno n√£o devolve um valor diretamente, mas realiza uma a√ß√£o. Por exemplo:\n\n* Imprimir uma mensagem na tela.\n\n* Tocar um som.\n\n* Salvar um arquivo no computador.\n\nEssas fun√ß√µes s√£o √∫teis para executar tarefas que n√£o precisam de um resultado imediato, como mostrar uma mensagem ou realizar um efeito visual no programa.\n\n### Por que utilizar fun√ß√µes?\n\nAgora que entendemos o conceito b√°sico de fun√ß√µes e seus componentes (par√¢metros, entradas, sa√≠das, retorno), vamos refletir sobre as principais vantagens de us√°-las:\n\n1. Evita repeti√ß√£o\n\nAo usar fun√ß√µes, voc√™ escreve um conjunto de instru√ß√µes uma √∫nica vez e pode cham√°-lo quantas vezes for necess√°rio. No caso do fatorial, voc√™ escreveria o c√°lculo uma vez dentro de uma fun√ß√£o e poderia cham√°-la sempre que precisasse calcular um fatorial para qualquer n√∫mero.\n\n2. Reduz erros\n\nSe voc√™ precisa corrigir ou otimizar algo, basta alterar a fun√ß√£o em um √∫nico lugar. Sem fun√ß√µes, ter√≠amos que atualizar v√°rias partes do c√≥digo, o que aumenta a chance de deixar algo passar batido. Com fun√ß√µes, isso fica bem mais seguro e eficiente.\n\n3. Facilita a manuten√ß√£o\n\nC√≥digo que utiliza fun√ß√µes √© muito mais f√°cil de entender e manter, porque voc√™ pode pensar nas fun√ß√µes como pequenos blocos de constru√ß√£o. Se voc√™ precisar alterar algo, pode se concentrar apenas na fun√ß√£o espec√≠fica, sem se preocupar em revisar o c√≥digo inteiro.\n\n4. Permite a abstra√ß√£o\n\nFun√ß√µes permitem que voc√™ se concentre no que uma parte do programa faz, sem se preocupar com o como ela faz. Em vez de entender todos os detalhes de um c√°lculo ou tarefa, voc√™ s√≥ precisa saber qual fun√ß√£o chamar e qual valor passar para ela.\n\n### Resumo\n\n| Conceito                    | Descri√ß√£o                                                                |\n| --------------------------- | ------------------------------------------------------------------------ |\n| **Par√¢metro(s)** / **Entrada** | Valores que a fun√ß√£o recebe como entrada, dados fornecidos para a fun√ß√£o |\n| **Processamento**                | As instru√ß√µes internas que a fun√ß√£o executa com esses dados   |\n| **Sa√≠da** / **Retorno**           | O valor que a fun√ß√£o devolve (ou nada, se n√£o houver retorno) |\n\n## Fun√ß√µes que j√° conhecemos\n\nVoc√™ j√° est√° usando fun√ß√µes no seu c√≥digo, sem nem perceber! Tr√™s exemplos que voc√™ provavelmente usa o tempo todo em Python s√£o as fun√ß√µes print(), input() e range(). Todas s√£o essenciais para a intera√ß√£o com o usu√°rio e a exibi√ß√£o de informa√ß√µes. No entanto, embora voc√™ j√° as tenha usado, talvez n√£o tenha notado que ambas s√£o fun√ß√µes completas, com entradas (valores que voc√™ passa para elas) e sa√≠das (valores que elas retornam ou a√ß√µes que realizam).\n\nAgora que come√ßamos a entender o que s√£o fun√ß√µes, vamos analisar como essas duas fun√ß√µes que voc√™ j√° conhece funcionam internamente, e o que elas fazem com as entradas e sa√≠das.\n\n### Fun√ß√£o print()\n\nA fun√ß√£o print() √© provavelmente a fun√ß√£o mais usada em Python. Ela permite que voc√™ mostre informa√ß√µes na tela durante a execu√ß√£o do seu programa. Sempre que voc√™ quer que algo apare√ßa para o usu√°rio ‚Äî seja uma mensagem, um valor ou o resultado de um c√°lculo ‚Äî voc√™ usa print().\n\n#### Entradas: o que a fun√ß√£o print() recebe\n\nA fun√ß√£o print() pode receber um ou mais par√¢metros, que s√£o os valores que voc√™ deseja exibir na tela. Cada valor √© separado por v√≠rgula dentro dos par√™nteses. Esses valores podem ser strings, n√∫meros, ou vari√°veis.\n\nPor exemplo:\n\n```{python}\n#| eval: false\nprint(\"Ol√°, Mundo!\")\n```\n\nAqui, a fun√ß√£o print() recebe uma string (\"Ol√°, Mundo!\") como par√¢metro e exibe essa string na tela. Voc√™ pode tamb√©m passar v√°rias informa√ß√µes de uma vez, separadas por v√≠rgulas, e o Python ir√° automaticamente adicionar espa√ßos entre elas:\n\n```{python}\n#| eval: false\nnome = \"Maria\"\nidade = 25\nprint(\"Nome:\", nome, \"Idade:\", idade)\n```\n\nNeste caso, a fun√ß√£o print() recebe tr√™s par√¢metros: a string \"Nome:\", a vari√°vel nome e a string \"Idade:\". Ela imprime esses valores na tela, com espa√ßos entre eles.\n\n#### Sa√≠da: o que a fun√ß√£o print() retorna\n\nA fun√ß√£o print() n√£o retorna nenhum valor. Ela apenas exibe as entradas fornecidas na tela. Em outras palavras, n√£o h√° um valor retornado por print() que voc√™ possa usar em outros c√°lculos ou vari√°veis. Se quisermos usar a terminologia de fun√ß√µes:\n\n* Sa√≠da/Retorno: `None` (n√£o h√° um valor retornado, a sa√≠da √© apenas o efeito de exibir algo na tela)\n\n#### Resumo da fun√ß√£o print()\n\n| Conceito                  | Descri√ß√£o                                                        |\n| ------------------------- | ---------------------------------------------------------------- |\n| **Par√¢metro(s)/Entrada**  | O(s) valor(es) que voc√™ quer exibir (ex: uma string ou vari√°vel) |\n| **Sa√≠da/Retorno**         | N√£o retorna valor, apenas exibe a informa√ß√£o                     |\n\n### Fun√ß√£o input()\n\nA fun√ß√£o input() √© outra fun√ß√£o muito comum em Python. Ela permite que voc√™ obtenha dados do usu√°rio. Sempre que voc√™ precisa fazer uma pergunta ao usu√°rio e obter uma resposta, voc√™ usa input().\n\n#### Entradas: o que a fun√ß√£o input() recebe\n\nA fun√ß√£o input() pode receber um par√¢metro, que √© o texto que voc√™ deseja exibir para o usu√°rio antes que ele digite a resposta. Esse texto √© normalmente uma pergunta ou uma mensagem explicativa.\n\nPor exemplo:\n\n```{python}\n#| eval: false\nnome = input(\"Qual √© o seu nome? \")\nprint(\"Ol√°, \" + nome + \"!\")\n```\n\nAqui, a fun√ß√£o input() recebe o par√¢metro \"Qual √© o seu nome? \" e exibe essa mensagem na tela. O Python ent√£o espera que o usu√°rio digite uma resposta. Quando o usu√°rio digita, a fun√ß√£o retorna a resposta como uma string. A resposta do usu√°rio √© armazenada na vari√°vel nome, que pode ser utilizada posteriormente.\n\n#### Sa√≠da: o que a fun√ß√£o input() retorna\n\nA fun√ß√£o input() sempre retorna uma string, independentemente do que o usu√°rio digite. Isso significa que, mesmo que o usu√°rio digite n√∫meros, a entrada ser√° interpretada como texto.\n\nPor exemplo, se o usu√°rio digitar \"25\" (para idade), ele ser√° armazenado como a string \"25\". Se quisermos tratar esse valor como um n√∫mero, precisamos convert√™-lo para o tipo correto usando fun√ß√µes como int() ou float().\n\n```{python}\n#| eval: false\nidade = input(\"Quantos anos voc√™ tem? \")\nidade = int(idade)  # Converte a resposta para um n√∫mero inteiro\nprint(\"Voc√™ tem\", idade, \"anos.\")\n```\n\nAqui, a fun√ß√£o input() retorna a resposta do usu√°rio como uma string. Depois, usamos int() para converter essa string em um n√∫mero inteiro.\n\n#### Resumo da fun√ß√£o input()\n\n| Conceito                  | Descri√ß√£o                                                            |\n| ------------------------- | -------------------------------------------------------------------- |\n| **Par√¢metro(s)/Entrada**  | O texto exibido para o usu√°rio (ex: uma pergunta ou mensagem)        |\n| **Sa√≠da/Retorno**         | A fun√ß√£o retorna uma **string** (mesmo que o usu√°rio digite n√∫meros) |\n\n### Fun√ß√£o range()\n\nVoc√™ j√° est√° familiarizado com a fun√ß√£o range(), uma das fun√ß√µes mais usadas em Python para controlar loops. Ela gera uma sequ√™ncia de n√∫meros, o que √© perfeito quando queremos repetir uma a√ß√£o v√°rias vezes com controle preciso sobre os n√∫meros.\n\n#### Entradas: o que a fun√ß√£o range() recebe\n\nA fun√ß√£o range() pode receber at√© tr√™s par√¢metros:\n\n* in√≠cio: O n√∫mero onde a sequ√™ncia come√ßa (inclusivo). O valor padr√£o √© 0.\n\n* fim: O n√∫mero onde a sequ√™ncia termina (exclusivo).\n\n* passo: O valor que define o incremento entre os n√∫meros. O valor padr√£o √© 1.\n\nOrganizados da seguinte maneira:\n\n```{python}\n#| eval: false\nrange(in√≠cio, fim, passo)\n```\n\n#### Sa√≠da: o que a fun√ß√£o range() retorna\n\nA fun√ß√£o range() retorna um objeto iter√°vel que gera os n√∫meros da sequ√™ncia solicitada. Ele n√£o cria uma lista de n√∫meros, mas gera cada n√∫mero conforme o loop vai sendo executado, o que √© mais eficiente.\n\n#### Resumo da fun√ß√£o range()\n\n| Conceito                  | Descri√ß√£o                                           |\n| ------------------------- | --------------------------------------------------- |\n| **Par√¢metro(s)/Entrada**  | `in√≠cio`, `fim`, e `passo` (todos s√£o opcionais)    |\n| **Sa√≠da/Retorno**         | Um objeto iter√°vel que gera os n√∫meros da sequ√™ncia |\n\n## Sintaxe de utiliza√ß√£o de fun√ß√µes\n\nAgora que j√° sabemos o que s√£o fun√ß√µes e por que elas s√£o √∫teis, vamos entender como cham√°-las corretamente. Chamar uma fun√ß√£o significa pedir ao Python para executar o c√≥digo dentro daquela fun√ß√£o. Quando voc√™ chama uma fun√ß√£o, o programa \"vai at√© a fun√ß√£o\", executa as instru√ß√µes que est√£o nela e, em muitos casos, retorna um resultado.\n\nEm termos simples, chamar uma fun√ß√£o √© como fazer um pedido para o programa realizar uma tarefa espec√≠fica. Quando voc√™ chama a fun√ß√£o, ela faz algo por voc√™, seja exibindo algo na tela, realizando um c√°lculo, ou at√© recebendo dados de entrada do usu√°rio.\n\nAgora, vamos ver como a sintaxe de uma fun√ß√£o funciona em Python, incluindo como passar par√¢metros, como chamar fun√ß√µes sem par√¢metros e como lidar com valores retornados.\n\n### Chamar uma fun√ß√£o\n\nEm Python, chamar uma fun√ß√£o √© bem simples, mas precisa seguir uma estrutura espec√≠fica. Toda vez que voc√™ quiser usar uma fun√ß√£o, voc√™ deve incluir par√™nteses ap√≥s o nome da fun√ß√£o.\n\n```{python}\n#| eval: false\nnome_da_funcao()\n```\n\n### Fun√ß√µes com par√¢metros\n\nAs fun√ß√µes podem receber par√¢metros, que s√£o os valores que voc√™ passa para elas para que possam realizar algum processamento. Esses par√¢metros s√£o colocados dentro dos par√™nteses ao chamar a fun√ß√£o.\n\n```{python}\n#| eval: false\nnome_da_funcao(parametro_1, parametro_2, ...)\n```\n\n### Fun√ß√µes sem par√¢metro\n\nAlgumas fun√ß√µes n√£o exigem nenhum par√¢metro. Nesse caso, voc√™ ainda deve usar os par√™nteses ao chamar a fun√ß√£o, mas n√£o h√° necessidade de colocar nada dentro deles.\n\n```{python}\n#| eval: false\nnome_da_funcao()\n```\n\n### Fun√ß√µes com retorno\n\nFun√ß√µes podem retornar um valor ap√≥s a execu√ß√£o. O valor retornado pode ser armazenado em uma vari√°vel ou utilizado diretamente em c√°lculos ou outras opera√ß√µes.\n\nQuando uma fun√ß√£o tem retorno, a sintaxe para us√°-la fica da seguinte forma:\n\n```{python}\n#| eval: false\nvariavel = nome_da_funcao(parametros)\n```\n\n### Fun√ß√µes com par√¢metros opcionais\n\n√Äs vezes, as fun√ß√µes podem ter par√¢metros com valores padr√£o, o que significa que, se voc√™ n√£o passar um valor para aquele par√¢metro, o Python usar√° algum valor pr√©-definido.\n\nOu seja, se temos uma fun√ß√£o, por exemplo, que tem um par√¢metro \"parametro_1\" pr√©-definido para o valor 10, se um novo valor de a n√£o for especificado na chamada, da seguinte forma:\n\n```{python}\n#| eval: false\nnome_da_funcao(parametro_1 = 3)\n```\n\nA fun√ß√£o √© executada com o valor de \"parametro_1\" igual a 10.\n\n## Exerc√≠cios\n\n### Exerc√≠cio 1\n\nImagine uma fun√ß√£o que calcule a soma de dois n√∫meros. Quais seriam as entradas e sa√≠das dessa fun√ß√£o? Quais s√£o os poss√≠veis tipos de dados que esta fun√ß√£o aceita? \n\n::: {.callout-tip collapse=\"true\" title=\"Ver Solu√ß√£o\"}\n\nEntradas e sa√≠das:\n\n| -------- | ------------------ |\n| entradas | dois n√∫meros: a, b |\n| sa√≠das   | a soma de a e b    |\n\na e b poderiam ser n√∫meros inteiros ou floats, mas provavelmente n√£o faria muito sentido eles serem diferentes disto.\n\n:::\n\n### Exerc√≠cio 2\n\nComo a defini√ß√£o de fun√ß√µes pode tornar a manuten√ß√£o de um c√≥digo mais f√°cil? Quais problemas podem surgir se n√£o usarmos fun√ß√µes e acabarmos repetindo o mesmo c√≥digo em v√°rias partes do programa?\n\n::: {.callout-tip collapse=\"true\" title=\"Ver Solu√ß√£o\"}\n\nA defini√ß√£o de fun√ß√µes torna um codigo muito mais simples, pois se o c√≥digo da fun√ß√£o est√° errado, √© necess√°rio alter√°-lo em somente um lugar, evitando com que partes estejam corretas e partes estejam incorretas. Caso n√£o sejam utilizadas fun√ß√µes em c√≥digo, √© poss√≠vel que a repeti√ß√£o de trechos de c√≥digo leve a problemas que s√£o praticmanete imposs√≠veis de rastrear.\n\n:::\n\n### Exerc√≠cio 3\n\nImagine que voc√™ tenha pontos 3D no espa√ßo. A f√≥rmula para calcular a dist√¢ncia entre dois destes pontos ($P1(x_1, y_1, z_1)$ e $P2(x_2, y_2, z_2)$) √© a seguinte:\n\n$$\nd(P1, P2) = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2} \n$$\n\nComo isto poderia ser adaptado para uma fun√ß√£o (quais entradas e sa√≠das)?\n\n::: {.callout-tip collapse=\"true\" title=\"Ver Solu√ß√£o\"}\n\nPara adaptar isto para fun√ß√£o, √© necess√°rio somente que as entradas sejam os dois pontos ($P1$ e $P2$), pois com eles ser√° feito o processamento de coordenadas para retornar, como sa√≠da, a dist√¢ncia entre eles.\n\n:::\n\n","srcMarkdownNoYaml":"\n\n## Exemplo motivacional\n\nDesde a antiguidade, matem√°ticos do mundo inteiro buscaram maneiras cada vez mais eficientes de calcular o valor de $\\pi$. Esse n√∫mero, que nasce da geometria dos c√≠rculos, acabou se tornando essencial em √°reas como f√≠sica, computa√ß√£o, engenharia, astronomia e estat√≠stica. A busca por m√©todos r√°pidos e precisos para calcular $\\pi$ √© t√£o antiga quanto a pr√≥pria matem√°tica, e evoluiu de formas surpreendentes ao longo da hist√≥ria.\n\nPrimeiro vieram as aproxima√ß√µes geom√©tricas, como as de Arquimedes. Mais tarde surgiram s√©ries matem√°ticas que, ao somar infinitos termos, aproximavam $\\pi$ com cada vez mais precis√£o. Algumas dessas s√©ries funcionam, mas convergem t√£o lentamente que seriam impratic√°veis para c√°lculos modernos que exigem milh√µes ou bilh√µes de casas decimais.\n\nO grande salto veio no s√©culo XX. O matem√°tico indiano Srinivasa Ramanujan descobriu f√≥rmulas extraordin√°rias, capazes de calcular $\\pi$ com rapidez impressionante. D√©cadas depois, inspirado em seu trabalho, os irm√£os David e Gregory Chudnovsky desenvolveram uma f√≥rmula ainda mais eficiente. Ela se tornou a base dos recordes modernos de c√°lculo de $\\pi$. V√°rios dos maiores valores j√° calculados ‚Äî contendo trilh√µes de d√≠gitos ‚Äî foram obtidos usando essa f√≥rmula.\n\nO motivo? A f√≥rmula de Chudnovsky converge incrivelmente r√°pido. Cada termo adicionado √† s√©rie j√° √© suficiente para somar dezenas de casas decimais corretas.\n\nA f√≥rmula de Chudnovsky √© a seguinte:\n\n$$\n\\frac{1}{\\pi} = 12 \\sum_{n = 0}^{\\infty} \\frac{(-1)^n (6n)! (545140134n+13591409)}{(3n)!(n!)^3 640320^{3n + \\frac{3}{2}}}\n$$\n\nCada novo termo depende de algumas opera√ß√µes:\n\n- um sinal alternado: $(-1)^n$\n\n- um polin√¥mio: $545140134ùëõ +13591409$\n\n- e, principalmente, fatoriais grandes, como\n\n  * $(6n)!$\n\n  * $(3n)!$\n\n  * $(n!)^3$\n\nAgora vamos tentar montar um programa simples para calcular um √∫nico termo desta s√©rie, utilizando somente os conhecimentos que possu√≠mos at√© o momento.\n\n::: {.callout-note title=\"Tente fazer! (clique para revelar a solu√ß√£o)\" collapse=\"true\"}\n\n```{python}\n#| eval: false\n# declara√ß√£o de n (como 0 para o primeiro termo da s√©rie)\nn: int = 0\n\n# C√°lculo do fatorial de 6n\nfatorial_6n = 1\nfor i in range(1, 6 * n + 1):\n    fatorial_6n *= i\n\n# C√°lculo do fatorial de 3n\nfatorial_3n = 1\nfor i in range(1, 3 * n + 1):\n    fatorial_3n *= i\n\n# C√°lculo do fatorial de n\nfatorial_n = 1\nfor i in range(1, n + 1):\n    fatorial_n *= i\n\n# calcular o numerador do termo da s√©rie\nnumerador: float = ((-1) ** n) * fatorial_6n * ((545140134 * n) + 13591409)\n\n# calcular o denominador do termo da s√©rie\ndenominador: float = fatorial_3n * (fatorial_n ** 3) * (640320 ** (3 * n)) * (640320 ** (1.5))\n\n# calcular a divis√£o dos dois\ntermo_da_serie: float = numerador / denominador\n\n# lembrando que 1/pi = 12 * termo_da_serie -> pi = 1/(12 * termo_da_serie)\nprint(1/(12 * termo_da_serie))\n```\n\nCaso n√£o tenha conseguido implementar este c√≥digo, **execute esta implementa√ß√£o na sua m√°quina** e busque entender o que est√° acontecendo exatamente.\n\n\nH√° tamb√©m, um detalhe importante no c√°lcuo do denominador, onde foi utilizado a propriedade que $a^{b + c} = a^b \\times a^c$ para reescrever $640320^{3n + \\frac{3}{2}}$ como $640320^{3n} \\times 640320^{\\frac{3}{2}}$, para melhorar a precis√£o do resultado no computador.\n:::\n\nAo escrever o c√≥digo dessa forma, percebemos uma situa√ß√£o curiosa: para calcular apenas um termo da s√©rie, tivemos que repetir v√°rias vezes exatamente o mesmo tipo de processo ‚Äî calcular o fatorial de um n√∫mero.\n\nVeja que:\n\no c√°lculo de $(6n)!$ segue um passo a passo, o c√°lculo de $(3n)!$ segue o mesmo passo a passo e o c√°lculo de $n!$ tamb√©m segue o mesmo passo a passo!\n\nA √∫nica coisa que muda entre eles √© qual n√∫mero estamos utilizando, mas o que est√° sendo calculado √© a mesma coisa: o fatorial.\n\nIsso significa que estamos copiando e colando o mesmo racioc√≠nio v√°rias vezes, mudando s√≥ um detalhe.\nOu seja, estamos fazendo trabalho repetido, manual e desnecess√°rio.\n\nE nos leva a duas reflex√µes:\n\n#### 1. Estamos repetindo a mesma l√≥gica v√°rias vezes\n\nEssa repeti√ß√£o j√° √© um problema por si s√≥, pois deixa o c√≥digo:\n\n* mais longo\n\n* mais dif√≠cil de ler\n\n* mais cansativo de escrever\n\n#### 2. Se algo estivesse errado, ter√≠amos que consertar em v√°rios lugares\n\nImagine agora que, por algum motivo, cometemos um erro na forma como escrevemos o c√°lculo do fatorial. Talvez tenhamos come√ßado o loop no n√∫mero errado, ou multiplicado na ordem incorreta, ou simplesmente esquecido um detalhe importante. (No c√≥digo acima tudo est√° correto ‚Äî estamos apenas imaginando um cen√°rio em que houvesse um erro.)\n\nComo copiamos esse c√°lculo tr√™s vezes, esse erro estaria:\n\n  * no fatorial de $6n$\n\n  * no fatorial de $3n$\n\n  * no fatorial de $n$\n\nE ent√£o, para corrigir esse erro, precisar√≠amos:\n\n  * lembrar de procurar cada trecho repetido\n\n  * corrigir todos eles manualmente\n\n  * garantir que n√£o esquecemos nenhum\n\nEsse tipo de repeti√ß√£o √© uma grande fonte de bugs em programas reais.\nQuanto mais partes iguais espalhadas pelo c√≥digo, maior a chance de:\n\n  * esquecer de atualizar uma delas\n\n  * corrigir uma vers√£o e deixar outra errada\n\n  * criar inconsist√™ncias dif√≠ceis de rastrear\n\n  * Ou seja: al√©m de trabalhoso, √© arriscado.\n\n#### O que fazer?\n\nSer√° que precisamos reescrever todo esse processo sempre que quisermos calcular um fatorial diferente?\n\nSeria muito mais pr√°tico se pud√©ssemos descrever esse processo uma √∫nica vez, de forma correta, e depois simplesmente pedir ao computador que o execute para qualquer n√∫mero.\n\nComo se diss√©ssemos ao computador:\n\n > ‚ÄúEste √© o procedimento para calcular um fatorial. Sempre que eu precisar, eu te digo o n√∫mero e voc√™ faz isso pra mim.‚Äù\n\nA programa√ß√£o oferece exatamente esse mecanismo:\na possibilidade de guardar um procedimento e reutiliz√°-lo sempre que necess√°rio, mudando apenas a informa√ß√£o de entrada.\n\nIsso melhora tudo:\n\n* evita repeti√ß√£o\n\n* evita erros de manuten√ß√£o\n\n* deixa o c√≥digo mais curto\n\n* deixa o programa mais organizado\n\n* diminui a chance de bugs\n\nEsse mecanismo recebe um nome muito importante: **fun√ß√£o**.\n\n## Introdu√ß√£o a fun√ß√µes\n\nAp√≥s ver o exemplo motivacional sobre o c√°lculo do fatorial, voc√™ provavelmente percebeu que, ao repetir o mesmo processo v√°rias vezes, estamos criando um c√≥digo dif√≠cil de manter, suscet√≠vel a erros e redundante. Uma solu√ß√£o muito poderosa para esse problema √© a utiliza√ß√£o de fun√ß√µes. As fun√ß√µes s√£o um dos conceitos mais importantes na programa√ß√£o, permitindo que voc√™ organize melhor o c√≥digo, evite repeti√ß√µes e torne o programa mais leg√≠vel.\n\nMas, o que s√£o fun√ß√µes exatamente? Como elas funcionam? Como voc√™ as usa de forma eficiente? Para responder a essas perguntas, vamos explorar os principais conceitos por tr√°s das fun√ß√µes, como entradas, sa√≠das, par√¢metros e retorno.\n\n### O que √© uma fun√ß√£o (\"formaliza√ß√£o\")?\n\nUma fun√ß√£o √© um bloco de c√≥digo que realiza uma tarefa espec√≠fica. Podemos v√™-la como um pequeno algoritmo dentro do programa, que voc√™ pode usar v√°rias vezes, sempre que necess√°rio. Funciona da seguinte maneira:\n\n* Entrada: A fun√ß√£o recebe alguns valores de entrada (chamados de par√¢metros).\n\n* Processamento: A fun√ß√£o realiza um processo interno com esses valores (como um c√°lculo ou qualquer outra opera√ß√£o).\n\n* Sa√≠da: A fun√ß√£o devolve um resultado (chamado de retorno), ou ent√£o realiza uma a√ß√£o sem devolver nada.\n\nVamos agora olhar mais a fundo para os diferentes componentes de uma fun√ß√£o, come√ßando pelas entradas, que s√£o essenciais para que a fun√ß√£o saiba o que fazer.\n\n### Entradas de uma fun√ß√£o\n\nQuando chamamos uma fun√ß√£o, passamos dados para ela. Esses dados s√£o chamados de par√¢metros. Eles s√£o valores que a fun√ß√£o usa para realizar seu trabalho. Pense nos par√¢metros como ingredientes que voc√™ passa para a fun√ß√£o, para que ela possa gerar um resultado. A principal vantagem dos par√¢metros √© que eles permitem que uma mesma fun√ß√£o seja usada de maneiras diferentes, dependendo do que voc√™ fornecer.\n\nExemplos do mundo real:\n\n * Receita de bolo:\n\n    Ingredientes como a√ß√∫car, ovos e farinha s√£o os par√¢metros da receita. Se voc√™ quiser fazer um bolo diferente, basta alterar a quantidade de um ou mais ingredientes.\n\n    A mesma receita pode ser usada para diferentes bolos, mudando apenas os par√¢metros (quantidade de a√ß√∫car, farinha, etc.).\n\n* Aplicativo de mapas:\n\n  Quando voc√™ pede para o app calcular a rota de ponto A at√© o ponto B, os endere√ßos de origem e destino s√£o os par√¢metros. O algoritmo de navega√ß√£o √© o mesmo, mas o ponto de partida e chegada que s√£o alterados.\n\n* M√°quina de caf√©:\n\n  Se voc√™ passar o par√¢metro \"tipo de caf√©\", a m√°quina pode preparar um caf√© espresso, um cappuccino ou um latte, dependendo do que voc√™ escolher. O processo de fazer o caf√© (aquecer a √°gua, misturar o p√≥ de caf√©, etc.) √© sempre o mesmo, mas o tipo de caf√© que voc√™ recebe vai depender do par√¢metro que voc√™ forneceu.\n\nNo contexto da programa√ß√£o, os par√¢metros permitem que uma fun√ß√£o tenha flexibilidade. A mesma fun√ß√£o pode ser chamada v√°rias vezes com valores diferentes e produzir resultados diferentes a partir dos mesmos passos internos.\n\nNo nosso exemplo do fatorial, o n√∫mero que queremos calcular o fatorial √© o par√¢metro. Em vez de escrever o c√°lculo de fatorial v√°rias vezes, com o n√∫mero alterando de vez em quando, passamos o n√∫mero como par√¢metro para a fun√ß√£o e ela faz o trabalho para n√≥s.\n\n### Sa√≠das de uma fun√ß√£o: o retorno\n\nDepois de executar o processo, a fun√ß√£o geralmente devolve um resultado. Esse resultado √© chamado de retorno. Dependendo do tipo de tarefa que a fun√ß√£o realiza, ela pode retornar:\n\n* Um valor espec√≠fico, como um n√∫mero ou texto\n\n* Nada (ou seja, ela realiza uma a√ß√£o mas n√£o retorna nenhum valor).\n\n#### Fun√ß√µes com retorno:\n\nUma fun√ß√£o com retorno vai calcular algo com base nas entradas e devolver o resultado. Exemplos disso incluem:\n\n* Calcular a soma de dois n√∫meros.\n\n* Converter temperatura de Celsius para Fahrenheit.\n\n* Calcular o fatorial de um n√∫mero.\n\nPor exemplo, a fun√ß√£o que calcula o fatorial de um n√∫mero deve retornar o resultado do c√°lculo, para que possamos us√°-lo em outra parte do c√≥digo.\n\nFun√ß√µes sem retorno:\n\nJ√° uma fun√ß√£o sem retorno n√£o devolve um valor diretamente, mas realiza uma a√ß√£o. Por exemplo:\n\n* Imprimir uma mensagem na tela.\n\n* Tocar um som.\n\n* Salvar um arquivo no computador.\n\nEssas fun√ß√µes s√£o √∫teis para executar tarefas que n√£o precisam de um resultado imediato, como mostrar uma mensagem ou realizar um efeito visual no programa.\n\n### Por que utilizar fun√ß√µes?\n\nAgora que entendemos o conceito b√°sico de fun√ß√µes e seus componentes (par√¢metros, entradas, sa√≠das, retorno), vamos refletir sobre as principais vantagens de us√°-las:\n\n1. Evita repeti√ß√£o\n\nAo usar fun√ß√µes, voc√™ escreve um conjunto de instru√ß√µes uma √∫nica vez e pode cham√°-lo quantas vezes for necess√°rio. No caso do fatorial, voc√™ escreveria o c√°lculo uma vez dentro de uma fun√ß√£o e poderia cham√°-la sempre que precisasse calcular um fatorial para qualquer n√∫mero.\n\n2. Reduz erros\n\nSe voc√™ precisa corrigir ou otimizar algo, basta alterar a fun√ß√£o em um √∫nico lugar. Sem fun√ß√µes, ter√≠amos que atualizar v√°rias partes do c√≥digo, o que aumenta a chance de deixar algo passar batido. Com fun√ß√µes, isso fica bem mais seguro e eficiente.\n\n3. Facilita a manuten√ß√£o\n\nC√≥digo que utiliza fun√ß√µes √© muito mais f√°cil de entender e manter, porque voc√™ pode pensar nas fun√ß√µes como pequenos blocos de constru√ß√£o. Se voc√™ precisar alterar algo, pode se concentrar apenas na fun√ß√£o espec√≠fica, sem se preocupar em revisar o c√≥digo inteiro.\n\n4. Permite a abstra√ß√£o\n\nFun√ß√µes permitem que voc√™ se concentre no que uma parte do programa faz, sem se preocupar com o como ela faz. Em vez de entender todos os detalhes de um c√°lculo ou tarefa, voc√™ s√≥ precisa saber qual fun√ß√£o chamar e qual valor passar para ela.\n\n### Resumo\n\n| Conceito                    | Descri√ß√£o                                                                |\n| --------------------------- | ------------------------------------------------------------------------ |\n| **Par√¢metro(s)** / **Entrada** | Valores que a fun√ß√£o recebe como entrada, dados fornecidos para a fun√ß√£o |\n| **Processamento**                | As instru√ß√µes internas que a fun√ß√£o executa com esses dados   |\n| **Sa√≠da** / **Retorno**           | O valor que a fun√ß√£o devolve (ou nada, se n√£o houver retorno) |\n\n## Fun√ß√µes que j√° conhecemos\n\nVoc√™ j√° est√° usando fun√ß√µes no seu c√≥digo, sem nem perceber! Tr√™s exemplos que voc√™ provavelmente usa o tempo todo em Python s√£o as fun√ß√µes print(), input() e range(). Todas s√£o essenciais para a intera√ß√£o com o usu√°rio e a exibi√ß√£o de informa√ß√µes. No entanto, embora voc√™ j√° as tenha usado, talvez n√£o tenha notado que ambas s√£o fun√ß√µes completas, com entradas (valores que voc√™ passa para elas) e sa√≠das (valores que elas retornam ou a√ß√µes que realizam).\n\nAgora que come√ßamos a entender o que s√£o fun√ß√µes, vamos analisar como essas duas fun√ß√µes que voc√™ j√° conhece funcionam internamente, e o que elas fazem com as entradas e sa√≠das.\n\n### Fun√ß√£o print()\n\nA fun√ß√£o print() √© provavelmente a fun√ß√£o mais usada em Python. Ela permite que voc√™ mostre informa√ß√µes na tela durante a execu√ß√£o do seu programa. Sempre que voc√™ quer que algo apare√ßa para o usu√°rio ‚Äî seja uma mensagem, um valor ou o resultado de um c√°lculo ‚Äî voc√™ usa print().\n\n#### Entradas: o que a fun√ß√£o print() recebe\n\nA fun√ß√£o print() pode receber um ou mais par√¢metros, que s√£o os valores que voc√™ deseja exibir na tela. Cada valor √© separado por v√≠rgula dentro dos par√™nteses. Esses valores podem ser strings, n√∫meros, ou vari√°veis.\n\nPor exemplo:\n\n```{python}\n#| eval: false\nprint(\"Ol√°, Mundo!\")\n```\n\nAqui, a fun√ß√£o print() recebe uma string (\"Ol√°, Mundo!\") como par√¢metro e exibe essa string na tela. Voc√™ pode tamb√©m passar v√°rias informa√ß√µes de uma vez, separadas por v√≠rgulas, e o Python ir√° automaticamente adicionar espa√ßos entre elas:\n\n```{python}\n#| eval: false\nnome = \"Maria\"\nidade = 25\nprint(\"Nome:\", nome, \"Idade:\", idade)\n```\n\nNeste caso, a fun√ß√£o print() recebe tr√™s par√¢metros: a string \"Nome:\", a vari√°vel nome e a string \"Idade:\". Ela imprime esses valores na tela, com espa√ßos entre eles.\n\n#### Sa√≠da: o que a fun√ß√£o print() retorna\n\nA fun√ß√£o print() n√£o retorna nenhum valor. Ela apenas exibe as entradas fornecidas na tela. Em outras palavras, n√£o h√° um valor retornado por print() que voc√™ possa usar em outros c√°lculos ou vari√°veis. Se quisermos usar a terminologia de fun√ß√µes:\n\n* Sa√≠da/Retorno: `None` (n√£o h√° um valor retornado, a sa√≠da √© apenas o efeito de exibir algo na tela)\n\n#### Resumo da fun√ß√£o print()\n\n| Conceito                  | Descri√ß√£o                                                        |\n| ------------------------- | ---------------------------------------------------------------- |\n| **Par√¢metro(s)/Entrada**  | O(s) valor(es) que voc√™ quer exibir (ex: uma string ou vari√°vel) |\n| **Sa√≠da/Retorno**         | N√£o retorna valor, apenas exibe a informa√ß√£o                     |\n\n### Fun√ß√£o input()\n\nA fun√ß√£o input() √© outra fun√ß√£o muito comum em Python. Ela permite que voc√™ obtenha dados do usu√°rio. Sempre que voc√™ precisa fazer uma pergunta ao usu√°rio e obter uma resposta, voc√™ usa input().\n\n#### Entradas: o que a fun√ß√£o input() recebe\n\nA fun√ß√£o input() pode receber um par√¢metro, que √© o texto que voc√™ deseja exibir para o usu√°rio antes que ele digite a resposta. Esse texto √© normalmente uma pergunta ou uma mensagem explicativa.\n\nPor exemplo:\n\n```{python}\n#| eval: false\nnome = input(\"Qual √© o seu nome? \")\nprint(\"Ol√°, \" + nome + \"!\")\n```\n\nAqui, a fun√ß√£o input() recebe o par√¢metro \"Qual √© o seu nome? \" e exibe essa mensagem na tela. O Python ent√£o espera que o usu√°rio digite uma resposta. Quando o usu√°rio digita, a fun√ß√£o retorna a resposta como uma string. A resposta do usu√°rio √© armazenada na vari√°vel nome, que pode ser utilizada posteriormente.\n\n#### Sa√≠da: o que a fun√ß√£o input() retorna\n\nA fun√ß√£o input() sempre retorna uma string, independentemente do que o usu√°rio digite. Isso significa que, mesmo que o usu√°rio digite n√∫meros, a entrada ser√° interpretada como texto.\n\nPor exemplo, se o usu√°rio digitar \"25\" (para idade), ele ser√° armazenado como a string \"25\". Se quisermos tratar esse valor como um n√∫mero, precisamos convert√™-lo para o tipo correto usando fun√ß√µes como int() ou float().\n\n```{python}\n#| eval: false\nidade = input(\"Quantos anos voc√™ tem? \")\nidade = int(idade)  # Converte a resposta para um n√∫mero inteiro\nprint(\"Voc√™ tem\", idade, \"anos.\")\n```\n\nAqui, a fun√ß√£o input() retorna a resposta do usu√°rio como uma string. Depois, usamos int() para converter essa string em um n√∫mero inteiro.\n\n#### Resumo da fun√ß√£o input()\n\n| Conceito                  | Descri√ß√£o                                                            |\n| ------------------------- | -------------------------------------------------------------------- |\n| **Par√¢metro(s)/Entrada**  | O texto exibido para o usu√°rio (ex: uma pergunta ou mensagem)        |\n| **Sa√≠da/Retorno**         | A fun√ß√£o retorna uma **string** (mesmo que o usu√°rio digite n√∫meros) |\n\n### Fun√ß√£o range()\n\nVoc√™ j√° est√° familiarizado com a fun√ß√£o range(), uma das fun√ß√µes mais usadas em Python para controlar loops. Ela gera uma sequ√™ncia de n√∫meros, o que √© perfeito quando queremos repetir uma a√ß√£o v√°rias vezes com controle preciso sobre os n√∫meros.\n\n#### Entradas: o que a fun√ß√£o range() recebe\n\nA fun√ß√£o range() pode receber at√© tr√™s par√¢metros:\n\n* in√≠cio: O n√∫mero onde a sequ√™ncia come√ßa (inclusivo). O valor padr√£o √© 0.\n\n* fim: O n√∫mero onde a sequ√™ncia termina (exclusivo).\n\n* passo: O valor que define o incremento entre os n√∫meros. O valor padr√£o √© 1.\n\nOrganizados da seguinte maneira:\n\n```{python}\n#| eval: false\nrange(in√≠cio, fim, passo)\n```\n\n#### Sa√≠da: o que a fun√ß√£o range() retorna\n\nA fun√ß√£o range() retorna um objeto iter√°vel que gera os n√∫meros da sequ√™ncia solicitada. Ele n√£o cria uma lista de n√∫meros, mas gera cada n√∫mero conforme o loop vai sendo executado, o que √© mais eficiente.\n\n#### Resumo da fun√ß√£o range()\n\n| Conceito                  | Descri√ß√£o                                           |\n| ------------------------- | --------------------------------------------------- |\n| **Par√¢metro(s)/Entrada**  | `in√≠cio`, `fim`, e `passo` (todos s√£o opcionais)    |\n| **Sa√≠da/Retorno**         | Um objeto iter√°vel que gera os n√∫meros da sequ√™ncia |\n\n## Sintaxe de utiliza√ß√£o de fun√ß√µes\n\nAgora que j√° sabemos o que s√£o fun√ß√µes e por que elas s√£o √∫teis, vamos entender como cham√°-las corretamente. Chamar uma fun√ß√£o significa pedir ao Python para executar o c√≥digo dentro daquela fun√ß√£o. Quando voc√™ chama uma fun√ß√£o, o programa \"vai at√© a fun√ß√£o\", executa as instru√ß√µes que est√£o nela e, em muitos casos, retorna um resultado.\n\nEm termos simples, chamar uma fun√ß√£o √© como fazer um pedido para o programa realizar uma tarefa espec√≠fica. Quando voc√™ chama a fun√ß√£o, ela faz algo por voc√™, seja exibindo algo na tela, realizando um c√°lculo, ou at√© recebendo dados de entrada do usu√°rio.\n\nAgora, vamos ver como a sintaxe de uma fun√ß√£o funciona em Python, incluindo como passar par√¢metros, como chamar fun√ß√µes sem par√¢metros e como lidar com valores retornados.\n\n### Chamar uma fun√ß√£o\n\nEm Python, chamar uma fun√ß√£o √© bem simples, mas precisa seguir uma estrutura espec√≠fica. Toda vez que voc√™ quiser usar uma fun√ß√£o, voc√™ deve incluir par√™nteses ap√≥s o nome da fun√ß√£o.\n\n```{python}\n#| eval: false\nnome_da_funcao()\n```\n\n### Fun√ß√µes com par√¢metros\n\nAs fun√ß√µes podem receber par√¢metros, que s√£o os valores que voc√™ passa para elas para que possam realizar algum processamento. Esses par√¢metros s√£o colocados dentro dos par√™nteses ao chamar a fun√ß√£o.\n\n```{python}\n#| eval: false\nnome_da_funcao(parametro_1, parametro_2, ...)\n```\n\n### Fun√ß√µes sem par√¢metro\n\nAlgumas fun√ß√µes n√£o exigem nenhum par√¢metro. Nesse caso, voc√™ ainda deve usar os par√™nteses ao chamar a fun√ß√£o, mas n√£o h√° necessidade de colocar nada dentro deles.\n\n```{python}\n#| eval: false\nnome_da_funcao()\n```\n\n### Fun√ß√µes com retorno\n\nFun√ß√µes podem retornar um valor ap√≥s a execu√ß√£o. O valor retornado pode ser armazenado em uma vari√°vel ou utilizado diretamente em c√°lculos ou outras opera√ß√µes.\n\nQuando uma fun√ß√£o tem retorno, a sintaxe para us√°-la fica da seguinte forma:\n\n```{python}\n#| eval: false\nvariavel = nome_da_funcao(parametros)\n```\n\n### Fun√ß√µes com par√¢metros opcionais\n\n√Äs vezes, as fun√ß√µes podem ter par√¢metros com valores padr√£o, o que significa que, se voc√™ n√£o passar um valor para aquele par√¢metro, o Python usar√° algum valor pr√©-definido.\n\nOu seja, se temos uma fun√ß√£o, por exemplo, que tem um par√¢metro \"parametro_1\" pr√©-definido para o valor 10, se um novo valor de a n√£o for especificado na chamada, da seguinte forma:\n\n```{python}\n#| eval: false\nnome_da_funcao(parametro_1 = 3)\n```\n\nA fun√ß√£o √© executada com o valor de \"parametro_1\" igual a 10.\n\n## Exerc√≠cios\n\n### Exerc√≠cio 1\n\nImagine uma fun√ß√£o que calcule a soma de dois n√∫meros. Quais seriam as entradas e sa√≠das dessa fun√ß√£o? Quais s√£o os poss√≠veis tipos de dados que esta fun√ß√£o aceita? \n\n::: {.callout-tip collapse=\"true\" title=\"Ver Solu√ß√£o\"}\n\nEntradas e sa√≠das:\n\n| -------- | ------------------ |\n| entradas | dois n√∫meros: a, b |\n| sa√≠das   | a soma de a e b    |\n\na e b poderiam ser n√∫meros inteiros ou floats, mas provavelmente n√£o faria muito sentido eles serem diferentes disto.\n\n:::\n\n### Exerc√≠cio 2\n\nComo a defini√ß√£o de fun√ß√µes pode tornar a manuten√ß√£o de um c√≥digo mais f√°cil? Quais problemas podem surgir se n√£o usarmos fun√ß√µes e acabarmos repetindo o mesmo c√≥digo em v√°rias partes do programa?\n\n::: {.callout-tip collapse=\"true\" title=\"Ver Solu√ß√£o\"}\n\nA defini√ß√£o de fun√ß√µes torna um codigo muito mais simples, pois se o c√≥digo da fun√ß√£o est√° errado, √© necess√°rio alter√°-lo em somente um lugar, evitando com que partes estejam corretas e partes estejam incorretas. Caso n√£o sejam utilizadas fun√ß√µes em c√≥digo, √© poss√≠vel que a repeti√ß√£o de trechos de c√≥digo leve a problemas que s√£o praticmanete imposs√≠veis de rastrear.\n\n:::\n\n### Exerc√≠cio 3\n\nImagine que voc√™ tenha pontos 3D no espa√ßo. A f√≥rmula para calcular a dist√¢ncia entre dois destes pontos ($P1(x_1, y_1, z_1)$ e $P2(x_2, y_2, z_2)$) √© a seguinte:\n\n$$\nd(P1, P2) = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2} \n$$\n\nComo isto poderia ser adaptado para uma fun√ß√£o (quais entradas e sa√≠das)?\n\n::: {.callout-tip collapse=\"true\" title=\"Ver Solu√ß√£o\"}\n\nPara adaptar isto para fun√ß√£o, √© necess√°rio somente que as entradas sejam os dois pontos ($P1$ e $P2$), pois com eles ser√° feito o processamento de coordenadas para retornar, como sa√≠da, a dist√¢ncia entre eles.\n\n:::\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"IntroducaoAFuncoes.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.25","theme":"../costumizacao.scss","title":"Introdu√ß√£o √† fun√ß√µes","toc-title":"Conte√∫dos da p√°gina"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}