{"title":"Representações de Algorítmos","markdown":{"yaml":{"title":"Representações de Algorítmos","toc":true,"toc-title":"Conteúdos da página"},"headingText":"Pseudocódigo","containsRefs":false,"markdown":"\n\n\nO pseudocódigo é uma forma simplificada e estruturada de descrever um algoritmo, usando uma linguagem próxima da linguagem humana, mas organizada de maneira lógica, semelhante à de um programa de computador. Ele serve como uma ponte entre o pensamento humano e a linguagem de programação, permitindo que a lógica de um problema seja planejada antes de ser implementada em código real.\n\nEm vez de usar uma sintaxe rígida e regras específicas de uma linguagem (como Python, Java ou C++), o pseudocódigo utiliza palavras e estruturas genéricas, fáceis de entender por qualquer pessoa com conhecimentos básicos de programação. O foco principal está em comunicar claramente os passos que devem ser seguidos para resolver um problema, e não em detalhes técnicos de implementação.\n\nPor exemplo, um algoritmo para somar dois números pode ser escrito em pseudocódigo assim:\n\n```{ObjectiveC}\nINÍCIO\n  LER número1\n  LER número2\n  SOMA ← número1 + número2\n  ESCREVER \"O resultado é:\", SOMA\nFIM\n```\n\n\nEsse exemplo mostra claramente o que o algoritmo faz, sem se preocupar com a linguagem de programação usada. Ele é fácil de compreender e de transformar depois em código real.\n\nO pseudocódigo também é amplamente usado no planejamento e ensino da lógica de programação, pois ajuda os estudantes e desenvolvedores a raciocinar sobre a sequência de passos de um problema sem se preocupar com erros de sintaxe.\n\nEm resumo, o pseudocódigo é uma ferramenta de planejamento e comunicação, que permite expressar ideias e soluções de forma estruturada, lógica e compreensível, sendo o primeiro passo natural antes da escrita do código em uma linguagem de programação real.\n\n### Condicionais em Pseudocódigo\n\nAs estruturas condicionais são essenciais para a tomada de decisões dentro de um algoritmo. Elas permitem que o fluxo de execução de um programa siga diferentes caminhos, dependendo de uma condição ser verdadeira ou falsa.\n\n### Condicional Simples (SE)\n\nA estrutura condicional mais simples é o SE. Ela permite que uma ação seja executada apenas quando uma condição for verdadeira.\n\nExemplo de pseudocódigo com condicional simples:\n\n```{ObjectiveC}\nINÍCIO\n  LER idade\n  SE idade >= 18 ENTÃO\n    ESCREVER \"Maior de idade\"\n  FIM SE\nFIM\n```\n\nNeste exemplo, o algoritmo lê a idade de uma pessoa e, caso a idade seja maior ou igual a 18, exibe a mensagem \"Maior de idade\". Se a condição não for satisfeita, nada é executado.\n\n### Condicional com SENÃO\n\nA estrutura condicional SE...SENÃO permite definir um caminho alternativo a ser seguido caso a condição não seja verdadeira.\n\nExemplo de pseudocódigo com SE...SENÃO:\n\n```{ObjectiveC}\nINÍCIO\n  LER idade\n  SE idade >= 18 ENTÃO\n    ESCREVER \"Maior de idade\"\n  SENÃO\n    ESCREVER \"Menor de idade\"\n  FIM SE\nFIM\n```\n\nAqui, o algoritmo verifica se a pessoa é maior de idade. Caso a condição idade >= 18 seja verdadeira, ele imprime \"Maior de idade\". Caso contrário, imprime \"Menor de idade\".\n\n### Condicional com múltiplas alternativas (SE...SENÃO SE...SENÃO)\n\nEm alguns casos, é necessário avaliar várias condições em sequência. Para isso, podemos usar a estrutura SE...SENÃO SE...SENÃO.\n\nExemplo de pseudocódigo com múltiplas alternativas:\n\n```{ObjectiveC}\nINÍCIO\n  LER nota\n  SE nota >= 9 ENTÃO\n    ESCREVER \"Excelente\"\n  SENÃO SE nota >= 7 ENTÃO\n    ESCREVER \"Bom\"\n  SENÃO SE nota >= 5 ENTÃO\n    ESCREVER \"Regular\"\n  SENÃO\n    ESCREVER \"Reprovado\"\n  FIM SE\nFIM\n```\n\n\nEste exemplo verifica a nota de um aluno e classifica-o em uma das categorias: \"Excelente\", \"Bom\", \"Regular\" ou \"Reprovado\". A estrutura SE...SENÃO SE...SENÃO permite verificar várias condições sequencialmente.\n\n### Condicionais Aninhadas\n\nÀs vezes, uma condição pode ser aninhada dentro de outra, ou seja, uma estrutura SE pode conter outra estrutura SE dentro de sua parte SENÃO.\n\nExemplo de pseudocódigo com condicional aninhada:\n\n```{ObjectiveC}\nINÍCIO\n  LER idade\n  SE idade >= 18 ENTÃO\n    LER salario\n    SE salario >= 5000 ENTÃO\n      ESCREVER \"Maior de idade e alta renda\"\n    SENÃO\n      ESCREVER \"Maior de idade, mas baixa renda\"\n    FIM SE\n  SENÃO\n    ESCREVER \"Menor de idade\"\n  FIM SE\nFIM\n```\n\nAqui, o algoritmo verifica se a pessoa é maior de idade. Se for, ele então verifica o salário da pessoa. Caso o salário seja maior ou igual a 5000, ele imprime \"Maior de idade e alta renda\"; caso contrário, imprime \"Maior de idade, mas baixa renda\". Se a pessoa for menor de idade, o programa imprime \"Menor de idade\".\n\n### Estruturas de repetição em pseudocódigo\n\nAs estruturas de repetição são fundamentais para a execução de um bloco de código várias vezes, até que uma condição seja atendida. Elas são especialmente úteis quando se tem tarefas repetitivas ou quando se precisa de uma sequência de ações que dependem de algum critério, como a contagem ou uma verificação lógica.\n\nEm pseudocódigo, as repetições são implementadas de forma simples, com estruturas que controlam a execução repetida de comandos. Vamos explorar as formas mais comuns de estrutura de repetição.\n\n### Repetição Controlada por Condição (Enquanto - ENQUANTO)\n\nA estrutura ENQUANTO (ou WHILE em algumas linguagens de programação) permite que um conjunto de ações seja repetido enquanto uma condição for verdadeira. Quando a condição se torna falsa, o loop é interrompido.\n\nExemplo de pseudocódigo com repetição controlada por condição:\n\n```{ObjectiveC}\nINÍCIO\n  LER número\n  ENQUANTO número >= 0 FAÇA\n    SOMA ← SOMA + número\n    LER número\n  FIM ENQUANTO\n  ESCREVER \"A soma dos números positivos é:\", SOMA\nFIM\n```\n\n\nNeste exemplo, o algoritmo lê números e vai somando-os enquanto o número informado for maior ou igual a zero. Quando um número negativo for digitado, o laço termina e o programa exibe a soma dos números positivos informados.\n\n### Repetição Controlada por Contagem (Para - PARA)\n\nA estrutura PARA (ou FOR) é usada quando você sabe o número de vezes que deseja repetir um conjunto de ações. Ela é controlada por um contador que incrementa ou decrementa a cada iteração, até atingir um limite predefinido.\n\nExemplo de pseudocódigo com repetição controlada por contagem:\n\n```{ObjectiveC}\nINÍCIO\n  LER n\n  PARA i ← 1 ATÉ n FAÇA\n    ESCREVER \"Repetição número:\", i\n  FIM PARA\nFIM\n```\n\nNeste exemplo, o algoritmo vai repetir o processo de exibição da mensagem \"Repetição número: i\" um número de vezes igual a n, onde i vai de 1 até o valor de n.\n\n## Fluxogramas\n\nFluxograma: é um tipo de diagrama, e pode ser entendido como uma representação esquemática de um processo ou algoritmo, muitas vezes feito através de gráficos que ilustram de forma descomplicada a transição de informações entre os elementos que o compõem, ou seja, é a sequência operacional do desenvolvimento de um processo, o qual caracteriza: o trabalho que está sendo realizado, o tempo necessário para sua realização, a distância percorrida pelos documentos, quem está realizando o trabalho e como ele flui entre os participantes deste processo.\n\nOs fluxogramas são muito utilizados em projetos de software para representar a lógica interna dos programas, mas podem também ser usados para desenhar processos de negócio e o workflow que envolve diversos atores corporativos no exercício de suas atribuições.[1]\n\nO diagrama de fluxo de dados (DFD) utiliza do fluxograma para modelagem e documentação de sistemas computacionais.\n\nO termo fluxograma designa uma representação gráfica de um determinado processo ou fluxo de trabalho, efetuado geralmente com recurso a figuras geométricas normalizadas e as setas unindo essas figuras geométricas. Através desta representação gráfica é possível compreender de forma rápida e fácil a transição de informações ou documentos entre os elementos que participam no processo em causa.\n\nO fluxograma pode ser definido também como o gráfico em que se representa o percurso ou caminho percorrido por certo elemento (por exemplo, um determinado documento), através dos vários departamentos da organização, bem como o tratamento que cada um vai lhe dando.\n\nA existência de fluxogramas para cada um dos processos é fundamental para a simplificação e racionalização do trabalho, permitindo a compreensão e posterior otimização dos processos desenvolvidos em cada departamento ou área da organização.\n\n### Funcionamento de fluxogramas simples\n\nTodos os fluxogramas possuem setas, que indicam para o onde a sequência lógica de execução do programa segue. Entre estas setas estão localizados nós, que podem ser agrupados em certos tipos:\n\n* Início/Fim: Indicam onde o fluxograma começa e onde o fluxograma termina.\n\n* Entrada de dados/Definição de dados: Indica quais dados serão utilizados e como devem ser definidos (seus nomes e possíveis valores).\n\n* Processamento de dados: Indica a lógica que deve ser efetuada com os dados do programa.\n\n\n#### Exemplo de fluxograma\n\nDescrição do algoritmo: Ler dois números (a e b), calcular a soma dos dois e armazenar o resultado em um terceiro número, c.\n\n<div style=\"text-align: center;\">\n\n```{mermaid}\nflowchart TD\nA([Início]) --> B[/entrada de dados em a/]\nB --> C[/entrada de dados em b/]\nC --> D[\"c = a + b\"]\nD --> E([Fim])\n```\n\n</div>\n\n### Fluxogramas com estruturas condicionais simples\n\nNos fluxogramas, as estruturas condicionais são representadas de forma visual, permitindo compreender facilmente os pontos de decisão dentro de um processo. Em vez de apenas mostrar uma sequência linear de ações, o fluxograma passa a indicar bifurcações — momentos em que o fluxo pode seguir por caminhos diferentes dependendo de um resultado lógico.\n\nA condicional é representada pelo losango (◇), símbolo universal usado para indicar uma decisão.\nDentro dele, é escrita a condição que será avaliada — por exemplo, “Idade ≥ 18?”.\nA partir do losango, saem normalmente duas setas, correspondendo às possíveis respostas da verificação:\n\n* Uma seta para o caminho verdadeiro (geralmente marcada com \"Sim\", “Verdadeiro” ou “True”).\n\n* Outra seta para o caminho falso (marcada com “Não”, \"Falso\" ou “False”).\n\nCada um desses caminhos leva a blocos diferentes de instruções, que mostram o que o algoritmo deve fazer em cada situação.\nDepois de executadas as ações correspondentes, dependendo do algoritmo, os caminhos se unem novamente ou não (antes do fim).\n\nEssa forma de representação torna as decisões fáceis de visualizar, permitindo que qualquer pessoa — mesmo sem conhecer o código — entenda rapidamente onde o processo toma decisões e quais são as possíveis consequências de cada escolha.\n\n#### Exemplo de fluxograma com condicional\n\nDescrição do algoritmo: Ler a idade de uma pessoa e determinar se ela é maior de idade (idade ≥ 18).\n\n<div style=\"text-align: center;\">\n\n```{mermaid}\nflowchart TD\nA([Início]) --> B[/Ler idade/]\nB --> C{Idade >= 18?}\nC -->|Verdadeiro| D[\"Exibir: Maior de idade\"]\nC -->|Falso| E[\"Exibir: Menor de idade\"]\nD --> F([Fim])\nE --> F\n```\n\n</div>\n\n::: {.callout-note title=\"Observação\"}\n\nAs estruturas condicionais são os principais elementos que conferem ramificações aos fluxogramas. Elas tornam o diagrama mais próximo da lógica real dos algoritmos, destacando pontos de decisão e possíveis alternativas de execução dentro do processo.\n\n:::\n\n### Fluxogramas com estruturas condicionais encadeadas\n\nEm muitos casos, um algoritmo não toma apenas uma decisão — ele precisa avaliar várias condições em sequência.\nQuando isso acontece, o fluxograma apresenta condicionais encadeadas, ou seja, um losango levando a outro, formando uma cadeia de verificações.\nCada decisão depende do resultado da anterior, e o fluxo do processo segue até que todas as verificações tenham sido realizadas.\n\nEsse tipo de estrutura é comum em algoritmos que precisam classificar situações, determinar categorias ou escolher entre múltiplas alternativas.\nVisualmente, o fluxograma vai mostrando as “encruzilhadas” do processo, permitindo acompanhar a sequência de perguntas e respostas até chegar ao resultado final.\n\n#### Exemplo de fluxograma com condicionais encadeadas\n\nDescrição do algortmo: Descobrir qual o desempenho de um aluno com base na sua nota final, categorizando-o entre Excelente, Bom, Regular e Reprovado.\n\n1. Verificar se a nota é maior ou igual a 9 — caso seja, classificar como “Excelente”.\n\n2. Se não for, verificar se é maior ou igual a 7 — classificar como “Bom”.\n\n3. Caso contrário, verificar se é maior ou igual a 5 — classificar como “Regular”.\n\n4. Se nenhuma das condições anteriores for atendida, o resultado será “Reprovado”.\n\nEssa representação mostra claramente que cada decisão leva a outra, até que o algoritmo encontre a condição que se aplica à situação analisada.\n\n<div style=\"text-align: center;\">\n\n```{mermaid}\nflowchart TD\nA([Início]) --> B[/Ler nota/]\nB --> C{Nota >= 9?}\nC -->|Verdadeiro| D[\"Exibir: Excelente\"]\nC -->|Falso| E{Nota >= 7?}\nE -->|Verdadeiro| F[\"Exibir: Bom\"]\nE -->|Falso| G{Nota >= 5?}\nG -->|Verdadeiro| H[\"Exibir: Regular\"]\nG -->|Falso| I[\"Exibir: Reprovado\"]\nD --> J([Fim])\nF --> J\nH --> J\nI --> J\n```\n\n</div>\n\n::: {.callout-note title=\"Observação\"}\n\nEssas cadeias de decisões tornam os fluxogramas especialmente úteis para entender lógicas complexas de forma visual e intuitiva, facilitando o planejamento e a comunicação de algoritmos com múltiplos critérios de decisão.\n\n:::\n\n### Fluxogramas com estruturas de repetição simples\n\nNos fluxogramas, as estruturas de repetição representam situações em que um conjunto de ações precisa ser executado diversas vezes, de forma controlada. Essas estruturas são fundamentais em algoritmos, pois permitem automatizar tarefas repetitivas e economizar etapas no processo lógico.\n\nVisualmente, a repetição é representada por um ciclo dentro do fluxograma, no qual o fluxo retorna a uma etapa anterior, formando um laço. Esse retorno é o que caracteriza o comportamento repetitivo da estrutura.\n\n#### Representação gráfica\n\nA estrutura de repetição é geralmente associada ao losango (◇), o mesmo símbolo usado para decisões, já que a repetição depende de uma condição lógica que determina se o ciclo continuará ou não. Enquanto a condição for verdadeira, o fluxo retorna ao início do bloco de instruções; quando a condição se torna falsa, o fluxo segue adiante, saindo do laço.\n\nIsso torna as estruturas de repetição visualmente distintas das condicionais simples: nelas, há um caminho que volta para um ponto anterior do fluxograma, evidenciando a ideia de repetição.\n\n#### Tipos de repetição representados em fluxogramas\n\nExistem diferentes formas de ilustrar a repetição em fluxogramas, de acordo com a lógica do algoritmo:\n\nRepetição controlada por condição (tipo “enquanto”) – O ciclo repete enquanto uma condição for verdadeira.\nO teste é feito antes da execução do bloco de instruções.\n\nRepetição controlada por contagem (tipo “para”) – O ciclo se repete um número pré-determinado de vezes.\nVisualmente, o laço indica que o fluxo volta até que o contador atinja o limite definido.\n\n#### Exemplo de fluxograma com repetição\n\nDescrição do algoritmo: Ler uma sequência de números e somá-los enquanto o número informado for positivo. Quando um número negativo for digitado, o processo deve parar e o resultado final ser exibido.\n\n<div style=\"text-align: center;\">\n\n```{mermaid}\nflowchart TD\nA([Início]) --> B[\"Soma = 0\"]\nB --> C[/Ler número/]\nC --> D{Número >= 0?}\nD -->|Verdadeiro| E[\"Soma = Soma + Número\"]\nE --> C\nD -->|Falso| F[\"Exibir Soma\"]\nF --> G([Fim])\n```\n\n</div>\n\n##### Interpretação\n\nNeste fluxograma, o losango representa a condição “Número ≥ 0?”.\nEnquanto essa condição é verdadeira, o fluxo retorna para a leitura de novos números, repetindo as etapas de leitura e soma.\nQuando a condição se torna falsa (ou seja, um número negativo é digitado), o laço é interrompido e o programa segue para o encerramento.\n\n## Exercícios\n\n### Exercício 1\n\nTransforme o pseudocódigo abaixo em fluxograma:\n\n```{Objectivec}\nINÍCIO\n  LER número1\n  LER número2\n  SE número1 > número2\n    ESCREVER \"Entre os números, o maior é: \", número1\n  SENÃO\n    ESCREVER \"Entre os números, ou são iguais ou o maior é: \", número2\n  FIM SE\nFIM\n```\n\n::: {.callout-tip collapse=\"true\" title=\"Ver Solução\"}\n\n![PNG](imagens/fluxogramafudidopqp.png)\n\n:::\n\n### Exercício 2\n\nAbaixo estão um pseudocógio e um floxograma:\n\n::: {.columns}\n\n::: {.column}\n\n### Fluxograma\n\n```{mermaid}\nflowchart TD\nA([Inicio]) --> B[\"a = 0\"]\nB --> C{a < 3?}\nC -->|Verdadeiro| D[\"a = a + 1\"]\nC -->|Falso| E([Fim])\nD --> C\n```\n\n:::\n\n::: {.column}\n\n### Pseudocódigo\n\n```{ObjectiveC}\nINÍCIO\n  a ← 0\n  ENQUANTO a < 3 FAÇA\n    a ← a + 1\n  FIM ENQUANTO\nFIM\n```\n\n:::\n\n:::\n\n::: {.callout-tip collapse=\"true\" title=\"Ver Solução\"}\n\nSim.\n\nNo fluxograma, temos um valor a = 0, e, enquanto ele é menor que 3 ele é incrementado por 1. No momento que seu valor atinge 3, o algortimo termina, pois a condição \"a < 3\" se torna falsa. No pseudocódigo temos o mesmo efeito, pois assim que a assume o valor 3, o ENQUANTO acaba.\n\n:::\n\n### Exercício 3\n\nCom base no algorítmo abaixo responda:\n\n```{mermaid}\nflowchart TD\nA([Início]) --> B[/Ler um número/]\nB --> C{Número < 0?}\nC -->|Sim| D[\"Exibir: Número negativo\"]\nC -->|Não| E{Número <= 50?}\nE -->|Sim| F[\"Exibir: Faixa 1\"]\nE -->|Não| G{Número <= 100?}\nG -->|Sim| H[\"Exibir: Faixa 2\"]\nG -->|Não| I[\"Exibir: Número fora da faixa permitida\"]\nD --> J([Fim])\nF --> J\nH --> J\nI --> B\n```\n\n1. O que este algoritmo faz?\n\n::: {.callout-tip collapse=\"true\" title=\"Ver Solução\"}\n\nEle lê um número e checa se este número está dentro da faixa aceitável de entradas, sendo a faixa: $(-\\infty, 100]$. Caso um número esteja fora da faixa, o algoritmo é repetido, até que um número válido seja lido.\n\n:::\n\n2. O que acontecerá se o número lido pelo algoritmo fosse 105?\n\n::: {.callout-tip collapse=\"true\" title=\"Ver Solução\"}\n\nComo números maiores que 100 serão classificados como números fora da faixa, o resultado será uma repetição do algoritmo, lendo novamente o número para checar se ele está na faixa aceitável.\n\n:::\n","srcMarkdownNoYaml":"\n\n## Pseudocódigo\n\nO pseudocódigo é uma forma simplificada e estruturada de descrever um algoritmo, usando uma linguagem próxima da linguagem humana, mas organizada de maneira lógica, semelhante à de um programa de computador. Ele serve como uma ponte entre o pensamento humano e a linguagem de programação, permitindo que a lógica de um problema seja planejada antes de ser implementada em código real.\n\nEm vez de usar uma sintaxe rígida e regras específicas de uma linguagem (como Python, Java ou C++), o pseudocódigo utiliza palavras e estruturas genéricas, fáceis de entender por qualquer pessoa com conhecimentos básicos de programação. O foco principal está em comunicar claramente os passos que devem ser seguidos para resolver um problema, e não em detalhes técnicos de implementação.\n\nPor exemplo, um algoritmo para somar dois números pode ser escrito em pseudocódigo assim:\n\n```{ObjectiveC}\nINÍCIO\n  LER número1\n  LER número2\n  SOMA ← número1 + número2\n  ESCREVER \"O resultado é:\", SOMA\nFIM\n```\n\n\nEsse exemplo mostra claramente o que o algoritmo faz, sem se preocupar com a linguagem de programação usada. Ele é fácil de compreender e de transformar depois em código real.\n\nO pseudocódigo também é amplamente usado no planejamento e ensino da lógica de programação, pois ajuda os estudantes e desenvolvedores a raciocinar sobre a sequência de passos de um problema sem se preocupar com erros de sintaxe.\n\nEm resumo, o pseudocódigo é uma ferramenta de planejamento e comunicação, que permite expressar ideias e soluções de forma estruturada, lógica e compreensível, sendo o primeiro passo natural antes da escrita do código em uma linguagem de programação real.\n\n### Condicionais em Pseudocódigo\n\nAs estruturas condicionais são essenciais para a tomada de decisões dentro de um algoritmo. Elas permitem que o fluxo de execução de um programa siga diferentes caminhos, dependendo de uma condição ser verdadeira ou falsa.\n\n### Condicional Simples (SE)\n\nA estrutura condicional mais simples é o SE. Ela permite que uma ação seja executada apenas quando uma condição for verdadeira.\n\nExemplo de pseudocódigo com condicional simples:\n\n```{ObjectiveC}\nINÍCIO\n  LER idade\n  SE idade >= 18 ENTÃO\n    ESCREVER \"Maior de idade\"\n  FIM SE\nFIM\n```\n\nNeste exemplo, o algoritmo lê a idade de uma pessoa e, caso a idade seja maior ou igual a 18, exibe a mensagem \"Maior de idade\". Se a condição não for satisfeita, nada é executado.\n\n### Condicional com SENÃO\n\nA estrutura condicional SE...SENÃO permite definir um caminho alternativo a ser seguido caso a condição não seja verdadeira.\n\nExemplo de pseudocódigo com SE...SENÃO:\n\n```{ObjectiveC}\nINÍCIO\n  LER idade\n  SE idade >= 18 ENTÃO\n    ESCREVER \"Maior de idade\"\n  SENÃO\n    ESCREVER \"Menor de idade\"\n  FIM SE\nFIM\n```\n\nAqui, o algoritmo verifica se a pessoa é maior de idade. Caso a condição idade >= 18 seja verdadeira, ele imprime \"Maior de idade\". Caso contrário, imprime \"Menor de idade\".\n\n### Condicional com múltiplas alternativas (SE...SENÃO SE...SENÃO)\n\nEm alguns casos, é necessário avaliar várias condições em sequência. Para isso, podemos usar a estrutura SE...SENÃO SE...SENÃO.\n\nExemplo de pseudocódigo com múltiplas alternativas:\n\n```{ObjectiveC}\nINÍCIO\n  LER nota\n  SE nota >= 9 ENTÃO\n    ESCREVER \"Excelente\"\n  SENÃO SE nota >= 7 ENTÃO\n    ESCREVER \"Bom\"\n  SENÃO SE nota >= 5 ENTÃO\n    ESCREVER \"Regular\"\n  SENÃO\n    ESCREVER \"Reprovado\"\n  FIM SE\nFIM\n```\n\n\nEste exemplo verifica a nota de um aluno e classifica-o em uma das categorias: \"Excelente\", \"Bom\", \"Regular\" ou \"Reprovado\". A estrutura SE...SENÃO SE...SENÃO permite verificar várias condições sequencialmente.\n\n### Condicionais Aninhadas\n\nÀs vezes, uma condição pode ser aninhada dentro de outra, ou seja, uma estrutura SE pode conter outra estrutura SE dentro de sua parte SENÃO.\n\nExemplo de pseudocódigo com condicional aninhada:\n\n```{ObjectiveC}\nINÍCIO\n  LER idade\n  SE idade >= 18 ENTÃO\n    LER salario\n    SE salario >= 5000 ENTÃO\n      ESCREVER \"Maior de idade e alta renda\"\n    SENÃO\n      ESCREVER \"Maior de idade, mas baixa renda\"\n    FIM SE\n  SENÃO\n    ESCREVER \"Menor de idade\"\n  FIM SE\nFIM\n```\n\nAqui, o algoritmo verifica se a pessoa é maior de idade. Se for, ele então verifica o salário da pessoa. Caso o salário seja maior ou igual a 5000, ele imprime \"Maior de idade e alta renda\"; caso contrário, imprime \"Maior de idade, mas baixa renda\". Se a pessoa for menor de idade, o programa imprime \"Menor de idade\".\n\n### Estruturas de repetição em pseudocódigo\n\nAs estruturas de repetição são fundamentais para a execução de um bloco de código várias vezes, até que uma condição seja atendida. Elas são especialmente úteis quando se tem tarefas repetitivas ou quando se precisa de uma sequência de ações que dependem de algum critério, como a contagem ou uma verificação lógica.\n\nEm pseudocódigo, as repetições são implementadas de forma simples, com estruturas que controlam a execução repetida de comandos. Vamos explorar as formas mais comuns de estrutura de repetição.\n\n### Repetição Controlada por Condição (Enquanto - ENQUANTO)\n\nA estrutura ENQUANTO (ou WHILE em algumas linguagens de programação) permite que um conjunto de ações seja repetido enquanto uma condição for verdadeira. Quando a condição se torna falsa, o loop é interrompido.\n\nExemplo de pseudocódigo com repetição controlada por condição:\n\n```{ObjectiveC}\nINÍCIO\n  LER número\n  ENQUANTO número >= 0 FAÇA\n    SOMA ← SOMA + número\n    LER número\n  FIM ENQUANTO\n  ESCREVER \"A soma dos números positivos é:\", SOMA\nFIM\n```\n\n\nNeste exemplo, o algoritmo lê números e vai somando-os enquanto o número informado for maior ou igual a zero. Quando um número negativo for digitado, o laço termina e o programa exibe a soma dos números positivos informados.\n\n### Repetição Controlada por Contagem (Para - PARA)\n\nA estrutura PARA (ou FOR) é usada quando você sabe o número de vezes que deseja repetir um conjunto de ações. Ela é controlada por um contador que incrementa ou decrementa a cada iteração, até atingir um limite predefinido.\n\nExemplo de pseudocódigo com repetição controlada por contagem:\n\n```{ObjectiveC}\nINÍCIO\n  LER n\n  PARA i ← 1 ATÉ n FAÇA\n    ESCREVER \"Repetição número:\", i\n  FIM PARA\nFIM\n```\n\nNeste exemplo, o algoritmo vai repetir o processo de exibição da mensagem \"Repetição número: i\" um número de vezes igual a n, onde i vai de 1 até o valor de n.\n\n## Fluxogramas\n\nFluxograma: é um tipo de diagrama, e pode ser entendido como uma representação esquemática de um processo ou algoritmo, muitas vezes feito através de gráficos que ilustram de forma descomplicada a transição de informações entre os elementos que o compõem, ou seja, é a sequência operacional do desenvolvimento de um processo, o qual caracteriza: o trabalho que está sendo realizado, o tempo necessário para sua realização, a distância percorrida pelos documentos, quem está realizando o trabalho e como ele flui entre os participantes deste processo.\n\nOs fluxogramas são muito utilizados em projetos de software para representar a lógica interna dos programas, mas podem também ser usados para desenhar processos de negócio e o workflow que envolve diversos atores corporativos no exercício de suas atribuições.[1]\n\nO diagrama de fluxo de dados (DFD) utiliza do fluxograma para modelagem e documentação de sistemas computacionais.\n\nO termo fluxograma designa uma representação gráfica de um determinado processo ou fluxo de trabalho, efetuado geralmente com recurso a figuras geométricas normalizadas e as setas unindo essas figuras geométricas. Através desta representação gráfica é possível compreender de forma rápida e fácil a transição de informações ou documentos entre os elementos que participam no processo em causa.\n\nO fluxograma pode ser definido também como o gráfico em que se representa o percurso ou caminho percorrido por certo elemento (por exemplo, um determinado documento), através dos vários departamentos da organização, bem como o tratamento que cada um vai lhe dando.\n\nA existência de fluxogramas para cada um dos processos é fundamental para a simplificação e racionalização do trabalho, permitindo a compreensão e posterior otimização dos processos desenvolvidos em cada departamento ou área da organização.\n\n### Funcionamento de fluxogramas simples\n\nTodos os fluxogramas possuem setas, que indicam para o onde a sequência lógica de execução do programa segue. Entre estas setas estão localizados nós, que podem ser agrupados em certos tipos:\n\n* Início/Fim: Indicam onde o fluxograma começa e onde o fluxograma termina.\n\n* Entrada de dados/Definição de dados: Indica quais dados serão utilizados e como devem ser definidos (seus nomes e possíveis valores).\n\n* Processamento de dados: Indica a lógica que deve ser efetuada com os dados do programa.\n\n\n#### Exemplo de fluxograma\n\nDescrição do algoritmo: Ler dois números (a e b), calcular a soma dos dois e armazenar o resultado em um terceiro número, c.\n\n<div style=\"text-align: center;\">\n\n```{mermaid}\nflowchart TD\nA([Início]) --> B[/entrada de dados em a/]\nB --> C[/entrada de dados em b/]\nC --> D[\"c = a + b\"]\nD --> E([Fim])\n```\n\n</div>\n\n### Fluxogramas com estruturas condicionais simples\n\nNos fluxogramas, as estruturas condicionais são representadas de forma visual, permitindo compreender facilmente os pontos de decisão dentro de um processo. Em vez de apenas mostrar uma sequência linear de ações, o fluxograma passa a indicar bifurcações — momentos em que o fluxo pode seguir por caminhos diferentes dependendo de um resultado lógico.\n\nA condicional é representada pelo losango (◇), símbolo universal usado para indicar uma decisão.\nDentro dele, é escrita a condição que será avaliada — por exemplo, “Idade ≥ 18?”.\nA partir do losango, saem normalmente duas setas, correspondendo às possíveis respostas da verificação:\n\n* Uma seta para o caminho verdadeiro (geralmente marcada com \"Sim\", “Verdadeiro” ou “True”).\n\n* Outra seta para o caminho falso (marcada com “Não”, \"Falso\" ou “False”).\n\nCada um desses caminhos leva a blocos diferentes de instruções, que mostram o que o algoritmo deve fazer em cada situação.\nDepois de executadas as ações correspondentes, dependendo do algoritmo, os caminhos se unem novamente ou não (antes do fim).\n\nEssa forma de representação torna as decisões fáceis de visualizar, permitindo que qualquer pessoa — mesmo sem conhecer o código — entenda rapidamente onde o processo toma decisões e quais são as possíveis consequências de cada escolha.\n\n#### Exemplo de fluxograma com condicional\n\nDescrição do algoritmo: Ler a idade de uma pessoa e determinar se ela é maior de idade (idade ≥ 18).\n\n<div style=\"text-align: center;\">\n\n```{mermaid}\nflowchart TD\nA([Início]) --> B[/Ler idade/]\nB --> C{Idade >= 18?}\nC -->|Verdadeiro| D[\"Exibir: Maior de idade\"]\nC -->|Falso| E[\"Exibir: Menor de idade\"]\nD --> F([Fim])\nE --> F\n```\n\n</div>\n\n::: {.callout-note title=\"Observação\"}\n\nAs estruturas condicionais são os principais elementos que conferem ramificações aos fluxogramas. Elas tornam o diagrama mais próximo da lógica real dos algoritmos, destacando pontos de decisão e possíveis alternativas de execução dentro do processo.\n\n:::\n\n### Fluxogramas com estruturas condicionais encadeadas\n\nEm muitos casos, um algoritmo não toma apenas uma decisão — ele precisa avaliar várias condições em sequência.\nQuando isso acontece, o fluxograma apresenta condicionais encadeadas, ou seja, um losango levando a outro, formando uma cadeia de verificações.\nCada decisão depende do resultado da anterior, e o fluxo do processo segue até que todas as verificações tenham sido realizadas.\n\nEsse tipo de estrutura é comum em algoritmos que precisam classificar situações, determinar categorias ou escolher entre múltiplas alternativas.\nVisualmente, o fluxograma vai mostrando as “encruzilhadas” do processo, permitindo acompanhar a sequência de perguntas e respostas até chegar ao resultado final.\n\n#### Exemplo de fluxograma com condicionais encadeadas\n\nDescrição do algortmo: Descobrir qual o desempenho de um aluno com base na sua nota final, categorizando-o entre Excelente, Bom, Regular e Reprovado.\n\n1. Verificar se a nota é maior ou igual a 9 — caso seja, classificar como “Excelente”.\n\n2. Se não for, verificar se é maior ou igual a 7 — classificar como “Bom”.\n\n3. Caso contrário, verificar se é maior ou igual a 5 — classificar como “Regular”.\n\n4. Se nenhuma das condições anteriores for atendida, o resultado será “Reprovado”.\n\nEssa representação mostra claramente que cada decisão leva a outra, até que o algoritmo encontre a condição que se aplica à situação analisada.\n\n<div style=\"text-align: center;\">\n\n```{mermaid}\nflowchart TD\nA([Início]) --> B[/Ler nota/]\nB --> C{Nota >= 9?}\nC -->|Verdadeiro| D[\"Exibir: Excelente\"]\nC -->|Falso| E{Nota >= 7?}\nE -->|Verdadeiro| F[\"Exibir: Bom\"]\nE -->|Falso| G{Nota >= 5?}\nG -->|Verdadeiro| H[\"Exibir: Regular\"]\nG -->|Falso| I[\"Exibir: Reprovado\"]\nD --> J([Fim])\nF --> J\nH --> J\nI --> J\n```\n\n</div>\n\n::: {.callout-note title=\"Observação\"}\n\nEssas cadeias de decisões tornam os fluxogramas especialmente úteis para entender lógicas complexas de forma visual e intuitiva, facilitando o planejamento e a comunicação de algoritmos com múltiplos critérios de decisão.\n\n:::\n\n### Fluxogramas com estruturas de repetição simples\n\nNos fluxogramas, as estruturas de repetição representam situações em que um conjunto de ações precisa ser executado diversas vezes, de forma controlada. Essas estruturas são fundamentais em algoritmos, pois permitem automatizar tarefas repetitivas e economizar etapas no processo lógico.\n\nVisualmente, a repetição é representada por um ciclo dentro do fluxograma, no qual o fluxo retorna a uma etapa anterior, formando um laço. Esse retorno é o que caracteriza o comportamento repetitivo da estrutura.\n\n#### Representação gráfica\n\nA estrutura de repetição é geralmente associada ao losango (◇), o mesmo símbolo usado para decisões, já que a repetição depende de uma condição lógica que determina se o ciclo continuará ou não. Enquanto a condição for verdadeira, o fluxo retorna ao início do bloco de instruções; quando a condição se torna falsa, o fluxo segue adiante, saindo do laço.\n\nIsso torna as estruturas de repetição visualmente distintas das condicionais simples: nelas, há um caminho que volta para um ponto anterior do fluxograma, evidenciando a ideia de repetição.\n\n#### Tipos de repetição representados em fluxogramas\n\nExistem diferentes formas de ilustrar a repetição em fluxogramas, de acordo com a lógica do algoritmo:\n\nRepetição controlada por condição (tipo “enquanto”) – O ciclo repete enquanto uma condição for verdadeira.\nO teste é feito antes da execução do bloco de instruções.\n\nRepetição controlada por contagem (tipo “para”) – O ciclo se repete um número pré-determinado de vezes.\nVisualmente, o laço indica que o fluxo volta até que o contador atinja o limite definido.\n\n#### Exemplo de fluxograma com repetição\n\nDescrição do algoritmo: Ler uma sequência de números e somá-los enquanto o número informado for positivo. Quando um número negativo for digitado, o processo deve parar e o resultado final ser exibido.\n\n<div style=\"text-align: center;\">\n\n```{mermaid}\nflowchart TD\nA([Início]) --> B[\"Soma = 0\"]\nB --> C[/Ler número/]\nC --> D{Número >= 0?}\nD -->|Verdadeiro| E[\"Soma = Soma + Número\"]\nE --> C\nD -->|Falso| F[\"Exibir Soma\"]\nF --> G([Fim])\n```\n\n</div>\n\n##### Interpretação\n\nNeste fluxograma, o losango representa a condição “Número ≥ 0?”.\nEnquanto essa condição é verdadeira, o fluxo retorna para a leitura de novos números, repetindo as etapas de leitura e soma.\nQuando a condição se torna falsa (ou seja, um número negativo é digitado), o laço é interrompido e o programa segue para o encerramento.\n\n## Exercícios\n\n### Exercício 1\n\nTransforme o pseudocódigo abaixo em fluxograma:\n\n```{Objectivec}\nINÍCIO\n  LER número1\n  LER número2\n  SE número1 > número2\n    ESCREVER \"Entre os números, o maior é: \", número1\n  SENÃO\n    ESCREVER \"Entre os números, ou são iguais ou o maior é: \", número2\n  FIM SE\nFIM\n```\n\n::: {.callout-tip collapse=\"true\" title=\"Ver Solução\"}\n\n![PNG](imagens/fluxogramafudidopqp.png)\n\n:::\n\n### Exercício 2\n\nAbaixo estão um pseudocógio e um floxograma:\n\n::: {.columns}\n\n::: {.column}\n\n### Fluxograma\n\n```{mermaid}\nflowchart TD\nA([Inicio]) --> B[\"a = 0\"]\nB --> C{a < 3?}\nC -->|Verdadeiro| D[\"a = a + 1\"]\nC -->|Falso| E([Fim])\nD --> C\n```\n\n:::\n\n::: {.column}\n\n### Pseudocódigo\n\n```{ObjectiveC}\nINÍCIO\n  a ← 0\n  ENQUANTO a < 3 FAÇA\n    a ← a + 1\n  FIM ENQUANTO\nFIM\n```\n\n:::\n\n:::\n\n::: {.callout-tip collapse=\"true\" title=\"Ver Solução\"}\n\nSim.\n\nNo fluxograma, temos um valor a = 0, e, enquanto ele é menor que 3 ele é incrementado por 1. No momento que seu valor atinge 3, o algortimo termina, pois a condição \"a < 3\" se torna falsa. No pseudocódigo temos o mesmo efeito, pois assim que a assume o valor 3, o ENQUANTO acaba.\n\n:::\n\n### Exercício 3\n\nCom base no algorítmo abaixo responda:\n\n```{mermaid}\nflowchart TD\nA([Início]) --> B[/Ler um número/]\nB --> C{Número < 0?}\nC -->|Sim| D[\"Exibir: Número negativo\"]\nC -->|Não| E{Número <= 50?}\nE -->|Sim| F[\"Exibir: Faixa 1\"]\nE -->|Não| G{Número <= 100?}\nG -->|Sim| H[\"Exibir: Faixa 2\"]\nG -->|Não| I[\"Exibir: Número fora da faixa permitida\"]\nD --> J([Fim])\nF --> J\nH --> J\nI --> B\n```\n\n1. O que este algoritmo faz?\n\n::: {.callout-tip collapse=\"true\" title=\"Ver Solução\"}\n\nEle lê um número e checa se este número está dentro da faixa aceitável de entradas, sendo a faixa: $(-\\infty, 100]$. Caso um número esteja fora da faixa, o algoritmo é repetido, até que um número válido seja lido.\n\n:::\n\n2. O que acontecerá se o número lido pelo algoritmo fosse 105?\n\n::: {.callout-tip collapse=\"true\" title=\"Ver Solução\"}\n\nComo números maiores que 100 serão classificados como números fora da faixa, o resultado será uma repetição do algoritmo, lendo novamente o número para checar se ele está na faixa aceitável.\n\n:::\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"RepresentacoesDeAlgoritmos.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.25","theme":"../costumizacao.scss","title":"Representações de Algorítmos","toc-title":"Conteúdos da página"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}