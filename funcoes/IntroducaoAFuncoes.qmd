---
title: "Introdu√ß√£o √† fun√ß√µes"
toc: true
toc-title: "Conte√∫dos da p√°gina"
---

## Exemplo motivacional

Desde a antiguidade, matem√°ticos do mundo inteiro buscaram maneiras cada vez mais eficientes de calcular o valor de $\pi$. Esse n√∫mero, que nasce da geometria dos c√≠rculos, acabou se tornando essencial em √°reas como f√≠sica, computa√ß√£o, engenharia, astronomia e estat√≠stica. A busca por m√©todos r√°pidos e precisos para calcular $\pi$ √© t√£o antiga quanto a pr√≥pria matem√°tica, e evoluiu de formas surpreendentes ao longo da hist√≥ria.

Primeiro vieram as aproxima√ß√µes geom√©tricas, como as de Arquimedes. Mais tarde surgiram s√©ries matem√°ticas que, ao somar infinitos termos, aproximavam $\pi$ com cada vez mais precis√£o. Algumas dessas s√©ries funcionam, mas convergem t√£o lentamente que seriam impratic√°veis para c√°lculos modernos que exigem milh√µes ou bilh√µes de casas decimais.

O grande salto veio no s√©culo XX. O matem√°tico indiano Srinivasa Ramanujan descobriu f√≥rmulas extraordin√°rias, capazes de calcular $\pi$ com rapidez impressionante. D√©cadas depois, inspirado em seu trabalho, os irm√£os David e Gregory Chudnovsky desenvolveram uma f√≥rmula ainda mais eficiente. Ela se tornou a base dos recordes modernos de c√°lculo de $\pi$. V√°rios dos maiores valores j√° calculados ‚Äî contendo trilh√µes de d√≠gitos ‚Äî foram obtidos usando essa f√≥rmula.

O motivo? A f√≥rmula de Chudnovsky converge incrivelmente r√°pido. Cada termo adicionado √† s√©rie j√° √© suficiente para somar dezenas de casas decimais corretas.

A f√≥rmula de Chudnovsky √© a seguinte:

$$
\frac{1}{\pi} = 12 \sum_{n = 0}^{\infty} \frac{(-1)^n (6n)! (545140134n+13591409)}{(3n)!(n!)^3 640320^{3n + \frac{3}{2}}}
$$

Cada novo termo depende de algumas opera√ß√µes:

- um sinal alternado: $(-1)^n$

- um polin√¥mio: $545140134ùëõ +13591409$

- e, principalmente, fatoriais grandes, como

  * $(6n)!$

  * $(3n)!$

  * $(n!)^3$

Agora vamos tentar montar um programa simples para calcular um √∫nico termo desta s√©rie, utilizando somente os conhecimentos que possu√≠mos at√© o momento.

::: {.callout-note title="Tente fazer! (clique para revelar a solu√ß√£o)" collapse="true"}

```{python}
#| eval: false
# declara√ß√£o de n (como 0 para o primeiro termo da s√©rie)
n: int = 0

# C√°lculo do fatorial de 6n
fatorial_6n = 1
for i in range(1, 6 * n + 1):
    fatorial_6n *= i

# C√°lculo do fatorial de 3n
fatorial_3n = 1
for i in range(1, 3 * n + 1):
    fatorial_3n *= i

# C√°lculo do fatorial de n
fatorial_n = 1
for i in range(1, n + 1):
    fatorial_n *= i

# calcular o numerador do termo da s√©rie
numerador: float = ((-1) ** n) * fatorial_6n * ((545140134 * n) + 13591409)

# calcular o denominador do termo da s√©rie
denominador: float = fatorial_3n * (fatorial_n ** 3) * (640320 ** (3 * n)) * (640320 ** (1.5))

# calcular a divis√£o dos dois
termo_da_serie: float = numerador / denominador

# lembrando que 1/pi = 12 * termo_da_serie -> pi = 1/(12 * termo_da_serie)
print(1/(12 * termo_da_serie))
```

Caso n√£o tenha conseguido implementar este c√≥digo, **execute esta implementa√ß√£o na sua m√°quina** e busque entender o que est√° acontecendo exatamente.


H√° tamb√©m, um detalhe importante no c√°lcuo do denominador, onde foi utilizado a propriedade que $a^{b + c} = a^b \times a^c$ para reescrever $640320^{3n + \frac{3}{2}}$ como $640320^{3n} \times 640320^{\frac{3}{2}}$, para melhorar a precis√£o do resultado no computador.
:::

Ao escrever o c√≥digo dessa forma, percebemos uma situa√ß√£o curiosa: para calcular apenas um termo da s√©rie, tivemos que repetir v√°rias vezes exatamente o mesmo tipo de processo ‚Äî calcular o fatorial de um n√∫mero.

Veja que:

o c√°lculo de $(6n)!$ segue um passo a passo, o c√°lculo de $(3n)!$ segue o mesmo passo a passo e o c√°lculo de $n!$ tamb√©m segue o mesmo passo a passo!

A √∫nica coisa que muda entre eles √© qual n√∫mero estamos utilizando, mas o que est√° sendo calculado √© a mesma coisa: o fatorial.

Isso significa que estamos copiando e colando o mesmo racioc√≠nio v√°rias vezes, mudando s√≥ um detalhe.
Ou seja, estamos fazendo trabalho repetido, manual e desnecess√°rio.

E nos leva a duas reflex√µes:

#### 1. Estamos repetindo a mesma l√≥gica v√°rias vezes

Essa repeti√ß√£o j√° √© um problema por si s√≥, pois deixa o c√≥digo:

* mais longo

* mais dif√≠cil de ler

* mais cansativo de escrever

#### 2. Se algo estivesse errado, ter√≠amos que consertar em v√°rios lugares

Imagine agora que, por algum motivo, cometemos um erro na forma como escrevemos o c√°lculo do fatorial. Talvez tenhamos come√ßado o loop no n√∫mero errado, ou multiplicado na ordem incorreta, ou simplesmente esquecido um detalhe importante. (No c√≥digo acima tudo est√° correto ‚Äî estamos apenas imaginando um cen√°rio em que houvesse um erro.)

Como copiamos esse c√°lculo tr√™s vezes, esse erro estaria:

  * no fatorial de $6n$

  * no fatorial de $3n$

  * no fatorial de $n$

E ent√£o, para corrigir esse erro, precisar√≠amos:

  * lembrar de procurar cada trecho repetido

  * corrigir todos eles manualmente

  * garantir que n√£o esquecemos nenhum

Esse tipo de repeti√ß√£o √© uma grande fonte de bugs em programas reais.
Quanto mais partes iguais espalhadas pelo c√≥digo, maior a chance de:

  * esquecer de atualizar uma delas

  * corrigir uma vers√£o e deixar outra errada

  * criar inconsist√™ncias dif√≠ceis de rastrear

  * Ou seja: al√©m de trabalhoso, √© arriscado.

#### O que fazer?

Ser√° que precisamos reescrever todo esse processo sempre que quisermos calcular um fatorial diferente?

Seria muito mais pr√°tico se pud√©ssemos descrever esse processo uma √∫nica vez, de forma correta, e depois simplesmente pedir ao computador que o execute para qualquer n√∫mero.

Como se diss√©ssemos ao computador:

 > ‚ÄúEste √© o procedimento para calcular um fatorial. Sempre que eu precisar, eu te digo o n√∫mero e voc√™ faz isso pra mim.‚Äù

A programa√ß√£o oferece exatamente esse mecanismo:
a possibilidade de guardar um procedimento e reutiliz√°-lo sempre que necess√°rio, mudando apenas a informa√ß√£o de entrada.

Isso melhora tudo:

* evita repeti√ß√£o

* evita erros de manuten√ß√£o

* deixa o c√≥digo mais curto

* deixa o programa mais organizado

* diminui a chance de bugs

Esse mecanismo recebe um nome muito importante: **fun√ß√£o**.

## Introdu√ß√£o a fun√ß√µes

Ap√≥s ver o exemplo motivacional sobre o c√°lculo do fatorial, voc√™ provavelmente percebeu que, ao repetir o mesmo processo v√°rias vezes, estamos criando um c√≥digo dif√≠cil de manter, suscet√≠vel a erros e redundante. Uma solu√ß√£o muito poderosa para esse problema √© a utiliza√ß√£o de fun√ß√µes. As fun√ß√µes s√£o um dos conceitos mais importantes na programa√ß√£o, permitindo que voc√™ organize melhor o c√≥digo, evite repeti√ß√µes e torne o programa mais leg√≠vel.

Mas, o que s√£o fun√ß√µes exatamente? Como elas funcionam? Como voc√™ as usa de forma eficiente? Para responder a essas perguntas, vamos explorar os principais conceitos por tr√°s das fun√ß√µes, como entradas, sa√≠das, par√¢metros e retorno.

### O que √© uma fun√ß√£o ("formaliza√ß√£o")?

Uma fun√ß√£o √© um bloco de c√≥digo que realiza uma tarefa espec√≠fica. Podemos v√™-la como um pequeno algoritmo dentro do programa, que voc√™ pode usar v√°rias vezes, sempre que necess√°rio. Funciona da seguinte maneira:

* Entrada: A fun√ß√£o recebe alguns valores de entrada (chamados de par√¢metros).

* Processamento: A fun√ß√£o realiza um processo interno com esses valores (como um c√°lculo ou qualquer outra opera√ß√£o).

* Sa√≠da: A fun√ß√£o devolve um resultado (chamado de retorno), ou ent√£o realiza uma a√ß√£o sem devolver nada.

Vamos agora olhar mais a fundo para os diferentes componentes de uma fun√ß√£o, come√ßando pelas entradas, que s√£o essenciais para que a fun√ß√£o saiba o que fazer.

### Entradas de uma fun√ß√£o

Quando chamamos uma fun√ß√£o, passamos dados para ela. Esses dados s√£o chamados de par√¢metros. Eles s√£o valores que a fun√ß√£o usa para realizar seu trabalho. Pense nos par√¢metros como ingredientes que voc√™ passa para a fun√ß√£o, para que ela possa gerar um resultado. A principal vantagem dos par√¢metros √© que eles permitem que uma mesma fun√ß√£o seja usada de maneiras diferentes, dependendo do que voc√™ fornecer.

Exemplos do mundo real:

 * Receita de bolo:

    Ingredientes como a√ß√∫car, ovos e farinha s√£o os par√¢metros da receita. Se voc√™ quiser fazer um bolo diferente, basta alterar a quantidade de um ou mais ingredientes.

    A mesma receita pode ser usada para diferentes bolos, mudando apenas os par√¢metros (quantidade de a√ß√∫car, farinha, etc.).

* Aplicativo de mapas:

  Quando voc√™ pede para o app calcular a rota de ponto A at√© o ponto B, os endere√ßos de origem e destino s√£o os par√¢metros. O algoritmo de navega√ß√£o √© o mesmo, mas o ponto de partida e chegada que s√£o alterados.

* M√°quina de caf√©:

  Se voc√™ passar o par√¢metro "tipo de caf√©", a m√°quina pode preparar um caf√© espresso, um cappuccino ou um latte, dependendo do que voc√™ escolher. O processo de fazer o caf√© (aquecer a √°gua, misturar o p√≥ de caf√©, etc.) √© sempre o mesmo, mas o tipo de caf√© que voc√™ recebe vai depender do par√¢metro que voc√™ forneceu.

No contexto da programa√ß√£o, os par√¢metros permitem que uma fun√ß√£o tenha flexibilidade. A mesma fun√ß√£o pode ser chamada v√°rias vezes com valores diferentes e produzir resultados diferentes a partir dos mesmos passos internos.

No nosso exemplo do fatorial, o n√∫mero que queremos calcular o fatorial √© o par√¢metro. Em vez de escrever o c√°lculo de fatorial v√°rias vezes, com o n√∫mero alterando de vez em quando, passamos o n√∫mero como par√¢metro para a fun√ß√£o e ela faz o trabalho para n√≥s.

### Sa√≠das de uma fun√ß√£o: o retorno

Depois de executar o processo, a fun√ß√£o geralmente devolve um resultado. Esse resultado √© chamado de retorno. Dependendo do tipo de tarefa que a fun√ß√£o realiza, ela pode retornar:

* Um valor espec√≠fico, como um n√∫mero ou texto

* Nada (ou seja, ela realiza uma a√ß√£o mas n√£o retorna nenhum valor).

#### Fun√ß√µes com retorno:

Uma fun√ß√£o com retorno vai calcular algo com base nas entradas e devolver o resultado. Exemplos disso incluem:

* Calcular a soma de dois n√∫meros.

* Converter temperatura de Celsius para Fahrenheit.

* Calcular o fatorial de um n√∫mero.

Por exemplo, a fun√ß√£o que calcula o fatorial de um n√∫mero deve retornar o resultado do c√°lculo, para que possamos us√°-lo em outra parte do c√≥digo.

Fun√ß√µes sem retorno:

J√° uma fun√ß√£o sem retorno n√£o devolve um valor diretamente, mas realiza uma a√ß√£o. Por exemplo:

* Imprimir uma mensagem na tela.

* Tocar um som.

* Salvar um arquivo no computador.

Essas fun√ß√µes s√£o √∫teis para executar tarefas que n√£o precisam de um resultado imediato, como mostrar uma mensagem ou realizar um efeito visual no programa.

### Por que utilizar fun√ß√µes?

Agora que entendemos o conceito b√°sico de fun√ß√µes e seus componentes (par√¢metros, entradas, sa√≠das, retorno), vamos refletir sobre as principais vantagens de us√°-las:

1. Evita repeti√ß√£o

Ao usar fun√ß√µes, voc√™ escreve um conjunto de instru√ß√µes uma √∫nica vez e pode cham√°-lo quantas vezes for necess√°rio. No caso do fatorial, voc√™ escreveria o c√°lculo uma vez dentro de uma fun√ß√£o e poderia cham√°-la sempre que precisasse calcular um fatorial para qualquer n√∫mero.

2. Reduz erros

Se voc√™ precisa corrigir ou otimizar algo, basta alterar a fun√ß√£o em um √∫nico lugar. Sem fun√ß√µes, ter√≠amos que atualizar v√°rias partes do c√≥digo, o que aumenta a chance de deixar algo passar batido. Com fun√ß√µes, isso fica bem mais seguro e eficiente.

3. Facilita a manuten√ß√£o

C√≥digo que utiliza fun√ß√µes √© muito mais f√°cil de entender e manter, porque voc√™ pode pensar nas fun√ß√µes como pequenos blocos de constru√ß√£o. Se voc√™ precisar alterar algo, pode se concentrar apenas na fun√ß√£o espec√≠fica, sem se preocupar em revisar o c√≥digo inteiro.

4. Permite a abstra√ß√£o

Fun√ß√µes permitem que voc√™ se concentre no que uma parte do programa faz, sem se preocupar com o como ela faz. Em vez de entender todos os detalhes de um c√°lculo ou tarefa, voc√™ s√≥ precisa saber qual fun√ß√£o chamar e qual valor passar para ela.

### Resumo

| Conceito                    | Descri√ß√£o                                                                |
| --------------------------- | ------------------------------------------------------------------------ |
| **Par√¢metro(s)** / **Entrada** | Valores que a fun√ß√£o recebe como entrada, dados fornecidos para a fun√ß√£o |
| **Processo**                | As instru√ß√µes internas que a fun√ß√£o executa com esses dados   |
| **Sa√≠da**                   | O que a fun√ß√£o produz ap√≥s executar seu processo              |
| **Retorno**                 | O valor que a fun√ß√£o devolve (ou nada, se n√£o houver retorno) |

## Fun√ß√µes que j√° conhecemos

Voc√™ j√° est√° usando fun√ß√µes no seu c√≥digo, sem nem perceber! Dois exemplos que voc√™ provavelmente usa o tempo todo em Python s√£o as fun√ß√µes print() e input(). Ambas s√£o essenciais para a intera√ß√£o com o usu√°rio e a exibi√ß√£o de informa√ß√µes. No entanto, embora voc√™ j√° as tenha usado, talvez n√£o tenha notado que ambas s√£o fun√ß√µes completas, com entradas (valores que voc√™ passa para elas) e sa√≠das (valores que elas retornam ou a√ß√µes que realizam).

Agora que come√ßamos a entender o que s√£o fun√ß√µes, vamos analisar como essas duas fun√ß√µes que voc√™ j√° conhece funcionam internamente, e o que elas fazem com as entradas e sa√≠das.

### Fun√ß√£o print()

A fun√ß√£o print() √© provavelmente a fun√ß√£o mais usada em Python. Ela permite que voc√™ mostre informa√ß√µes na tela durante a execu√ß√£o do seu programa. Sempre que voc√™ quer que algo apare√ßa para o usu√°rio ‚Äî seja uma mensagem, um valor ou o resultado de um c√°lculo ‚Äî voc√™ usa print().

#### Entradas: o que a fun√ß√£o print() recebe

A fun√ß√£o print() pode receber um ou mais par√¢metros, que s√£o os valores que voc√™ deseja exibir na tela. Cada valor √© separado por v√≠rgula dentro dos par√™nteses. Esses valores podem ser strings, n√∫meros, ou vari√°veis.

Por exemplo:

```{python}
#| eval: false
print("Ol√°, Mundo!")
```

Aqui, a fun√ß√£o print() recebe uma string ("Ol√°, Mundo!") como par√¢metro e exibe essa string na tela. Voc√™ pode tamb√©m passar v√°rias informa√ß√µes de uma vez, separadas por v√≠rgulas, e o Python ir√° automaticamente adicionar espa√ßos entre elas:

```{python}
#| eval: false
nome = "Maria"
idade = 25
print("Nome:", nome, "Idade:", idade)
```

Neste caso, a fun√ß√£o print() recebe tr√™s par√¢metros: a string "Nome:", a vari√°vel nome e a string "Idade:". Ela imprime esses valores na tela, com espa√ßos entre eles.

#### Sa√≠da: o que a fun√ß√£o print() retorna

A fun√ß√£o print() n√£o retorna nenhum valor. Ela apenas exibe as entradas fornecidas na tela. Em outras palavras, n√£o h√° um valor retornado por print() que voc√™ possa usar em outros c√°lculos ou vari√°veis. Se quisermos usar a terminologia de fun√ß√µes:

* Sa√≠da/Retorno: `None` (n√£o h√° um valor retornado, a sa√≠da √© apenas o efeito de exibir algo na tela)

#### Resumo da fun√ß√£o print()

| Conceito          | Descri√ß√£o                                                        |
| ----------------- | ---------------------------------------------------------------- |
| **Par√¢metro(s)**  | O(s) valor(es) que voc√™ quer exibir (ex: uma string ou vari√°vel) |
| **Entrada**       | O que voc√™ quer mostrar na tela                                  |
| **Sa√≠da/Retorno** | N√£o retorna valor, apenas exibe a informa√ß√£o                     |

### Fun√ß√£o input()

A fun√ß√£o input() √© outra fun√ß√£o muito comum em Python. Ela permite que voc√™ obtenha dados do usu√°rio. Sempre que voc√™ precisa fazer uma pergunta ao usu√°rio e obter uma resposta, voc√™ usa input().

#### Entradas: o que a fun√ß√£o input() recebe

A fun√ß√£o input() pode receber um par√¢metro, que √© o texto que voc√™ deseja exibir para o usu√°rio antes que ele digite a resposta. Esse texto √© normalmente uma pergunta ou uma mensagem explicativa.

Por exemplo:

```{python}
#| eval: false
nome = input("Qual √© o seu nome? ")
print("Ol√°, " + nome + "!")
```

Aqui, a fun√ß√£o input() recebe o par√¢metro "Qual √© o seu nome? " e exibe essa mensagem na tela. O Python ent√£o espera que o usu√°rio digite uma resposta. Quando o usu√°rio digita, a fun√ß√£o retorna a resposta como uma string. A resposta do usu√°rio √© armazenada na vari√°vel nome, que pode ser utilizada posteriormente.

#### Sa√≠da: o que a fun√ß√£o input() retorna

A fun√ß√£o input() sempre retorna uma string, independentemente do que o usu√°rio digite. Isso significa que, mesmo que o usu√°rio digite n√∫meros, a entrada ser√° interpretada como texto.

Por exemplo, se o usu√°rio digitar "25" (para idade), ele ser√° armazenado como a string "25". Se quisermos tratar esse valor como um n√∫mero, precisamos convert√™-lo para o tipo correto usando fun√ß√µes como int() ou float().

```{python}
#| eval: false
idade = input("Quantos anos voc√™ tem? ")
idade = int(idade)  # Converte a resposta para um n√∫mero inteiro
print("Voc√™ tem", idade, "anos.")
```

Aqui, a fun√ß√£o input() retorna a resposta do usu√°rio como uma string. Depois, usamos int() para converter essa string em um n√∫mero inteiro.

#### Resumo da fun√ß√£o input()

| Conceito          | Descri√ß√£o                                                            |
| ----------------- | -------------------------------------------------------------------- |
| **Par√¢metro(s)**  | O texto exibido para o usu√°rio (ex: uma pergunta ou mensagem)        |
| **Entrada**       | O que o usu√°rio digita como resposta                                 |
| **Sa√≠da/Retorno** | A fun√ß√£o retorna uma **string** (mesmo que o usu√°rio digite n√∫meros) |

## Sintaxe de utiliza√ß√£o de fun√ß√µes

Agora que j√° sabemos o que s√£o fun√ß√µes e por que elas s√£o √∫teis, vamos entender como cham√°-las corretamente. Chamar uma fun√ß√£o significa pedir ao Python para executar o c√≥digo dentro daquela fun√ß√£o. Quando voc√™ chama uma fun√ß√£o, o programa "vai at√© a fun√ß√£o", executa as instru√ß√µes que est√£o nela e, em muitos casos, retorna um resultado.

Em termos simples, chamar uma fun√ß√£o √© como fazer um pedido para o programa realizar uma tarefa espec√≠fica. Quando voc√™ chama a fun√ß√£o, ela faz algo por voc√™, seja exibindo algo na tela, realizando um c√°lculo, ou at√© recebendo dados de entrada do usu√°rio.

Agora, vamos ver como a sintaxe de uma fun√ß√£o funciona em Python, incluindo como passar par√¢metros, como chamar fun√ß√µes sem par√¢metros e como lidar com valores retornados.

### Chamar uma fun√ß√£o

Em Python, chamar uma fun√ß√£o √© bem simples, mas precisa seguir uma estrutura espec√≠fica. Toda vez que voc√™ quiser usar uma fun√ß√£o, voc√™ deve incluir par√™nteses ap√≥s o nome da fun√ß√£o.

```{python}
#| eval: false
nome_da_funcao()
```

### Fun√ß√µes com par√¢metros

As fun√ß√µes podem receber par√¢metros, que s√£o os valores que voc√™ passa para elas para que possam realizar algum processamento. Esses par√¢metros s√£o colocados dentro dos par√™nteses ao chamar a fun√ß√£o.

```{python}
#| eval: false
nome_da_funcao(parametro_1, parametro_2, ...)
```

### Fun√ß√µes sem par√¢metro

Algumas fun√ß√µes n√£o exigem nenhum par√¢metro. Nesse caso, voc√™ ainda deve usar os par√™nteses ao chamar a fun√ß√£o, mas n√£o h√° necessidade de colocar nada dentro deles.

```{python}
#| eval: false
nome_da_funcao()
```

### Fun√ß√µes com retorno

Fun√ß√µes podem retornar um valor ap√≥s a execu√ß√£o. O valor retornado pode ser armazenado em uma vari√°vel ou utilizado diretamente em c√°lculos ou outras opera√ß√µes.

Quando uma fun√ß√£o tem retorno, a sintaxe para us√°-la fica da seguinte forma:

```{python}
#| eval: false
variavel = nome_da_funcao(parametros)
```

### Fun√ß√µes com par√¢metros opcionais

√Äs vezes, as fun√ß√µes podem ter par√¢metros com valores padr√£o, o que significa que, se voc√™ n√£o passar um valor para aquele par√¢metro, o Python usar√° algum valor pr√©-definido.

Ou seja, se temos uma fun√ß√£o, por exemplo, que tem um par√¢metro "parametro_1" pr√©-definido para o valor 10, se um novo valor de a n√£o for especificado na chamada, da seguinte forma:

```{python}
#| eval: false
nome_da_funcao(parametro_1 = 3)
```

A fun√ß√£o √© executada com o valor de "parametro_1" igual a 10.