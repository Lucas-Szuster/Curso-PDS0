[
  {
    "objectID": "introducao/RepresentacoesDeAlgoritmos.html",
    "href": "introducao/RepresentacoesDeAlgoritmos.html",
    "title": "Representações de Algorítmos",
    "section": "",
    "text": "O pseudocódigo é uma forma simplificada e estruturada de descrever um algoritmo, usando uma linguagem próxima da linguagem humana, mas organizada de maneira lógica, semelhante à de um programa de computador. Ele serve como uma ponte entre o pensamento humano e a linguagem de programação, permitindo que a lógica de um problema seja planejada antes de ser implementada em código real.\nEm vez de usar uma sintaxe rígida e regras específicas de uma linguagem (como Python, Java ou C++), o pseudocódigo utiliza palavras e estruturas genéricas, fáceis de entender por qualquer pessoa com conhecimentos básicos de programação. O foco principal está em comunicar claramente os passos que devem ser seguidos para resolver um problema, e não em detalhes técnicos de implementação.\nPor exemplo, um algoritmo para somar dois números pode ser escrito em pseudocódigo assim:\nINÍCIO\n  LER número1\n  LER número2\n  SOMA ← número1 + número2\n  ESCREVER \"O resultado é:\", SOMA\nFIM\nEsse exemplo mostra claramente o que o algoritmo faz, sem se preocupar com a linguagem de programação usada. Ele é fácil de compreender e de transformar depois em código real.\nO pseudocódigo também é amplamente usado no planejamento e ensino da lógica de programação, pois ajuda os estudantes e desenvolvedores a raciocinar sobre a sequência de passos de um problema sem se preocupar com erros de sintaxe.\nEm resumo, o pseudocódigo é uma ferramenta de planejamento e comunicação, que permite expressar ideias e soluções de forma estruturada, lógica e compreensível, sendo o primeiro passo natural antes da escrita do código em uma linguagem de programação real.\n\n\nAs estruturas condicionais são essenciais para a tomada de decisões dentro de um algoritmo. Elas permitem que o fluxo de execução de um programa siga diferentes caminhos, dependendo de uma condição ser verdadeira ou falsa.\n\n\n\nA estrutura condicional mais simples é o SE. Ela permite que uma ação seja executada apenas quando uma condição for verdadeira.\nExemplo de pseudocódigo com condicional simples:\nINÍCIO\n  LER idade\n  SE idade &gt;= 18 ENTÃO\n    ESCREVER \"Maior de idade\"\n  FIM SE\nFIM\nNeste exemplo, o algoritmo lê a idade de uma pessoa e, caso a idade seja maior ou igual a 18, exibe a mensagem “Maior de idade”. Se a condição não for satisfeita, nada é executado.\n\n\n\nA estrutura condicional SE…SENÃO permite definir um caminho alternativo a ser seguido caso a condição não seja verdadeira.\nExemplo de pseudocódigo com SE…SENÃO:\nINÍCIO\n  LER idade\n  SE idade &gt;= 18 ENTÃO\n    ESCREVER \"Maior de idade\"\n  SENÃO\n    ESCREVER \"Menor de idade\"\n  FIM SE\nFIM\nAqui, o algoritmo verifica se a pessoa é maior de idade. Caso a condição idade &gt;= 18 seja verdadeira, ele imprime “Maior de idade”. Caso contrário, imprime “Menor de idade”.\n\n\n\nEm alguns casos, é necessário avaliar várias condições em sequência. Para isso, podemos usar a estrutura SE…SENÃO SE…SENÃO.\nExemplo de pseudocódigo com múltiplas alternativas:\nINÍCIO\n  LER nota\n  SE nota &gt;= 9 ENTÃO\n    ESCREVER \"Excelente\"\n  SENÃO SE nota &gt;= 7 ENTÃO\n    ESCREVER \"Bom\"\n  SENÃO SE nota &gt;= 5 ENTÃO\n    ESCREVER \"Regular\"\n  SENÃO\n    ESCREVER \"Reprovado\"\n  FIM SE\nFIM\nEste exemplo verifica a nota de um aluno e classifica-o em uma das categorias: “Excelente”, “Bom”, “Regular” ou “Reprovado”. A estrutura SE…SENÃO SE…SENÃO permite verificar várias condições sequencialmente.\n\n\n\nÀs vezes, uma condição pode ser aninhada dentro de outra, ou seja, uma estrutura SE pode conter outra estrutura SE dentro de sua parte SENÃO.\nExemplo de pseudocódigo com condicional aninhada:\nINÍCIO\n  LER idade\n  SE idade &gt;= 18 ENTÃO\n    LER salario\n    SE salario &gt;= 5000 ENTÃO\n      ESCREVER \"Maior de idade e alta renda\"\n    SENÃO\n      ESCREVER \"Maior de idade, mas baixa renda\"\n    FIM SE\n  SENÃO\n    ESCREVER \"Menor de idade\"\n  FIM SE\nFIM\nAqui, o algoritmo verifica se a pessoa é maior de idade. Se for, ele então verifica o salário da pessoa. Caso o salário seja maior ou igual a 5000, ele imprime “Maior de idade e alta renda”; caso contrário, imprime “Maior de idade, mas baixa renda”. Se a pessoa for menor de idade, o programa imprime “Menor de idade”.\n\n\n\nAs estruturas de repetição são fundamentais para a execução de um bloco de código várias vezes, até que uma condição seja atendida. Elas são especialmente úteis quando se tem tarefas repetitivas ou quando se precisa de uma sequência de ações que dependem de algum critério, como a contagem ou uma verificação lógica.\nEm pseudocódigo, as repetições são implementadas de forma simples, com estruturas que controlam a execução repetida de comandos. Vamos explorar as formas mais comuns de estrutura de repetição.\n\n\n\nA estrutura ENQUANTO (ou WHILE em algumas linguagens de programação) permite que um conjunto de ações seja repetido enquanto uma condição for verdadeira. Quando a condição se torna falsa, o loop é interrompido.\nExemplo de pseudocódigo com repetição controlada por condição:\nINÍCIO\n  LER número\n  ENQUANTO número &gt;= 0 FAÇA\n    SOMA ← SOMA + número\n    LER número\n  FIM ENQUANTO\n  ESCREVER \"A soma dos números positivos é:\", SOMA\nFIM\nNeste exemplo, o algoritmo lê números e vai somando-os enquanto o número informado for maior ou igual a zero. Quando um número negativo for digitado, o laço termina e o programa exibe a soma dos números positivos informados.\n\n\n\nA estrutura PARA (ou FOR) é usada quando você sabe o número de vezes que deseja repetir um conjunto de ações. Ela é controlada por um contador que incrementa ou decrementa a cada iteração, até atingir um limite predefinido.\nExemplo de pseudocódigo com repetição controlada por contagem:\nINÍCIO\n  LER n\n  PARA i ← 1 ATÉ n FAÇA\n    ESCREVER \"Repetição número:\", i\n  FIM PARA\nFIM\nNeste exemplo, o algoritmo vai repetir o processo de exibição da mensagem “Repetição número: i” um número de vezes igual a n, onde i vai de 1 até o valor de n.",
    "crumbs": [
      "Introdução",
      "Representações de Algorítmos"
    ]
  },
  {
    "objectID": "introducao/RepresentacoesDeAlgoritmos.html#pseudocódigo",
    "href": "introducao/RepresentacoesDeAlgoritmos.html#pseudocódigo",
    "title": "Representações de Algorítmos",
    "section": "",
    "text": "O pseudocódigo é uma forma simplificada e estruturada de descrever um algoritmo, usando uma linguagem próxima da linguagem humana, mas organizada de maneira lógica, semelhante à de um programa de computador. Ele serve como uma ponte entre o pensamento humano e a linguagem de programação, permitindo que a lógica de um problema seja planejada antes de ser implementada em código real.\nEm vez de usar uma sintaxe rígida e regras específicas de uma linguagem (como Python, Java ou C++), o pseudocódigo utiliza palavras e estruturas genéricas, fáceis de entender por qualquer pessoa com conhecimentos básicos de programação. O foco principal está em comunicar claramente os passos que devem ser seguidos para resolver um problema, e não em detalhes técnicos de implementação.\nPor exemplo, um algoritmo para somar dois números pode ser escrito em pseudocódigo assim:\nINÍCIO\n  LER número1\n  LER número2\n  SOMA ← número1 + número2\n  ESCREVER \"O resultado é:\", SOMA\nFIM\nEsse exemplo mostra claramente o que o algoritmo faz, sem se preocupar com a linguagem de programação usada. Ele é fácil de compreender e de transformar depois em código real.\nO pseudocódigo também é amplamente usado no planejamento e ensino da lógica de programação, pois ajuda os estudantes e desenvolvedores a raciocinar sobre a sequência de passos de um problema sem se preocupar com erros de sintaxe.\nEm resumo, o pseudocódigo é uma ferramenta de planejamento e comunicação, que permite expressar ideias e soluções de forma estruturada, lógica e compreensível, sendo o primeiro passo natural antes da escrita do código em uma linguagem de programação real.\n\n\nAs estruturas condicionais são essenciais para a tomada de decisões dentro de um algoritmo. Elas permitem que o fluxo de execução de um programa siga diferentes caminhos, dependendo de uma condição ser verdadeira ou falsa.\n\n\n\nA estrutura condicional mais simples é o SE. Ela permite que uma ação seja executada apenas quando uma condição for verdadeira.\nExemplo de pseudocódigo com condicional simples:\nINÍCIO\n  LER idade\n  SE idade &gt;= 18 ENTÃO\n    ESCREVER \"Maior de idade\"\n  FIM SE\nFIM\nNeste exemplo, o algoritmo lê a idade de uma pessoa e, caso a idade seja maior ou igual a 18, exibe a mensagem “Maior de idade”. Se a condição não for satisfeita, nada é executado.\n\n\n\nA estrutura condicional SE…SENÃO permite definir um caminho alternativo a ser seguido caso a condição não seja verdadeira.\nExemplo de pseudocódigo com SE…SENÃO:\nINÍCIO\n  LER idade\n  SE idade &gt;= 18 ENTÃO\n    ESCREVER \"Maior de idade\"\n  SENÃO\n    ESCREVER \"Menor de idade\"\n  FIM SE\nFIM\nAqui, o algoritmo verifica se a pessoa é maior de idade. Caso a condição idade &gt;= 18 seja verdadeira, ele imprime “Maior de idade”. Caso contrário, imprime “Menor de idade”.\n\n\n\nEm alguns casos, é necessário avaliar várias condições em sequência. Para isso, podemos usar a estrutura SE…SENÃO SE…SENÃO.\nExemplo de pseudocódigo com múltiplas alternativas:\nINÍCIO\n  LER nota\n  SE nota &gt;= 9 ENTÃO\n    ESCREVER \"Excelente\"\n  SENÃO SE nota &gt;= 7 ENTÃO\n    ESCREVER \"Bom\"\n  SENÃO SE nota &gt;= 5 ENTÃO\n    ESCREVER \"Regular\"\n  SENÃO\n    ESCREVER \"Reprovado\"\n  FIM SE\nFIM\nEste exemplo verifica a nota de um aluno e classifica-o em uma das categorias: “Excelente”, “Bom”, “Regular” ou “Reprovado”. A estrutura SE…SENÃO SE…SENÃO permite verificar várias condições sequencialmente.\n\n\n\nÀs vezes, uma condição pode ser aninhada dentro de outra, ou seja, uma estrutura SE pode conter outra estrutura SE dentro de sua parte SENÃO.\nExemplo de pseudocódigo com condicional aninhada:\nINÍCIO\n  LER idade\n  SE idade &gt;= 18 ENTÃO\n    LER salario\n    SE salario &gt;= 5000 ENTÃO\n      ESCREVER \"Maior de idade e alta renda\"\n    SENÃO\n      ESCREVER \"Maior de idade, mas baixa renda\"\n    FIM SE\n  SENÃO\n    ESCREVER \"Menor de idade\"\n  FIM SE\nFIM\nAqui, o algoritmo verifica se a pessoa é maior de idade. Se for, ele então verifica o salário da pessoa. Caso o salário seja maior ou igual a 5000, ele imprime “Maior de idade e alta renda”; caso contrário, imprime “Maior de idade, mas baixa renda”. Se a pessoa for menor de idade, o programa imprime “Menor de idade”.\n\n\n\nAs estruturas de repetição são fundamentais para a execução de um bloco de código várias vezes, até que uma condição seja atendida. Elas são especialmente úteis quando se tem tarefas repetitivas ou quando se precisa de uma sequência de ações que dependem de algum critério, como a contagem ou uma verificação lógica.\nEm pseudocódigo, as repetições são implementadas de forma simples, com estruturas que controlam a execução repetida de comandos. Vamos explorar as formas mais comuns de estrutura de repetição.\n\n\n\nA estrutura ENQUANTO (ou WHILE em algumas linguagens de programação) permite que um conjunto de ações seja repetido enquanto uma condição for verdadeira. Quando a condição se torna falsa, o loop é interrompido.\nExemplo de pseudocódigo com repetição controlada por condição:\nINÍCIO\n  LER número\n  ENQUANTO número &gt;= 0 FAÇA\n    SOMA ← SOMA + número\n    LER número\n  FIM ENQUANTO\n  ESCREVER \"A soma dos números positivos é:\", SOMA\nFIM\nNeste exemplo, o algoritmo lê números e vai somando-os enquanto o número informado for maior ou igual a zero. Quando um número negativo for digitado, o laço termina e o programa exibe a soma dos números positivos informados.\n\n\n\nA estrutura PARA (ou FOR) é usada quando você sabe o número de vezes que deseja repetir um conjunto de ações. Ela é controlada por um contador que incrementa ou decrementa a cada iteração, até atingir um limite predefinido.\nExemplo de pseudocódigo com repetição controlada por contagem:\nINÍCIO\n  LER n\n  PARA i ← 1 ATÉ n FAÇA\n    ESCREVER \"Repetição número:\", i\n  FIM PARA\nFIM\nNeste exemplo, o algoritmo vai repetir o processo de exibição da mensagem “Repetição número: i” um número de vezes igual a n, onde i vai de 1 até o valor de n.",
    "crumbs": [
      "Introdução",
      "Representações de Algorítmos"
    ]
  },
  {
    "objectID": "introducao/RepresentacoesDeAlgoritmos.html#fluxogramas",
    "href": "introducao/RepresentacoesDeAlgoritmos.html#fluxogramas",
    "title": "Representações de Algorítmos",
    "section": "Fluxogramas",
    "text": "Fluxogramas\nFluxograma: é um tipo de diagrama, e pode ser entendido como uma representação esquemática de um processo ou algoritmo, muitas vezes feito através de gráficos que ilustram de forma descomplicada a transição de informações entre os elementos que o compõem, ou seja, é a sequência operacional do desenvolvimento de um processo, o qual caracteriza: o trabalho que está sendo realizado, o tempo necessário para sua realização, a distância percorrida pelos documentos, quem está realizando o trabalho e como ele flui entre os participantes deste processo.\nOs fluxogramas são muito utilizados em projetos de software para representar a lógica interna dos programas, mas podem também ser usados para desenhar processos de negócio e o workflow que envolve diversos atores corporativos no exercício de suas atribuições.[1]\nO diagrama de fluxo de dados (DFD) utiliza do fluxograma para modelagem e documentação de sistemas computacionais.\nO termo fluxograma designa uma representação gráfica de um determinado processo ou fluxo de trabalho, efetuado geralmente com recurso a figuras geométricas normalizadas e as setas unindo essas figuras geométricas. Através desta representação gráfica é possível compreender de forma rápida e fácil a transição de informações ou documentos entre os elementos que participam no processo em causa.\nO fluxograma pode ser definido também como o gráfico em que se representa o percurso ou caminho percorrido por certo elemento (por exemplo, um determinado documento), através dos vários departamentos da organização, bem como o tratamento que cada um vai lhe dando.\nA existência de fluxogramas para cada um dos processos é fundamental para a simplificação e racionalização do trabalho, permitindo a compreensão e posterior otimização dos processos desenvolvidos em cada departamento ou área da organização.\n\nFuncionamento de fluxogramas simples\nTodos os fluxogramas possuem setas, que indicam para o onde a sequência lógica de execução do programa segue. Entre estas setas estão localizados nós, que podem ser agrupados em certos tipos:\n\nInício/Fim: Indicam onde o fluxograma começa e onde o fluxograma termina.\nEntrada de dados/Definição de dados: Indica quais dados serão utilizados e como devem ser definidos (seus nomes e possíveis valores).\nProcessamento de dados: Indica a lógica que deve ser efetuada com os dados do programa.\n\n\nExemplo de fluxograma\nDescrição do algoritmo: Ler dois números (a e b), calcular a soma dos dois e armazenar o resultado em um terceiro número, c.\n\n\n\n\n\n\nflowchart TD\nA([Início]) --&gt; B[/entrada de dados em a/]\nB --&gt; C[/entrada de dados em b/]\nC --&gt; D[\"c = a + b\"]\nD --&gt; E([Fim])\n\n\n\n\n\n\n\n\n\n\nFluxogramas com estruturas condicionais simples\nNos fluxogramas, as estruturas condicionais são representadas de forma visual, permitindo compreender facilmente os pontos de decisão dentro de um processo. Em vez de apenas mostrar uma sequência linear de ações, o fluxograma passa a indicar bifurcações — momentos em que o fluxo pode seguir por caminhos diferentes dependendo de um resultado lógico.\nA condicional é representada pelo losango (◇), símbolo universal usado para indicar uma decisão. Dentro dele, é escrita a condição que será avaliada — por exemplo, “Idade ≥ 18?”. A partir do losango, saem normalmente duas setas, correspondendo às possíveis respostas da verificação:\n\nUma seta para o caminho verdadeiro (geralmente marcada com “Sim”, “Verdadeiro” ou “True”).\nOutra seta para o caminho falso (marcada com “Não”, “Falso” ou “False”).\n\nCada um desses caminhos leva a blocos diferentes de instruções, que mostram o que o algoritmo deve fazer em cada situação. Depois de executadas as ações correspondentes, dependendo do algoritmo, os caminhos se unem novamente ou não (antes do fim).\nEssa forma de representação torna as decisões fáceis de visualizar, permitindo que qualquer pessoa — mesmo sem conhecer o código — entenda rapidamente onde o processo toma decisões e quais são as possíveis consequências de cada escolha.\n\nExemplo de fluxograma com condicional\nDescrição do algoritmo: Ler a idade de uma pessoa e determinar se ela é maior de idade (idade ≥ 18).\n\n\n\n\n\n\nflowchart TD\nA([Início]) --&gt; B[/Ler idade/]\nB --&gt; C{Idade &gt;= 18?}\nC --&gt;|Verdadeiro| D[\"Exibir: Maior de idade\"]\nC --&gt;|Falso| E[\"Exibir: Menor de idade\"]\nD --&gt; F([Fim])\nE --&gt; F\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nAs estruturas condicionais são os principais elementos que conferem ramificações aos fluxogramas. Elas tornam o diagrama mais próximo da lógica real dos algoritmos, destacando pontos de decisão e possíveis alternativas de execução dentro do processo.\n\n\n\n\n\nFluxogramas com estruturas condicionais encadeadas\nEm muitos casos, um algoritmo não toma apenas uma decisão — ele precisa avaliar várias condições em sequência. Quando isso acontece, o fluxograma apresenta condicionais encadeadas, ou seja, um losango levando a outro, formando uma cadeia de verificações. Cada decisão depende do resultado da anterior, e o fluxo do processo segue até que todas as verificações tenham sido realizadas.\nEsse tipo de estrutura é comum em algoritmos que precisam classificar situações, determinar categorias ou escolher entre múltiplas alternativas. Visualmente, o fluxograma vai mostrando as “encruzilhadas” do processo, permitindo acompanhar a sequência de perguntas e respostas até chegar ao resultado final.\n\nExemplo de fluxograma com condicionais encadeadas\nDescrição do algortmo: Descobrir qual o desempenho de um aluno com base na sua nota final, categorizando-o entre Excelente, Bom, Regular e Reprovado.\n\nVerificar se a nota é maior ou igual a 9 — caso seja, classificar como “Excelente”.\nSe não for, verificar se é maior ou igual a 7 — classificar como “Bom”.\nCaso contrário, verificar se é maior ou igual a 5 — classificar como “Regular”.\nSe nenhuma das condições anteriores for atendida, o resultado será “Reprovado”.\n\nEssa representação mostra claramente que cada decisão leva a outra, até que o algoritmo encontre a condição que se aplica à situação analisada.\n\n\n\n\n\n\nflowchart TD\nA([Início]) --&gt; B[/Ler nota/]\nB --&gt; C{Nota &gt;= 9?}\nC --&gt;|Verdadeiro| D[\"Exibir: Excelente\"]\nC --&gt;|Falso| E{Nota &gt;= 7?}\nE --&gt;|Verdadeiro| F[\"Exibir: Bom\"]\nE --&gt;|Falso| G{Nota &gt;= 5?}\nG --&gt;|Verdadeiro| H[\"Exibir: Regular\"]\nG --&gt;|Falso| I[\"Exibir: Reprovado\"]\nD --&gt; J([Fim])\nF --&gt; J\nH --&gt; J\nI --&gt; J\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nEssas cadeias de decisões tornam os fluxogramas especialmente úteis para entender lógicas complexas de forma visual e intuitiva, facilitando o planejamento e a comunicação de algoritmos com múltiplos critérios de decisão.\n\n\n\n\n\nFluxogramas com estruturas de repetição simples\nNos fluxogramas, as estruturas de repetição representam situações em que um conjunto de ações precisa ser executado diversas vezes, de forma controlada. Essas estruturas são fundamentais em algoritmos, pois permitem automatizar tarefas repetitivas e economizar etapas no processo lógico.\nVisualmente, a repetição é representada por um ciclo dentro do fluxograma, no qual o fluxo retorna a uma etapa anterior, formando um laço. Esse retorno é o que caracteriza o comportamento repetitivo da estrutura.\n\nRepresentação gráfica\nA estrutura de repetição é geralmente associada ao losango (◇), o mesmo símbolo usado para decisões, já que a repetição depende de uma condição lógica que determina se o ciclo continuará ou não. Enquanto a condição for verdadeira, o fluxo retorna ao início do bloco de instruções; quando a condição se torna falsa, o fluxo segue adiante, saindo do laço.\nIsso torna as estruturas de repetição visualmente distintas das condicionais simples: nelas, há um caminho que volta para um ponto anterior do fluxograma, evidenciando a ideia de repetição.\n\n\nTipos de repetição representados em fluxogramas\nExistem diferentes formas de ilustrar a repetição em fluxogramas, de acordo com a lógica do algoritmo:\nRepetição controlada por condição (tipo “enquanto”) – O ciclo repete enquanto uma condição for verdadeira. O teste é feito antes da execução do bloco de instruções.\nRepetição controlada por contagem (tipo “para”) – O ciclo se repete um número pré-determinado de vezes. Visualmente, o laço indica que o fluxo volta até que o contador atinja o limite definido.\n\n\nExemplo de fluxograma com repetição\nDescrição do algoritmo: Ler uma sequência de números e somá-los enquanto o número informado for positivo. Quando um número negativo for digitado, o processo deve parar e o resultado final ser exibido.\n\n\n\n\n\n\nflowchart TD\nA([Início]) --&gt; B[\"Soma = 0\"]\nB --&gt; C[/Ler número/]\nC --&gt; D{Número &gt;= 0?}\nD --&gt;|Verdadeiro| E[\"Soma = Soma + Número\"]\nE --&gt; C\nD --&gt;|Falso| F[\"Exibir Soma\"]\nF --&gt; G([Fim])\n\n\n\n\n\n\n\n\nInterpretação\nNeste fluxograma, o losango representa a condição “Número ≥ 0?”. Enquanto essa condição é verdadeira, o fluxo retorna para a leitura de novos números, repetindo as etapas de leitura e soma. Quando a condição se torna falsa (ou seja, um número negativo é digitado), o laço é interrompido e o programa segue para o encerramento.",
    "crumbs": [
      "Introdução",
      "Representações de Algorítmos"
    ]
  },
  {
    "objectID": "introducao/RepresentacoesDeAlgoritmos.html#exercícios",
    "href": "introducao/RepresentacoesDeAlgoritmos.html#exercícios",
    "title": "Representações de Algorítmos",
    "section": "Exercícios",
    "text": "Exercícios\n\nExercício 1\nTransforme o pseudocódigo abaixo em fluxograma:\nINÍCIO\n  LER número1\n  LER número2\n  SE número1 &gt; número2\n    ESCREVER \"Entre os números, o maior é: \", número1\n  SENÃO\n    ESCREVER \"Entre os números, ou são iguais ou o maior é: \", número2\n  FIM SE\nFIM\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\n\n\nPNG\n\n\n\n\n\n\n\nExercício 2\nAbaixo estão um pseudocógio e um floxograma:\n\n\n\n\nFluxograma\n\n\n\n\n\nflowchart TD\nA([Inicio]) --&gt; B[\"a = 0\"]\nB --&gt; C{a &lt; 3?}\nC --&gt;|Verdadeiro| D[\"a = a + 1\"]\nC --&gt;|Falso| E([Fim])\nD --&gt; C\n\n\n\n\n\n\n\n\n\nPseudocódigo\nINÍCIO\n  a ← 0\n  ENQUANTO a &lt; 3 FAÇA\n    a ← a + 1\n  FIM ENQUANTO\nFIM\n\n\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nSim.\nNo fluxograma, temos um valor a = 0, e, enquanto ele é menor que 3 ele é incrementado por 1. No momento que seu valor atinge 3, o algortimo termina, pois a condição “a &lt; 3” se torna falsa. No pseudocódigo temos o mesmo efeito, pois assim que a assume o valor 3, o ENQUANTO acaba.\n\n\n\n\nExercício 3\nCom base no algorítmo abaixo responda:\n\n\n\n\n\nflowchart TD\nA([Início]) --&gt; B[/Ler um número/]\nB --&gt; C{Número &lt; 0?}\nC --&gt;|Sim| D[\"Exibir: Número negativo\"]\nC --&gt;|Não| E{Número &lt;= 50?}\nE --&gt;|Sim| F[\"Exibir: Faixa 1\"]\nE --&gt;|Não| G{Número &lt;= 100?}\nG --&gt;|Sim| H[\"Exibir: Faixa 2\"]\nG --&gt;|Não| I[\"Exibir: Número fora da faixa permitida\"]\nD --&gt; J([Fim])\nF --&gt; J\nH --&gt; J\nI --&gt; B\n\n\n\n\n\n\n\nO que este algoritmo faz?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nEle lê um número e checa se este número está dentro da faixa aceitável de entradas, sendo a faixa: \\((-\\infty, 100]\\). Caso um número esteja fora da faixa, o algoritmo é repetido, até que um número válido seja lido.\n\n\n\n\nO que acontecerá se o número lido pelo algoritmo fosse 105?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nComo números maiores que 100 serão classificados como números fora da faixa, o resultado será uma repetição do algoritmo, lendo novamente o número para checar se ele está na faixa aceitável.",
    "crumbs": [
      "Introdução",
      "Representações de Algorítmos"
    ]
  },
  {
    "objectID": "introducao/OrganizacaoDeComputadores.html",
    "href": "introducao/OrganizacaoDeComputadores.html",
    "title": "Fundamentos de computadores",
    "section": "",
    "text": "Um computador é uma máquina projetada para processar dados automaticamente. Ele recebe entradas, realiza operações e fornece saídas. A principal função de um computador é seguir instruções de forma precisa e repetitiva, o que permite a execução de tarefas complexas com rapidez e confiabilidade.\nEssas instruções são transformadas em algoritmos que o computador interpreta e executa. A máquina processa informações através de cálculos e operações lógicas de acordo com as regras definidas pelos algoritmos. Diferente de um ser humano, que toma decisões de forma subjetiva, o computador executa essas operações com base no que foi programado.",
    "crumbs": [
      "Introdução",
      "Fundamentos de computadores"
    ]
  },
  {
    "objectID": "introducao/OrganizacaoDeComputadores.html#o-que-é-um-computador",
    "href": "introducao/OrganizacaoDeComputadores.html#o-que-é-um-computador",
    "title": "Fundamentos de computadores",
    "section": "",
    "text": "Um computador é uma máquina projetada para processar dados automaticamente. Ele recebe entradas, realiza operações e fornece saídas. A principal função de um computador é seguir instruções de forma precisa e repetitiva, o que permite a execução de tarefas complexas com rapidez e confiabilidade.\nEssas instruções são transformadas em algoritmos que o computador interpreta e executa. A máquina processa informações através de cálculos e operações lógicas de acordo com as regras definidas pelos algoritmos. Diferente de um ser humano, que toma decisões de forma subjetiva, o computador executa essas operações com base no que foi programado.",
    "crumbs": [
      "Introdução",
      "Fundamentos de computadores"
    ]
  },
  {
    "objectID": "introducao/OrganizacaoDeComputadores.html#componentes-básicos-de-um-computador",
    "href": "introducao/OrganizacaoDeComputadores.html#componentes-básicos-de-um-computador",
    "title": "Fundamentos de computadores",
    "section": "Componentes Básicos de um Computador",
    "text": "Componentes Básicos de um Computador\n\nHardware\nO hardware são os componentes físicos do computador, como o processador, a memória, o disco rígido e a tela. Cada um desses elementos desempenha um papel essencial no funcionamento da máquina, permitindo que ela armazene dados, execute operações e interaja com o usuário e outros dispositivos.\n\n\nSoftware\nO software é o conjunto de programas e instruções que indicam ao hardware como operar. Ele inclui o sistema operacional, programas de aplicativos e scripts. O software organiza e controla os recursos de hardware, traduzindo os comandos do usuário e as lógicas de programação em ações executáveis pela máquina.",
    "crumbs": [
      "Introdução",
      "Fundamentos de computadores"
    ]
  },
  {
    "objectID": "introducao/OrganizacaoDeComputadores.html#como-os-computadores-processam-dados",
    "href": "introducao/OrganizacaoDeComputadores.html#como-os-computadores-processam-dados",
    "title": "Fundamentos de computadores",
    "section": "Como os Computadores Processam Dados?",
    "text": "Como os Computadores Processam Dados?\nOs computadores funcionam com o sistema binário, o que significa que eles trabalham com apenas dois estados: “ligado” (1) e “desligado” (0). Esses estados são usados para representar todos os tipos de dados, como números, letras, imagens e até sons. O processamento de dados é feito por meio de sequências de bits, as unidades básicas de informação, agrupadas em bytes.\n\nSistema Binário e Representação de Dados\n\nBits e Bytes\nOs dados são representados em sequências de 1s e 0s, conhecidos como bits. Oito bits formam um byte, que é a unidade básica de armazenamento e processamento de informações. Esses bits e bytes são usados para codificar tudo o que um computador pode processar, como texto, imagens e som.\n\n\n\nAlgoritmos\nAlgoritmos são sequências de instruções que guiam o computador para resolver problemas ou realizar tarefas. Eles são fundamentais para todas as operações de um computador, desde cálculos simples até tarefas complexas como aprendizado de máquina e inteligência artificial.\n\n\nImportância do Processador (CPU)\nO processador, ou CPU (Central Processing Unit), é o cérebro do computador. Ele é responsável por interpretar e executar as instruções dos programas. A CPU realiza cálculos, toma decisões e gerencia os dados conforme as instruções do software.",
    "crumbs": [
      "Introdução",
      "Fundamentos de computadores"
    ]
  },
  {
    "objectID": "introducao/OrganizacaoDeComputadores.html#memória-e-armazenamento",
    "href": "introducao/OrganizacaoDeComputadores.html#memória-e-armazenamento",
    "title": "Fundamentos de computadores",
    "section": "Memória e Armazenamento",
    "text": "Memória e Armazenamento\n\nMemória RAM\nA memória RAM (Random Access Memory) é usada pelo computador para armazenar temporariamente dados e programas que estão sendo executados. Ela é volátil, ou seja, perde seu conteúdo quando o computador é desligado.\n\n\nArmazenamento Permanente\nOs dados permanentes, como documentos e programas, são armazenados em dispositivos de armazenamento como discos rígidos (HDs) ou unidades de estado sólido (SSDs). Esses dispositivos têm a função de guardar dados de forma permanente, permitindo seu acesso a qualquer momento.\n\n\nEntrada e Saída de Dados\nOs computadores interagem com o mundo exterior por meio de dispositivos de entrada e saída. Dispositivos de entrada incluem o teclado, mouse e microfone, enquanto dispositivos de saída incluem a tela e impressora. Eles permitem a comunicação entre o usuário e a máquina, tornando a experiência computacional interativa.",
    "crumbs": [
      "Introdução",
      "Fundamentos de computadores"
    ]
  },
  {
    "objectID": "introducao/IntroducaoAPython.html",
    "href": "introducao/IntroducaoAPython.html",
    "title": "Introdução A Python",
    "section": "",
    "text": "Em Python, as variáveis representam espaços na memória utilizados para armazenar dados que podem ser manipulados durante a execução de um programa. Esses dados podem ser de diferentes tipos, como números (int e float), textos (string), listas (list), dicionários (dict) ou até objetos mais complexos (cenas dos próximos capítulos). Uma das principais características da linguagem é sua tipagem dinâmica, o que significa que não é necessário declarar previamente o tipo de uma variável — o interpretador identifica automaticamente o tipo de dado com base no valor atribuído a ela. Assim, uma variável pode receber um número em um momento e, posteriormente, um texto, sem que o programador precise realizar uma redefinição explícita do tipo.\nDeclarar uma variável, em termos conceituais, significa criar uma referência que aponta para um determinado valor armazenado na memória. Já inicializar uma variável consiste em atribuir-lhe um valor inicial, permitindo que o programa utilize essa informação. Em Python, a declaração e a inicialização geralmente ocorrem simultaneamente, pois basta atribuir um valor a um nome para que a variável seja criada.\nApesar da flexibilidade proporcionada pela tipagem dinâmica, o Python também oferece a possibilidade de indicar explicitamente o tipo esperado de uma variável por meio das chamadas type hints. Esses indicadores não alteram o funcionamento do código em tempo de execução, mas servem como uma forma de documentação e auxiliam ferramentas de análise estática, tornando o código mais legível, seguro e fácil de manter. Essa prática é especialmente útil em projetos de maior porte, nos quais a clareza sobre o tipo de dados esperados em cada parte do programa contribui para reduzir erros e melhorar a colaboração entre desenvolvedores.\n\n\nEm Python, declarar uma variável é muito simples: basta escolher um nome e atribuir um valor a ele usando o sinal de igual (=), o operador de atribuição do Python. A linguagem cria automaticamente a variável e identifica seu tipo com base no valor atribuído. Não é necessário especificar o tipo antes, pois o Python faz isso automaticamente.\nO padrão de declaração, portanto é:\n\nnome_da_variavel: tipo_da_variavel = valor_da_variavel\n\nou (sem especificação do tipo da variável)\n\nnome_da_variavel = valor_da_variavel\n\nA seguir estão os principais tipos de variáveis que você pode declarar:\n\n\n\nPara declarar um int chamado “variavel_tipo_inteiro” inicializado com o valor 5, basta fazer o seguinte:\n\nvariavel_tipo_inteiro: int = 5\n\nou\n\nvariavel_tipo_inteiro = 5\n\n\n\n\nPara declarar um float chamado “variavel_tipo_float” incializado com o valor 3.14, basta fazer o seguinte:\n\nvariavel_tipo_float: float = 3.14\n\nou\n\nvariavel_tipo_float = 3.14\n\n\n\n\nPara declarar uma string chamada “variavel_tipo_string” incializada com o valor “Minha string”, basta fazer o seguinte:\n\nvariavel_tipo_string: str = \"Minha string\"\n\nou\n\nvariavel_tipo_string = \"Minha string\"\n\n\n\n\n\n\n\nNoteObservação importante\n\n\n\nO tipo string em Python é chamado str, e, para incializá-lo com algum valor, este valor pode estar em aspas duplas (““) ou aspas simples. Assim, aqui estão outras duas maneiras de declarar as mesmas variáveis:\n\nvariavel_tipo_string: str = 'Minha string'\n\nou\n\nvariavel_tipo_string = 'Minha string'\n\n\n\n\n\n\nPara declarar um bool chamado “variavel_tipo_bool” incializado com o valor True, basta fazer o seguinte:\n\nvariavel_tipo_bool: bool = True\n\nou\n\nvariavel_tipo_bool = True\n\n\n\n\nPara declarar um list chamada “variavel_tipo_lista” e incializá-lo com algum(s) valor(es), basta fazer o seguinte:\n\nvariavel_tipo_lista: list = [1, 4, 89]\n\nou\n\nvariavel_tipo_lista = [1, 4, 89]\n\n\n\n\n\n\n\nNoteObservação importante\n\n\n\nUma lista pode conter conter qualquer tipo de variável nos seus elementos, poranto todas as listas seguintes são listas válidas em python:\n\nvariavel_tipo_lista: list = [1, 2, 3]\n\n\nvariavel_tipo_lista: list = ['a', 'b', 'c']\n\n\nvariavel_tipo_lista: list = [True, False, True]\n\nPortanto, como uma lista pode conter qualquer tipo de variável em seus elementos, isto nos leva a dois casos “extremos” que são completamente válidos em python (e quase toda lingugagem de programção):\n\nLista vazia, delcarada a seguir:\n\n\nvariavel_tipo_lista: list = []\n\n\nLista de listas, declarada a seguir:\n\n\nvariavel_tipo_lista: list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nEstas listas de listas são a base de estruturas chamadas matrizes, que serão estudas posteriormente.\n\n\n\n\n\nPara declarar um dict chamado “variavel_tipo_dict” e incializá-lo com algumas chaves e valores, basta fazer o seguinte:\n::: {#75ae3ef1 .cell execution_count=20} {.python .cell-code}   variavel_tipo_dict: dict = {'chave_1' : 1, 'chave_2' : 2, 'chave_3' : 3} :::\nou\n::: {#db02a68c .cell execution_count=21} {.python .cell-code}   variavel_tipo_dict = {'chave_1' : 1, 'chave_2' : 2, 'chave_3' : 3} :::\n\n\n\nExistem ainda outros tipos de variáveis em python, com destaque o tuple e o set, mas ester tipos serão estudados posteriormente.",
    "crumbs": [
      "Introdução",
      "Introdução A Python"
    ]
  },
  {
    "objectID": "introducao/IntroducaoAPython.html#variáveis-em-python",
    "href": "introducao/IntroducaoAPython.html#variáveis-em-python",
    "title": "Introdução A Python",
    "section": "",
    "text": "Em Python, as variáveis representam espaços na memória utilizados para armazenar dados que podem ser manipulados durante a execução de um programa. Esses dados podem ser de diferentes tipos, como números (int e float), textos (string), listas (list), dicionários (dict) ou até objetos mais complexos (cenas dos próximos capítulos). Uma das principais características da linguagem é sua tipagem dinâmica, o que significa que não é necessário declarar previamente o tipo de uma variável — o interpretador identifica automaticamente o tipo de dado com base no valor atribuído a ela. Assim, uma variável pode receber um número em um momento e, posteriormente, um texto, sem que o programador precise realizar uma redefinição explícita do tipo.\nDeclarar uma variável, em termos conceituais, significa criar uma referência que aponta para um determinado valor armazenado na memória. Já inicializar uma variável consiste em atribuir-lhe um valor inicial, permitindo que o programa utilize essa informação. Em Python, a declaração e a inicialização geralmente ocorrem simultaneamente, pois basta atribuir um valor a um nome para que a variável seja criada.\nApesar da flexibilidade proporcionada pela tipagem dinâmica, o Python também oferece a possibilidade de indicar explicitamente o tipo esperado de uma variável por meio das chamadas type hints. Esses indicadores não alteram o funcionamento do código em tempo de execução, mas servem como uma forma de documentação e auxiliam ferramentas de análise estática, tornando o código mais legível, seguro e fácil de manter. Essa prática é especialmente útil em projetos de maior porte, nos quais a clareza sobre o tipo de dados esperados em cada parte do programa contribui para reduzir erros e melhorar a colaboração entre desenvolvedores.\n\n\nEm Python, declarar uma variável é muito simples: basta escolher um nome e atribuir um valor a ele usando o sinal de igual (=), o operador de atribuição do Python. A linguagem cria automaticamente a variável e identifica seu tipo com base no valor atribuído. Não é necessário especificar o tipo antes, pois o Python faz isso automaticamente.\nO padrão de declaração, portanto é:\n\nnome_da_variavel: tipo_da_variavel = valor_da_variavel\n\nou (sem especificação do tipo da variável)\n\nnome_da_variavel = valor_da_variavel\n\nA seguir estão os principais tipos de variáveis que você pode declarar:\n\n\n\nPara declarar um int chamado “variavel_tipo_inteiro” inicializado com o valor 5, basta fazer o seguinte:\n\nvariavel_tipo_inteiro: int = 5\n\nou\n\nvariavel_tipo_inteiro = 5\n\n\n\n\nPara declarar um float chamado “variavel_tipo_float” incializado com o valor 3.14, basta fazer o seguinte:\n\nvariavel_tipo_float: float = 3.14\n\nou\n\nvariavel_tipo_float = 3.14\n\n\n\n\nPara declarar uma string chamada “variavel_tipo_string” incializada com o valor “Minha string”, basta fazer o seguinte:\n\nvariavel_tipo_string: str = \"Minha string\"\n\nou\n\nvariavel_tipo_string = \"Minha string\"\n\n\n\n\n\n\n\nNoteObservação importante\n\n\n\nO tipo string em Python é chamado str, e, para incializá-lo com algum valor, este valor pode estar em aspas duplas (““) ou aspas simples. Assim, aqui estão outras duas maneiras de declarar as mesmas variáveis:\n\nvariavel_tipo_string: str = 'Minha string'\n\nou\n\nvariavel_tipo_string = 'Minha string'\n\n\n\n\n\n\nPara declarar um bool chamado “variavel_tipo_bool” incializado com o valor True, basta fazer o seguinte:\n\nvariavel_tipo_bool: bool = True\n\nou\n\nvariavel_tipo_bool = True\n\n\n\n\nPara declarar um list chamada “variavel_tipo_lista” e incializá-lo com algum(s) valor(es), basta fazer o seguinte:\n\nvariavel_tipo_lista: list = [1, 4, 89]\n\nou\n\nvariavel_tipo_lista = [1, 4, 89]\n\n\n\n\n\n\n\nNoteObservação importante\n\n\n\nUma lista pode conter conter qualquer tipo de variável nos seus elementos, poranto todas as listas seguintes são listas válidas em python:\n\nvariavel_tipo_lista: list = [1, 2, 3]\n\n\nvariavel_tipo_lista: list = ['a', 'b', 'c']\n\n\nvariavel_tipo_lista: list = [True, False, True]\n\nPortanto, como uma lista pode conter qualquer tipo de variável em seus elementos, isto nos leva a dois casos “extremos” que são completamente válidos em python (e quase toda lingugagem de programção):\n\nLista vazia, delcarada a seguir:\n\n\nvariavel_tipo_lista: list = []\n\n\nLista de listas, declarada a seguir:\n\n\nvariavel_tipo_lista: list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nEstas listas de listas são a base de estruturas chamadas matrizes, que serão estudas posteriormente.\n\n\n\n\n\nPara declarar um dict chamado “variavel_tipo_dict” e incializá-lo com algumas chaves e valores, basta fazer o seguinte:\n::: {#75ae3ef1 .cell execution_count=20} {.python .cell-code}   variavel_tipo_dict: dict = {'chave_1' : 1, 'chave_2' : 2, 'chave_3' : 3} :::\nou\n::: {#db02a68c .cell execution_count=21} {.python .cell-code}   variavel_tipo_dict = {'chave_1' : 1, 'chave_2' : 2, 'chave_3' : 3} :::\n\n\n\nExistem ainda outros tipos de variáveis em python, com destaque o tuple e o set, mas ester tipos serão estudados posteriormente.",
    "crumbs": [
      "Introdução",
      "Introdução A Python"
    ]
  },
  {
    "objectID": "introducao/IntroducaoAPython.html#operadores-por-tipo-de-variável",
    "href": "introducao/IntroducaoAPython.html#operadores-por-tipo-de-variável",
    "title": "Introdução A Python",
    "section": "Operadores por tipo de variável",
    "text": "Operadores por tipo de variável\nEm Python, cada tipo de variável possui um conjunto de operadores que podem ser utilizados com ele. Os operadores são símbolos ou palavras especiais que indicam ao interpretador que deve realizar uma operação sobre um ou mais valores. A seguir, apresentamos os principais tipos de variáveis e seus operadores, explicando o funcionamento de cada um.\n\nTipo Inteiro (int)\n\n\n\n\n\n\n\n\n\n\nOperador\nNome\nDescrição\nExemplo\nResultado\n\n\n\n\n+\nAdição\nSoma dois valores inteiros\n3 + 2\n5\n\n\n-\nSubtração\nSubtrai o segundo número do primeiro\n5 - 3\n2\n\n\n*\nMultiplicação\nMultiplica dois números inteiros\n4 * 3\n12\n\n\n/\nDivisão\nDivide o primeiro número pelo segundo (resultado float)\n7 / 2\n3.5\n\n\n//\nDivisão inteira\nRetorna apenas a parte inteira da divisão\n7 // 2\n3\n\n\n%\nMódulo\nRetorna o resto da divisão inteira\n7 % 2\n1\n\n\n**\nExponenciação\nEleva o primeiro número à potência do segundo\n2 ** 3\n8\n\n\n==\nIgualdade\nVerifica se dois valores são iguais\n3 == 3\nTrue\n\n\n!=\nDiferente\nVerifica se dois valores são diferentes\n3 != 2\nTrue\n\n\n&gt;\nMaior que\nRetorna True se o primeiro for maior\n5 &gt; 2\nTrue\n\n\n&lt;\nMenor que\nRetorna True se o primeiro for menor\n2 &lt; 5\nTrue\n\n\n&gt;=\nMaior ou igual\nVerifica se é maior ou igual\n4 &gt;= 4\nTrue\n\n\n&lt;=\nMenor ou igual\nVerifica se é menor ou igual\n3 &lt;= 5\nTrue\n\n\n+=\nAtribuição com soma\nSoma e atribui o resultado\na = 5; a += 2\na = 7\n\n\n-=\nAtribuição com subtração\nSubtrai e reatribui o resultado\na = 5; a -= 2\na = 3\n\n\n\n\n\n\nTipo Ponto Flutuante (float)\n\n\n\n\n\n\n\n\n\n\nOperador\nNome\nDescrição\nExemplo\nResultado\n\n\n\n\n+\nAdição\nSoma dois valores\n3.2 + 2.7\n5.9\n\n\n-\nSubtração\nSubtrai o segundo número do primeiro\n5.0 - 3.1\n1.9\n\n\n*\nMultiplicação\nMultiplica dois números\n4.2 * 2.0\n8.4\n\n\n/\nDivisão\nDivide o primeiro número pelo segundo (resultado float)\n7.0 / 2.0\n3.5\n\n\n//\nDivisão inteira\nRetorna apenas a parte inteira da divisão (como um float)\n7.0 // 2.0\n3.0\n\n\n%\nMódulo\nRetorna o resto da divisão inteira\n7.25 % 3.5\n0.25\n\n\n**\nExponenciação\nEleva o primeiro número à potência do segundo\n2.0 ** 3.0\n8.0\n\n\n==\nIgualdade\nVerifica se dois valores são iguais\n3.14 == 3.14\nTrue\n\n\n!=\nDiferente\nVerifica se dois valores são diferentes\n7.34 != 5.67\nTrue\n\n\n&gt;\nMaior que\nRetorna True se o primeiro for maior\n3.1 &gt; 3\nTrue\n\n\n&lt;\nMenor que\nRetorna True se o primeiro for menor\n3.0 &lt; 8.6\nTrue\n\n\n&gt;=\nMaior ou igual\nVerifica se é maior ou igual\n3.14 &gt;= 3.14\nTrue\n\n\n&lt;=\nMenor ou igual\nVerifica se é menor ou igual\n2.7 &lt;= 5.0\nTrue\n\n\n+=\nAtribuição com soma\nSoma e atribui o resultado\na = 5.0; a += 2.2\na = 7.2\n\n\n-=\nAtribuição com subtração\nSubtrai e reatribui o resultado\na = 3.5; a -= 2.0\na = 1.5\n\n\n\n\n\n\nTipo String (str)\n\n\n\n\n\n\n\n\n\n\nOperador\nNome\nDescrição\nExemplo\nResultado\n\n\n\n\n+\nConcatenação\nJunta duas strings\n\"Olá, \" + \"mundo!\"\n\"Olá, mundo!\"\n\n\n*\nRepetição\nRepete uma string N vezes\n\"Oi\" * 3\n\"OiOiOi\"\n\n\n==\nIgualdade\nVerifica se duas strings são idênticas\n\"abc\" == \"abc\"\nTrue\n\n\n!=\nDiferente\nVerifica se são diferentes\n\"a\" != \"b\"\nTrue\n\n\n&lt;\nComparação lexicográfica\nCompara pela ordem alfabética\n\"a\" &lt; \"b\"\nTrue\n\n\n&gt;\nComparação lexicográfica\nCompara pela ordem alfabética\n\"b\" &gt; \"a\"\nTrue\n\n\n&lt;=\nComparação lexicográfica\nCompara pela ordem alfabética\n\"a\" &lt;= \"a\"\nTrue\n\n\n&gt;=\nComparação lexicográfica\nCompara pela ordem alfabética\n\"b\" &gt;= \"b\"\nTrue\n\n\nin\nContém\nVerifica se uma substring existe\n\"Py\" in \"Python\"\nTrue\n\n\nnot in\nNão contém\nVerifica se uma substring não existe\n\"java\" not in \"python\"\nTrue\n\n\n[ ]\nAcesso por índice\nAcessa um caractere da string\n\"Python\"[0]\n\"P\"\n\n\n\n\n\n\nTipo Booleano (bool)\n\n\n\n\n\n\n\n\n\n\nOperador\nNome\nDescrição\nExemplo\nResultado\n\n\n\n\nand\nE lógico\nVerdadeiro se ambos forem verdadeiros\nTrue and False\nFalse\n\n\nor\nOU lógico\nVerdadeiro se um for verdadeiro\nTrue or False\nTrue\n\n\nnot\nNegação\nInverte o valor lógico\nnot True\nFalse\n\n\n==\nComparação\nCompara se dois valores booleanos sã iguais\nTrue == False\nFalse\n\n\n!=\nComparação\nCompara se dois valores booleanos são diferentes\nTrue != False\nTrue\n\n\n\n\n\n\nTipo Lista (list)\n\n\n\n\n\n\n\n\n\n\nOperador\nNome\nDescrição\nExemplo\nResultado\n\n\n\n\n+\nConcatenação\nJunta duas listas\n[1, 2] + [3, 4]\n[1, 2, 3, 4]\n\n\n*\nRepetição\nRepete os elementos\n[1, 2] * 2\n[1, 2, 1, 2]\n\n\nin\nContém\nVerifica se um valor está na lista\n3 in [1, 2, 3]\nTrue\n\n\nnot in\nNão contém\nVerifica se um valor não está na lista\n5 not in [1, 2, 3]\nTrue\n\n\n[ ]\nAcesso por índice\nRetorna o elemento em uma posição\na = [10, 20, 30]; a[1]\n20\n\n\n==\nComparação\nCompara listas elemento a elemento, checando igualdade\n[1,2] == [1,2]\nTrue\n\n\n!=\nComparação\nCompara listas elemento a elemento, checando diferenças\n[1, 2] != [3, 4]\nTrue\n\n\n\n\n\n\nTipo Dicionário (dict)\n\n\n\n\n\n\n\n\n\n\nOperador\nNome\nDescrição\nExemplo\nResultado\n\n\n\n\n[ ]\nAcesso por chave\nRetorna o valor associado\nd = {\"a\": 1}; d[\"a\"]\n1\n\n\nin\nVerifica chave\nRetorna True se a chave existir\n\"a\" in {\"a\": 1}\nTrue\n\n\nnot in\nVerifica ausência\nRetorna True se a chave não existir\n\"b\" not in {\"a\": 1}\nTrue\n\n\n==\nComparação\nCompara dicionários por conteúdo, checando igualdade\n{'a' : 1} == {'a' : 1}\nTrue\n\n\n!=\nComparação\nComparada dicionários por conteúdo, checando diferenças\n{'a' : 1} != {'b' : 2}\nTrue\n\n\n\n\n\n\nObservações gerais\nOs operadores podem ter comportamentos diferentes dependendo do tipo de dado. Os exemplos mais importantes destas diferenças são os seguintes casos:\n\n+ soma números, mas concatena strings e listas;\n* multiplica números, mas repete strings e listas;\nin verifica pertencimento em strings, listas, tuplas, conjuntos e dicionários.",
    "crumbs": [
      "Introdução",
      "Introdução A Python"
    ]
  },
  {
    "objectID": "introducao/IntroducaoAPython.html#introdução-básica-a-entradas-e-saídas-de-dados",
    "href": "introducao/IntroducaoAPython.html#introdução-básica-a-entradas-e-saídas-de-dados",
    "title": "Introdução A Python",
    "section": "Introdução básica a entradas e saídas de dados",
    "text": "Introdução básica a entradas e saídas de dados\nEm Python, é comum precisarmos exibir informações na tela ou receber dados digitados pelo usuário. Para isso, utilizamos as funções print() e input().\n\nExibindo informações com print()\nA função print() é usada para mostrar mensagens, resultados de operações ou valores de variáveis na tela. Basta escrever o que você quer exibir entre parênteses e aspas.\n\nprint(\"Olá, mundo!\")\n\n\n\n\n\n\n\nNoteObservação/Teste este código!\n\n\n\nA saída do código acima é o texto “Olá, mundo!” impresso no terminal.\n\n\nAlém de exibir texto escritos na função, é possível exibir o valor de variáveis utilizando a mesma lógica:\n\ntexto: str = \"Olá, mundo!\"\nprint(texto)\n\n\n\n\n\n\n\nNoteObservação/Teste este código!\n\n\n\nA saída do código acima é o texto “Olá, mundo!” impresso no terminal.\n\n\nTambém é possivel exibir mais de um texto, passando estes textos à função na ordem que você deseja que sejam mostrados, separados com vírgulas:\n\nnome: str = \"Maria\"\nprint(\"Olá, \", nome)\n\n\n\n\n\n\n\nNoteObservação/Teste este código!\n\n\n\nA saída do código acima é o texto “Olá, Maria” impresso no terminal.\n\n\n\n\nLendo informações com input()\nA função input() serve para coletar dados digitados pelo usuário. Tudo o que o usuário digitar será lido como uma string (str).\n\nnome = input(\"Digite seu nome: \")\nprint(\"Olá, \", nome)\n\n\n\n\n\n\n\nNoteObservação/Teste este código!\n\n\n\nAo executar este código, será exibida a mensagem “Digite seu nome:” no terminal.\nO programa então aguardará que o usuário digite um valor e pressione Enter.\nO texto digitado será armazenado como uma string na variável nome e, em seguida, exibido na tela junto à saudação “Olá,”.\nExemplo:\nSe o usuário digitar “Pedro”, a saída será: “Olá, Pedro”.\n\n\nComo toda coleta de dados realizada pela função input() é uma string, se for necessário trabalhar com números, é preciso converter o valor digitado usando int() ou float():\n\nidade = int(input(\"Digite sua idade: \"))\naltura = float(input(\"Digite sua altura: \"))\nprint(\"Você tem\", idade, \"anos e mede\", altura, \"metros.\")\n\n\n\n\n\n\n\nNoteObservação/Teste este código!\n\n\n\nAo executar este código, o programa solicitará duas entradas do usuário:\n\nIdade: será exibida a mensagem “Digite sua idade:” e o valor digitado será convertido para um número inteiro (int) e armazenado na variável idade.\n\nAltura: será exibida a mensagem “Digite sua altura:” e o valor digitado será convertido para um número decimal (float) e armazenado na variável altura.\n\nApós a coleta desses dados, o programa exibirá na tela a frase com os valores fornecidos:\nExemplo:\nSe o usuário digitar 25 para a idade e 1.75 para a altura, a saída será: “Você tem 25 anos e mede 1.75 metros.”\n\n\n\n\nTabela de consulta\n\n\n\nFunção\nUtilidade\nTipo de dado retornado\n\n\n\n\nprint()\nExibe informações na tela\n(Não retorna nada)\n\n\ninput()\nLê dados digitados pelo usuário\nstr (texto)",
    "crumbs": [
      "Introdução",
      "Introdução A Python"
    ]
  },
  {
    "objectID": "introducao/IntroducaoAPython.html#comentários-em-python",
    "href": "introducao/IntroducaoAPython.html#comentários-em-python",
    "title": "Introdução A Python",
    "section": "Comentários em Python",
    "text": "Comentários em Python\nComentários são partes do código que não são executadas pelo Python. Eles servem para explicar trechos do programa, deixar observações importantes ou facilitar o entendimento do código para outras pessoas — ou para você mesmo no futuro.\n\nComentários de uma linha\nPara criar um comentário de uma linha, utiliza-se o símbolo #. Tudo o que estiver depois dele será ignorado pelo interpretador.\n\n# Este é um comentário de uma linha\n\nx: int = 10  # Também é possível comentar ao lado de um comando\n\n\n\nComentários de múltiplas linhas\nPython não possui um símbolo específico para comentários longos, mas é comum utilizar três aspas (simples ou duplas). Quando esse texto não é atribuído a nenhuma variável, ele é ignorado pelo interpretador e funciona como bloco de comentário.\n\nUsando aspas duplas\n\n\"\"\"\nEste é um comentário\nde múltiplas linhas.\nEle é útil para explicações mais longas.\n\"\"\"\n\n\n\nUsando aspas simples\n\n'''\nTambém funciona com aspas simples.\nUse quando quiser escrever textos longos.\n'''\n\n\n\n\n\n\n\nNoteObservação importante\n\n\n\nApesar de serem usados como comentários longos, esses blocos também são considerados strings multilinha. Eles só funcionam como comentário quando não são atribuídos a nenhuma variável.\n\n\n\n\n\nQuando usar comentários?\nComentários são úteis quando:\n\num trecho de código não é óbvio;\né importante registrar o porquê de uma decisão;\nvocê quer facilitar a leitura para outras pessoas;\ndeseja documentar partes específicas do algoritmo.\n\nEvite escrever comentários desnecessários, como explicar algo óbvio demais. Prefira comentários que realmente esclareçam a intenção do código.",
    "crumbs": [
      "Introdução",
      "Introdução A Python"
    ]
  },
  {
    "objectID": "introducao/IntroducaoAPython.html#exercícios",
    "href": "introducao/IntroducaoAPython.html#exercícios",
    "title": "Introdução A Python",
    "section": "Exercícios",
    "text": "Exercícios\n\nExercício 1\nClassifique as seguintes variáveis com base em seu tipo:\n\nidade = 25\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nint, pois 25 é um número sem casas decimais.\n\n\n\n\naltura = 1.82\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nfloat, pois 1.82 é um número com casas decimais.\n\n\n\n\nnome = “Maria”\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nstr, pois “Maria” é texto.\n\n\n\n\naprovado = True\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nbool, pois True é um valor booleano.\n\n\n\n\nnotas = [8.5, 7.0, 9.2]\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nlist, pois a variável notas contém 3 posições, em cada uma delas sendo armazenado um float.\n\n\n\n\ndados = {“nome”: “João”, “idade”: 20}\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\ndict, pois a variável dados tem pares de chaves e valores.\n\n\n\n\n\nExercício 2\nAssumindo que a é uma variável do tipo int com valor igual a 4 e b é uma variável do tipo int com valor igual a 2, complete a tabela:\n\n\n\nOperação\nResultado\n\n\n\n\na + b\n\n\n\na - b\n\n\n\na * b\n\n\n\na / b\n\n\n\na // b\n\n\n\na % b\n\n\n\na ** b\n\n\n\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\n\n\nOperação\nResultado\n\n\n\n\na + b\n6\n\n\na - b\n2\n\n\na * b\n8\n\n\na / b\n2\n\n\na // b\n2\n\n\na % b\n0\n\n\na ** b\n16\n\n\n\n\n\n\n\n\nExercício 3\nAnalise o código a seguir e faça o que se pede:\n\na: str = '5'\nb: str = '5'\n\nc = a + b\n\n\nQual o valor da variável c?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nComo a e b são duas variáveis do tipo str, para avaliar a soma das duas, basta entender que o operador + concatena (junta) duas variáveis do tipo str. Ou seja, o resultado será a concatenação de ‘5’ com ‘5’, que é igual a ‘55’.\n\n\n\n\nQual o tipo da variável c?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nComo a e b são duas variáveis do tipo str, a concatenação de a e b resultará em uma outra variável do tpo str.\n\n\n\n\n\nExercício 4\nAvalie o seguinte código:\n\na: int = 5\n\na += 2\na *= 2\na -= 4\n\nQual é o valor final da variável a?\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nPara descobrir o valor de a, basta realizar todas as operações que foram feitas em a.\n\na += 2 -&gt; a = a + 2 -&gt; a = 5 + 2 -&gt; a = 7. Logo, após a execução da linha a += 2, o valor de a é 7.\na = 2 -&gt; a = a  2 -&gt; a = 7 * 2 -&gt; a = 14. Logo, após a execução da linha a *= 2, o valor de a é 14.\na -= 4 -&gt; a = a - 4 -&gt; a = 14 - 4 -&gt; a = 10. Logo, após a execução da linha a -= 4, o valor de a é 10.\n\nPortanto, o valor final da variável a é 10.\n\n\n\n\n\nExercício 5\nDada a lista, faça o que se pede:\n\nnumeros = [10, 20, 30, 40]\n\n\nO que significa numeros[2]?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nnumeros[2] significa acessar o elemento armazenado no índice 2 da lista numeros. Como a contagem de índices inicia em 0, numeros[2] nos retorna o terceiro elemento, neste caso 30.\n\n\n\n\nE numeros[0]?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nnumeros[0] significa acessar o primeiro elemento da lista numeros, que neste caso é 10.\n\n\n\n\nComo acessar o último elemento desta lista?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nPara acessar o último elemento de uma lista com n elementos, basta acessar a lista na posição n - 1. Neste caso, n é 4, pois a lista possui 4 elementos, então, o comando para acessar o último elemento é numeros[3].",
    "crumbs": [
      "Introdução",
      "Introdução A Python"
    ]
  },
  {
    "objectID": "introducao/IntroducaoAPython.html#desafio",
    "href": "introducao/IntroducaoAPython.html#desafio",
    "title": "Introdução A Python",
    "section": "Desafio",
    "text": "Desafio\nDado o código:\n\naluno = {\"nome\": \"Lucas\", \"notas\": [7.5, 8.0, 9.0]}\nmedia = (aluno[\"notas\"][0] + aluno[\"notas\"][1] + aluno[\"notas\"][2]) / 3\n\n\nO que o programa faz?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nEste programa calcula a média de 3 notas: 7.5, 8.0 e 9.0, que estão armazenadas como uma lista, guardada dentro de um dict.\n\n\n\n\nO que significa aluno[“notas”]?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAcessar aluno[“notas”] significa acessar uma lista que está guardada na posição “notas” no dict aluno.\n\n\n\n\nQual é o valor final da variável media?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nO valor final é a soma de cada uma das posições de aluno[“notas”] dividido por 3. Vamos descobrir estes valores passo a passo:\n\naluno[“notas”][0] = 7.5\naluno[“notas”][1] = 8.0\naluno[“notas”][2] = 9.0\n\nLogo, o cálculo é: \\(\\frac{7.5 + 8.0 + 9.0}{3}\\) -&gt; \\(\\frac{24.5}{3}\\) -&gt; \\(8.16666...\\)\nPortanto, o valor final da variavel media é 8.166666\n\n\n\n\nQual o tipo da variável media?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nA variável média é um float, pois o resultado da conta da média é um número com casas decimais.",
    "crumbs": [
      "Introdução",
      "Introdução A Python"
    ]
  },
  {
    "objectID": "introducao/Exercicios.html",
    "href": "introducao/Exercicios.html",
    "title": "Exercícios",
    "section": "",
    "text": "Defina o melhor tipo de variável para se utilizar nos seguintes casos:\n\nA quantidade de pessoas que existem no planeta;\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nint - pois o número de pessoas que existem no planeta é inteiro.\n\n\n\n\nO nome de uma pessoa;\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nstring - pois um nome é uma sequência de caracteres.\n\n\n\n\nO peso (medido com alta precisão) de um prego;\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nfloat - pois um peso medido com alta precisão, idependente da unidade de medição (kg, g, etc), muito provavelmente terá casas decimais.\n\n\n\n\nUma lista que contém todas as notas de alunos associadas aos seus nomes;\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\ndict - pois queremos associas pares de chave (nome) com valor (nota do aluno).\n\n\n\n\nA média entre dois números;\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nfloat - pois a média entre quaisquer dois números tem alta probabilidade de conter casas decimais.\n\n\n\n\n\n\nLeia os valores abaixo e diga qual seria o tipo de variável ideal para armazenar cada um deles:\n\n42\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nint - pois é um número inteiro.\n\n\n\n\n“Olá, mundo!”\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nstring - pois é uma sequência de caracteres.\n\n\n\n\n3.1415\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nfloat - pois é um número não-inteiro.\n\n\n\n\nTrue\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nbool - pois é um valor booleano.\n\n\n\n\n-1200\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nint - pois é um número inteiro.\n\n\n\n\n\n\nLeia as sentenças e separe o nome da variável e o valor armazenado:\n\ncidade = “Recife”\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\ncidade é o nome da variável e a string “Recife” é seu valor.\n\n\n\n\npopulacao = 1600000\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\npopulacao é o nome da variável e o seu valor é 1600000 (tipo int).\n\n\n\n\ncapital = True\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\ncapital é o nome da variável e o seu valor é True (tipo bool).\n\n\n\n\n\n\nExplique o que acontece se tentarmos somar “5” (string) com 5 (inteiro). Como você poderia corrigir o código para que a soma funcione corretamente?\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nA operação \"5\" + 5 não funciona porque os dois elementos são de tipos diferentes, e a operação de somar um int a uma string não está definida. Para corrigir o erro, ambos os valores devem ser do mesmo tipo. Para isso, podem ser feitas duas correções diferentes:\n\n\"5\" + \"5\" -&gt; resulta em \"55\"\n5 + 5 -&gt; resulta em 10\n\n\n\n\n\n\n\nSem executar, diga qual tipo de dado cada variável deve ter no código abaixo:\n\nnome = \"Maria\"\nidade = 17\naltura = 1.63\nmaior_de_idade = False\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nnome: string, pois é uma sequência de caracteres\nidade: int, pois é um número inteiro\naltura: float, pois é um número não inteiro\nmaior_de_idade: bool, pois é um valor booleano\n\n\n\n\n\n\n\nObserve os exemplos abaixo e diga se cada um representa uma lista ou um dicionário:\n\n[“maçã”, “banana”, “uva”]\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nlist - pois não temos pares de chave e valor, somente valores.\n\n\n\n\n{“nome”: “Maria”, “idade”: 20}\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\ndict - pois temos pares de chave e valor.\n\n\n\n\n[10, 20, 30, 40, 50]\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nlist - pois não temos pares de chave e valor, somente valores.\n\n\n\n\n{“cor”: “azul”, “tamanho”: “M”, “estoque”: 12}\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\ndict - pois temos pares de chave e valor.\n\n\n\n\n[True, False, True, False]\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nlist - pois não temos pares de chave e valor, somente valores.\n\n\n\n\n\n\nAnalise a seguinte estrutura e responda os items 1, 2 e 3:\n\nanimais = [\"gato\", \"cachorro\", \"papagaio\", \"peixe\"]\n\n\nQuantos elementos essa lista possui?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n4 elementos.\n\n\n\n\nQual elemento está na posição 0?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n“gato”.\n\n\n\n\nQual elemento está na última posição?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n“peixe”.\n\n\n\n\n\n\nObserve o dicionário abaixo e responda os items 1, 2 e 3:\n\naluno = {\"nome\": \"Pedro\", \"idade\": 19, \"curso\": \"Física\"}\n\nResponda: 1. Quantas chaves ele possui?\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n3 chaves - “nome”, “idade” e “curso”.\n\n\n\n\nQuais são os valores associados a essas chaves?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\no valor associado a “nome” é “Pedro”, o valor associado a “idade” é 19 e o valor associado a “curso” é “Física”.\n\n\n\n\nQuais são os tipos dos valores deste dict?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\no tipo do valor “Pedro” é string, pois “Pedro” é uma sequência de caracteres.\no tipo do valor 19 é int, pois 19 é um número inteiro.\no tipo do valor “Física” é string, pois “Física” é uma sequência de caracteres.\n\n\n\n\n\n\n\nLeia as situações e identifique se seria mais adequado usar uma lista ou um dicionário:\n\nGuardar as notas de uma prova em ordem (sem nomes, apenas os valores).\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nlist - pois não queremos associar valores a uma chave.\n\n\n\n\nArmazenar o nome e a nota de cada aluno em uma turma.\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\ndict - pois queremos associar valores (os nomes dos alunos) a chaves (as notas).\n\n\n\n\nGuardar uma sequência de números sorteados em um jogo.\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nlist - pois não queremos associar valores a uma chave.\n\n\n\n\nRepresentar as informações de um produto (nome, preço, categoria).\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\ndict - pois queremos associar valores (os atributos do produto) a chaves (os valores destes atributos).\nPor exemplo:\n\n# produto carro\nproduto_carro = {\"modelo\" : \"Polo\", \"marca\" : \"Volkswagen\", \"ano\" : 2019}\n\n# produto celular\nproduto_celular = {\"modelo\" : \"A12\", \"marca\" : \"Samsung\", \"ano\" : 2021}\n\n\n\n\n\nArmazenar todas as cidades que uma pessoa já visitou.\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nlist - pois não queremos associar valores a uma chave.",
    "crumbs": [
      "Introdução",
      "Exercícios"
    ]
  },
  {
    "objectID": "introducao/Exercicios.html#exercícios-de-variáveis",
    "href": "introducao/Exercicios.html#exercícios-de-variáveis",
    "title": "Exercícios",
    "section": "",
    "text": "Defina o melhor tipo de variável para se utilizar nos seguintes casos:\n\nA quantidade de pessoas que existem no planeta;\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nint - pois o número de pessoas que existem no planeta é inteiro.\n\n\n\n\nO nome de uma pessoa;\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nstring - pois um nome é uma sequência de caracteres.\n\n\n\n\nO peso (medido com alta precisão) de um prego;\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nfloat - pois um peso medido com alta precisão, idependente da unidade de medição (kg, g, etc), muito provavelmente terá casas decimais.\n\n\n\n\nUma lista que contém todas as notas de alunos associadas aos seus nomes;\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\ndict - pois queremos associas pares de chave (nome) com valor (nota do aluno).\n\n\n\n\nA média entre dois números;\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nfloat - pois a média entre quaisquer dois números tem alta probabilidade de conter casas decimais.\n\n\n\n\n\n\nLeia os valores abaixo e diga qual seria o tipo de variável ideal para armazenar cada um deles:\n\n42\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nint - pois é um número inteiro.\n\n\n\n\n“Olá, mundo!”\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nstring - pois é uma sequência de caracteres.\n\n\n\n\n3.1415\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nfloat - pois é um número não-inteiro.\n\n\n\n\nTrue\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nbool - pois é um valor booleano.\n\n\n\n\n-1200\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nint - pois é um número inteiro.\n\n\n\n\n\n\nLeia as sentenças e separe o nome da variável e o valor armazenado:\n\ncidade = “Recife”\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\ncidade é o nome da variável e a string “Recife” é seu valor.\n\n\n\n\npopulacao = 1600000\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\npopulacao é o nome da variável e o seu valor é 1600000 (tipo int).\n\n\n\n\ncapital = True\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\ncapital é o nome da variável e o seu valor é True (tipo bool).\n\n\n\n\n\n\nExplique o que acontece se tentarmos somar “5” (string) com 5 (inteiro). Como você poderia corrigir o código para que a soma funcione corretamente?\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nA operação \"5\" + 5 não funciona porque os dois elementos são de tipos diferentes, e a operação de somar um int a uma string não está definida. Para corrigir o erro, ambos os valores devem ser do mesmo tipo. Para isso, podem ser feitas duas correções diferentes:\n\n\"5\" + \"5\" -&gt; resulta em \"55\"\n5 + 5 -&gt; resulta em 10\n\n\n\n\n\n\n\nSem executar, diga qual tipo de dado cada variável deve ter no código abaixo:\n\nnome = \"Maria\"\nidade = 17\naltura = 1.63\nmaior_de_idade = False\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nnome: string, pois é uma sequência de caracteres\nidade: int, pois é um número inteiro\naltura: float, pois é um número não inteiro\nmaior_de_idade: bool, pois é um valor booleano\n\n\n\n\n\n\n\nObserve os exemplos abaixo e diga se cada um representa uma lista ou um dicionário:\n\n[“maçã”, “banana”, “uva”]\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nlist - pois não temos pares de chave e valor, somente valores.\n\n\n\n\n{“nome”: “Maria”, “idade”: 20}\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\ndict - pois temos pares de chave e valor.\n\n\n\n\n[10, 20, 30, 40, 50]\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nlist - pois não temos pares de chave e valor, somente valores.\n\n\n\n\n{“cor”: “azul”, “tamanho”: “M”, “estoque”: 12}\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\ndict - pois temos pares de chave e valor.\n\n\n\n\n[True, False, True, False]\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nlist - pois não temos pares de chave e valor, somente valores.\n\n\n\n\n\n\nAnalise a seguinte estrutura e responda os items 1, 2 e 3:\n\nanimais = [\"gato\", \"cachorro\", \"papagaio\", \"peixe\"]\n\n\nQuantos elementos essa lista possui?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n4 elementos.\n\n\n\n\nQual elemento está na posição 0?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n“gato”.\n\n\n\n\nQual elemento está na última posição?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n“peixe”.\n\n\n\n\n\n\nObserve o dicionário abaixo e responda os items 1, 2 e 3:\n\naluno = {\"nome\": \"Pedro\", \"idade\": 19, \"curso\": \"Física\"}\n\nResponda: 1. Quantas chaves ele possui?\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n3 chaves - “nome”, “idade” e “curso”.\n\n\n\n\nQuais são os valores associados a essas chaves?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\no valor associado a “nome” é “Pedro”, o valor associado a “idade” é 19 e o valor associado a “curso” é “Física”.\n\n\n\n\nQuais são os tipos dos valores deste dict?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\no tipo do valor “Pedro” é string, pois “Pedro” é uma sequência de caracteres.\no tipo do valor 19 é int, pois 19 é um número inteiro.\no tipo do valor “Física” é string, pois “Física” é uma sequência de caracteres.\n\n\n\n\n\n\n\nLeia as situações e identifique se seria mais adequado usar uma lista ou um dicionário:\n\nGuardar as notas de uma prova em ordem (sem nomes, apenas os valores).\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nlist - pois não queremos associar valores a uma chave.\n\n\n\n\nArmazenar o nome e a nota de cada aluno em uma turma.\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\ndict - pois queremos associar valores (os nomes dos alunos) a chaves (as notas).\n\n\n\n\nGuardar uma sequência de números sorteados em um jogo.\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nlist - pois não queremos associar valores a uma chave.\n\n\n\n\nRepresentar as informações de um produto (nome, preço, categoria).\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\ndict - pois queremos associar valores (os atributos do produto) a chaves (os valores destes atributos).\nPor exemplo:\n\n# produto carro\nproduto_carro = {\"modelo\" : \"Polo\", \"marca\" : \"Volkswagen\", \"ano\" : 2019}\n\n# produto celular\nproduto_celular = {\"modelo\" : \"A12\", \"marca\" : \"Samsung\", \"ano\" : 2021}\n\n\n\n\n\nArmazenar todas as cidades que uma pessoa já visitou.\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nlist - pois não queremos associar valores a uma chave.",
    "crumbs": [
      "Introdução",
      "Exercícios"
    ]
  },
  {
    "objectID": "introducao/Exercicios.html#exercícios-de-interpretação-de-fluxograma",
    "href": "introducao/Exercicios.html#exercícios-de-interpretação-de-fluxograma",
    "title": "Exercícios",
    "section": "Exercícios de interpretação de fluxograma",
    "text": "Exercícios de interpretação de fluxograma\n\nExercício 1\nDescreva o funcionamento do algoritmo representado neste fluxograma:\n\n\n\n\n\nflowchart LR\n    A([Início]) --&gt; B[/Ler valor de a e b/]\n    B --&gt; C[c = a + b]\n    C --&gt; D[Imprimir c]\n    D --&gt; E([Término])\n\n\n\n\n\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nO fluxograma descreve um algorítmo que primeiramente lê valores de duas variáveis, a e b. Com estas variáveis, o algorítmo calcula um terceiro valor, a soma de a e b, armazenado em c. Por fim, o algorítmo imprime a variável c e termina.\n\n\n\n\n\nExercício 2\nDescreva o funcionamento do algoritmo representado neste fluxograma:\n\n\n\n\n\nflowchart LR\n    A([Início]) --&gt; B[/Ler valor de a e b/]\n    B --&gt; C[\"média = (a + b) / 2\"]\n    C --&gt; D[Imprimir média]\n    D --&gt; E([Término]) \n\n\n\n\n\n\n\n\n\n\n\n\nWarningObservação importante\n\n\n\nNo fluxograma acima, é utilizada uma variável cahamada “média”, com acento em seu nome. Para a implementação deste fluxograma em código, é correto alterar seu nome para “media”, sem acento, pois nomes de variáveis em programas não devem conter caracteres especiais.\n\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nO fluxograma descreve um algorítmo que primeiramente lê valores de duas variáveis, a e b. Com estas variáveis, o algorítmo calcula um terceiro valor, a média entre a e b, armazenado na varíavel média. Por fim, o algorítmo imprime a variável média e termina.\n\n\n\n\n\nExercício 3\nDescreva o funcionamento do algoritmo representado neste fluxograma:\n\n\n\n\n\nflowchart LR\n    A([Início]) --&gt; B[/ler a e b/]\n    B --&gt; C[temp = a]\n    C --&gt; D[a = b]\n    D --&gt; E[b = temp]\n    E --&gt; F[Imprimir a e b]\n    F --&gt; G([Término])\n\n\n\n\n\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nO fluxograma descreve um algorítmo que troca os valores de duas variáveis. Para isto, o alogrítmo inicialmente lê dois valores para variáveis a e b. Após isto, uma nova variável chamada temp é declarada com o valor de a. Isto permite que a tenha seu valor alterado para o valor de b, e depois que b tenha seu valor alterado para o valor guardado em temp (que é o valor inicial de a). Após isto, os valores de a e b são impressos e o algorítmo termina.",
    "crumbs": [
      "Introdução",
      "Exercícios"
    ]
  },
  {
    "objectID": "introducao/Exercicios.html#exercícios-de-implementação-simples-sem-condicional",
    "href": "introducao/Exercicios.html#exercícios-de-implementação-simples-sem-condicional",
    "title": "Exercícios",
    "section": "Exercícios de implementação simples (sem condicional)",
    "text": "Exercícios de implementação simples (sem condicional)\n\nExercício 1\nImplemente um algoritmo que leia uma temperatura em Celsius e converta para Kelvin usando a fórmula: \\(K = C + 273\\), onde \\(K\\) é a temperatura em graus Kelvin e \\(C\\) é a temperatura em graus celsius.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nC: float = float(input('Insira a temperatura em graus Celsius: '))\nK: float = C + 273\n\nprint('A temperatura em graus Kelvin é: ', K)\n\nNeste bloco de código, uma variável chamada C é inicializada com um valor lido do terminal, através da função input(). Após ler a entrada, é feito o cálculo de conversão dos graus Celsius para Kelvin e o valor da conversão é armazenado em uma variável chamada K. Por fim, o valor de K é impresso na tela.\n\n\n\n\n\n\nNoteObservação\n\n\n\n\nNeste código, os nomes das variáveis são pouco descritíveis, e foram escolhidos somente para exemplificar com clareza o que o enunciado pede. Nomes melhores de variáveis seriam “temperaturaEmGrausCelsius” ao invés de “C” e “temperaturaEmGrausKelvin” ao invés de K.\nNomes de variáveis inteiramente escritos em letras maiúsculas são geralmente reservados para constantes, assim há um outro motivo pelo qual os nomes “C” e “K” não são boas escolhas.\n\n\n\n\n\n\n\n\nExercício 2\nImplemente o código que realiza o algorítmo descrito pelo seguinte fluxograma:\n\n\n\n\n\n    flowchart LR\n        A([Início]) --&gt; B[/Ler largura e altura/]\n        B --&gt; C[area = largura * altura]\n        C --&gt; D[Imprimir area]\n        D --&gt; E([Término])\n\n\n\n\n\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nlargura: float = float(input('Insira a largura: '))\naltura: float = float(input('Insira a altura: '))\n\narea: float = largura * altura\n\nprint('A área do retangulo é: ', area)\n\nNeste bloco de código, são declaradas duas variáveis do tipo float, largura e altura, e ambas são inicializadas com valores lidos do terminal. Após ler valores para largura e altura, a fórmula de área de um retângulo (\\(A = B \\times h\\)) é aplicada e o novo valor calculado é salvo em uma variavel chamada area. Por fim, o valor da área é impresso e algorítmo termina sua execução.\n\n\n\n\n\n\nNoteObservação\n\n\n\nÉ importante observar que o nome da variável que guarda a área do retângulo descrito no código é area e não área. Isto se deve porque não é uma boa prática de programação implementar variáveis que possuam nomes com caracteres especiais (neste caso o “á”).\n\n\n\n\n\n\n\nExercício 3\nImplemente o código que realiza o algorítmo descrito pelo seguinte fluxograma:\n\n\n\n\n\nflowchart LR\n    A([Início]) --&gt; B[/Ler valor de raio/]\n    B --&gt; C[area = 3.1416 * raio * raio]\n    C --&gt; D[Imprimir area]\n    D --&gt; E([Término])\n\n\n\n\n\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nraio: float = float(input('Insira o valor do raio do círculo: '))\npi: float = 3.14\n\narea: float = pi * raio * raio\n\nprint('A área do retangulo é: ', area)\n\nNeste bloco de código, são declaradas duas variáveis, raio e pi. A variável pi é incializada com uma aproximação de \\(\\pi\\) para duas casas decimais, enquanto a variável raio é inicializada com um valor lido do terminal. Após obter os valores de \\(\\pi\\) e raio, basta aplicar a fórmula de cálculo de área de um círculo (\\(A = \\pi r^2\\)) e armazenar o resultado em uma variável chamada area. Por fim, o valor da área é impresso e o programa termina sua execução\n\n\n\n\n\n\nNoteObservação\n\n\n\n\nÉ importante observar que o nome da variável que guarda a área do círculo descrito no código é area e não área. Isto se deve porque não é uma boa prática de programação implementar variáveis que possuam nomes com caracteres especiais (neste caso o “á”).\nUma melhoria a este código é utilizar uma definição de \\(\\pi\\) que venha de algum módulo (como o módulo math), entretanto isto não foi estudado ainda, então será relevado.\n\n\n\n\n\n\n\n\nExercício 4\nImplemente o código que realiza o algorítmo descrito pelo seguinte fluxograma:\n\n\n\n\n\nflowchart LR\n    A([Início]) --&gt; B[/Ler quantidade de horas/]\n    B --&gt; C[minutos = horas * 60]\n    C --&gt; D[Imprimir minutos]\n    D --&gt; E([Término])\n\n\n\n\n\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nhoras: int = int(input('Insira a quantidade de horas: '))\n\nminutos: int = horas * 60\n\nprint('A quantidade de minutos é: ', minutos)\n\nNeste bloco de código, é declarada uma variável horas, do tipo inteiro (int), que é incializada com um valor lido do terminal. Após isto, outra variável, minutos, é definida como a \\(\\text{horas} \\times 60\\). Por fim, o valor de minutos é impresso e o programa termina sua execução.\n\n\n\n\n\n\nNoteObservação\n\n\n\nPara imprimir a quantidade de minutos, foi utilizado uma forma da função print() que imprime os parâmetros passados em ordem. Entretanto, para imprimir uma resposta mais completa, seria mais adequado a utilização de f-string, como descrito abaixo:\n\nprint(f'Em {horas} horas são {minutos} minutos')\n\n\n\n\n\n\n\n\nExercício 5\nImplemente o código que realiza o algorítmo descrito pelo seguinte fluxograma:\n\n\n\n\n\nflowchart LR\n    A([Início]) --&gt; B[/Ler valor de n/]\n    B --&gt; C[soma = 1 + 2 + ... + n]\n    C --&gt; D[Imprimir soma]\n    D --&gt; E([Término])\n\n\n\n\n\n\n\n\n\n\n\n\nTipDica\n\n\n\nLembre-se da soma de Gauss\n\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nn: int = int(input('Insira o valor de n: '))\nsoma: int = (n * (n + 1)) / 2\n\nprint('A soma dos números até n é: ', soma)\n\nNeste bloco de código, é declarada uma variável n (do tipo int), inicializada com um valor lido do terminal. Com este valor estabelecido, a soma de todos os números inteiros começando de 1 até n é calculada com base na soma de Gauss. Após calcular a soma, o valor é impreso na tela e o programa termina sua execução.\n\n\n\n\n\n\nNoteObservação\n\n\n\nPara imprimir a soma, foi utilizado uma forma da função print() que imprime os parâmetros passados em ordem. Entretanto, para imprimir uma resposta mais completa, seria mais adequado a utilização de f-string, como descrito abaixo:\n\nprint(f'A soma de 1 até {n} é: {soma}')",
    "crumbs": [
      "Introdução",
      "Exercícios"
    ]
  },
  {
    "objectID": "introducao/Exercicios.html#exercícios-de-implementação-com-condicional",
    "href": "introducao/Exercicios.html#exercícios-de-implementação-com-condicional",
    "title": "Exercícios",
    "section": "Exercícios de implementação com condicional",
    "text": "Exercícios de implementação com condicional\n\nExercício 1\nCom base no fluxograma abaixo, faça o que se pede:\n\n\n\n\n\nflowchart TD\n    A([Início]) --&gt; B[/Ler valor de n/]\n    B --&gt; C{n &gt;= 0}\n    C --&gt;|Verdadeiro| D[\"Imprimir: Número positivo\"]\n    C --&gt;|Falso| E[\"Imprimir: Número negativo\"]\n    D --&gt; F([Término])\n    E --&gt; F\n\n\n\n\n\n\n\n\nDescreva o que este algorítmo faz;\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nO algorítmo descrito recebe um número n como entrada e descobre se este número é negativo ou positivo, indicando o resultado na saída\n\n\n\n\nImplemente em código o algorítmo descrito pelo fluxograma.\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAbaixo está a implementação do algorítmo descrita no item 1:\n\nn: int = int(input('Insira o valor de n: '))\n\nif(n &gt;= 0):\n    print('Número positivo')\nelse:\n    print('Número negativo')\n\n\n\n\n\n\nExercício 2\nCom base no fluxograma abaixo, faça o que se pede:\n\n\n\n\n\nflowchart TD\n    A([Início]) --&gt; B[/Ler valor de n/]\n    B --&gt; C{n % 2 == 0?}\n    C --&gt;|Verdadeiro| D[\"Imprimir: Número par\"]\n    C --&gt;|Falso| E[\"Imprimir: Número ímpar\"]\n    D --&gt; F([Término])\n    E --&gt; F\n\n\n\n\n\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nO operador módulo “%” retorna o resto de uma divisão. Por exemplo: 7 % 5 = 2, pois 2 é o resto que sobra ao realizar a divisão inteira de 7 por 5.\n\n\n\nDescreva o que este algorítmo faz;\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nO algorítmo descrito recebe um número n como entrada e descobre se este número é part ou ímpar, indicando o resultado na saída.\n\n\n\n\nImplemente em código o algorítmo descrito pelo fluxograma.\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAbaixo está a implementação do algorítmo descrita no item 1:\n\nn: int = int(input('Insira o valor de n: '))\n\nif(n % 2 == 0):\n    print('Número par')\nelse:\n    print('Número ímpar')\n\n\n\n\n\n\nExercício 3\nCom base no fluxograma abaixo, faça o que se pede:\n\n\n\n\n\nflowchart TD\n    A([Início]) --&gt; B[/Ler valores a e b/]\n    B --&gt; C{a &gt; b?}\n    C --&gt;|Verdadeiro| D[\"Imprimir: a é maior\"]\n    C --&gt;|Falso| E[\"Imprimir: b é maior ou igual a a\"]\n    D --&gt; F([Término])\n    E --&gt; F\n\n\n\n\n\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nO operador maior “&gt;” retorna verdadeiro caso o número a esquerda seja estritamente maior que o número a direita e falso caso contrário.\n\n\n\nDescreva o que este algorítmo faz;\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nO algorítmo descrito recebe dois números na entrada, a e b, e descobre qual deles é o maior, indicando o resultado na saída.\n\n\n\n\nImplemente em código o algorítmo descrito pelo fluxograma.\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAbaixo está a implementação do algorítmo descrita no item 1:\n\na: int = int(input('Insira o valor de a: '))\nb: int = int(input('Insira o valor de b: '))\n\nif(a &gt; b):\n    print('a é maior')\nelse:\n    print('b é maior ou igual a a')\n\n\n\n\n\n\nExercício 4\nCom base no fluxograma abaixo, faça o que se pede:\n\n\n\n\n\nflowchart TD\n    A([Início]) --&gt; B[/Ler valor de n/]\n    B --&gt; C{n &gt; 0?}\n    C --&gt;|Verdadeiro| D[\"Imprimir: Número positivo\"]\n    C --&gt;|Falso| E{n &lt; 0}\n    E --&gt;|Verdadeiro| F[\"Imprimir: Número negativo\"]\n    E --&gt;|Falso| G[\"Imprimir: Zero\"]\n    D --&gt; H([Término])\n    F --&gt; H\n    G --&gt; H\n\n\n\n\n\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nO operador maior “&gt;” retorna verdadeiro caso o número a esquerda seja estritamente maior que o número a direita e falso caso contrário.\nDa mesma forma, o operador “&lt;” retorna verdadeiro caso o número a direita seja estritamente maior que o número a direita e falso caso contrário.\n\n\n\nDescreva o que este algorítmo faz;\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nO algorítmo descrito recebe um valor n e descobre se ele é maior, menor ou igual a 0, indicando o resultado na saída.\n\n\n\n\nImplemente em código o algorítmo descrito pelo fluxograma.\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAbaixo está a implementação do algorítmo descrita no item 1:\n\nn: int = int(input('Insira o valor de n: '))\n\nif(n &gt; 0):\n    print('Número postivo')\nelse:\n    if(n &lt; 0):\n        print('Número negativo')\n    else:\n        print('Zero')",
    "crumbs": [
      "Introdução",
      "Exercícios"
    ]
  },
  {
    "objectID": "introducao/Exercicios.html#exercícios-complexos",
    "href": "introducao/Exercicios.html#exercícios-complexos",
    "title": "Exercícios",
    "section": "Exercícios complexos",
    "text": "Exercícios complexos\n\nExercício 1\nAproximação do número \\(e\\) usando a Série de Taylor\nO número \\(e\\) e é uma das constantes mais importantes da matemática, assim como \\(\\pi\\). Ele aparece naturalmente em várias áreas: crescimento populacional, juros compostos, probabilidade, estatística, equações diferenciais, física, computação e muito mais.\nSeu valor começa com:\n\\[\ne \\approx 2,718281828459 \\dots\n\\]\nUm fato interessante sobre \\(e\\) é que ele é um número irracional — isso significa que não pode ser expresso como uma fração exata e que sua expansão decimal não termina e não se repete. Por essa razão, o valor exato de \\(e\\) não pode ser escrito diretamente, mas pode ser calculado com aproximações cada vez melhores.\nUma forma clássica de aproximar \\(e\\) vem da série de Taylor da função \\(e^x\\). Quando avaliamos essa série no ponto \\(x = 1\\), obtemos:\n\\[\ne = \\sum_{n = 0}^{\\infty} \\frac{1}{n!}\n\\]\nQue corresponde à soma:\n\\[\ne = 1 + 1 + \\frac{1}{2!} + \\frac{1}{3!} + \\frac{1}{4!} + \\dots\n\\]\nEssa série é especialmente interessante porque converge rapidamente, e é simples de implementar computacionalmente.\nCom estas informações, sua tarefa é implementar um programa que calcule uma aproximação para o número \\(e\\) usando a série acima.\nSeu programa deve:\n\nPedir ao usuário um número inteiro \\(N\\), representando quantos termos da série devem ser somados.\nUsar uma estrutura de repetição (por exemplo: for ou while) para somar os termos até \\(N\\)\nCalcular o fatorial de cada \\(n\\) durante o processo.\nExibir a aproximação final de \\(e\\).\n\nExemplos de resultado:\n\nQuando o número de termos é 1, a soma é definida como:\n\\[\ne \\approx \\sum_{n = 0}^{0} \\frac{1}{n!}\n\\]\nE esta aproximação se da como:\n\\[\n\\sum_{n = 0}^{0} \\frac{1}{n!} = \\frac{1}{0!} = \\frac{1}{1} = 1\n\\]\nQuando o número de termos é 2, a soma é definida como:\n\\[\ne \\approx \\sum_{n = 0}^{1} \\frac{1}{n!}\n\\]\nE esta aproximação se da como:\n\\[\n\\sum_{n = 0}^{1} \\frac{1}{n!} = \\frac{1}{0!} + \\frac{1}{1!} = \\frac{1}{1} + \\frac{1}{1} = 1 + 1 = 2\n\\]\nQuando o número de termos é 3, a aproximação de \\(e\\) deve ser \\(2.5\\)\nQuando o número de termos é 4, a aproximação de \\(e\\) deve ser \\(2.6666666666666665\\)\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\n# declarar e aproximado como 0\ne_aprox: float = 0\n\n# ler o valor de n\nqtd_de_termos_da_aproximacao: int = int(input('Insira a quantidade de termos da aproximação: '))\n\n# estrutura de repetição que vai de 0 até n - 1\nfor n in range(0, qtd_de_termos_da_aproximacao):\n    # declarar n fatoria\n    n_fatorial: int = 1\n    \n    # calcular n fatorial\n    for i in range(n, 0, -1):\n        n_fatorial *= i\n\n    # somar o termo (1 / n!) à aproximação de e\n    e_aprox += (1 / n_fatorial)\n\n# exibir o resultado\nprint(e_aprox)",
    "crumbs": [
      "Introdução",
      "Exercícios"
    ]
  },
  {
    "objectID": "introducao/CondicionaisEmPython.html",
    "href": "introducao/CondicionaisEmPython.html",
    "title": "Condicionais em Python",
    "section": "",
    "text": "As condicionais são estruturas que permitem que um programa tome decisões com base em condições.\nElas controlam o fluxo do código, executando diferentes blocos dependendo de expressões booleanas (True ou False).\nEm Python, usamos principalmente: if, elif e else.",
    "crumbs": [
      "Introdução",
      "Condicionais em Python"
    ]
  },
  {
    "objectID": "introducao/CondicionaisEmPython.html#condicionais-em-python",
    "href": "introducao/CondicionaisEmPython.html#condicionais-em-python",
    "title": "Condicionais em Python",
    "section": "",
    "text": "As condicionais são estruturas que permitem que um programa tome decisões com base em condições.\nElas controlam o fluxo do código, executando diferentes blocos dependendo de expressões booleanas (True ou False).\nEm Python, usamos principalmente: if, elif e else.",
    "crumbs": [
      "Introdução",
      "Condicionais em Python"
    ]
  },
  {
    "objectID": "introducao/CondicionaisEmPython.html#if",
    "href": "introducao/CondicionaisEmPython.html#if",
    "title": "Condicionais em Python",
    "section": "1. if",
    "text": "1. if\nO if verifica uma condição e executa um bloco de código somente se a condição for verdadeira. Esta estrutura é equivalente à um bloco SE em pseudocódico e se assemelha a avaliar somente a seta verdadeira de um condicional em um fluxograma.\n\n\n\nPseudocódigo\nINÍCIO\n  idade ← 18\n  SE idade &gt;= 18 ENTÃO\n    ESCREVER \"Você é maior de idade.\"\n  FIM SE\nFIM\n\n\n\nPython\n\nidade = 18\n\nif idade &gt;= 18:\n    print(\"Você é maior de idade.\")\n\n\n\n\n\n\n\n\n\n\nNoteObservações Importantes\n\n\n\n\nO bloco dentro do if deve sempre ser indentado (4 espaços ou 1 tabulação).\nSe a condição for False, o Python ignora o bloco.\nA condição deve retornar True ou False.\n\nA função nativa de python print() é análoga ao “ESCREVER” do pseudocódigo, e exibe no terminal o que foi passado para ela.",
    "crumbs": [
      "Introdução",
      "Condicionais em Python"
    ]
  },
  {
    "objectID": "introducao/CondicionaisEmPython.html#else",
    "href": "introducao/CondicionaisEmPython.html#else",
    "title": "Condicionais em Python",
    "section": "2. else",
    "text": "2. else\nO else permite executar um bloco quando a condição do if não for verdadeira. O else é diretamente equivalente ao SENÃO encontrado no pseudocódigo.\n\n\n\nPseudocódigo\nINÍCIO\n  idade ← 16\n  SE idade &gt;= 18 ENTÃO\n    ESCREVER \"Você é maior de idade.\"\n  SENÃO\n    ESCREVER \"Você é menor de idade\"\n  FIM SE\nFIM\n\n\n\nPython\n\nidade = 16\n\nif idade &gt;= 18:\n    print(\"Você é maior de idade.\")\nelse:\n    print(\"Você é menor de idade.\")\n\n\n\n\n\n\n\n\n\n\nNoteObservações Importantes\n\n\n\n\nO bloco dentro do else deve sempre ser indentado (4 espaços ou 1 tabulação).\nA combinação simples de blocos do tipo if e else é ideal para casos onde há apenas duas possibilidades, pois a condição sempre cairá em alguma delas.",
    "crumbs": [
      "Introdução",
      "Condicionais em Python"
    ]
  },
  {
    "objectID": "introducao/CondicionaisEmPython.html#elsif-else-if",
    "href": "introducao/CondicionaisEmPython.html#elsif-else-if",
    "title": "Condicionais em Python",
    "section": "3. elsif (else if)",
    "text": "3. elsif (else if)\nO elif permite verificar múltiplas condições em sequência, sendo diretamente equvivalente ao bloco SE SENÃO no pseudocódigo.\n\n\n\nPseudocódigo\nINÍCIO\n  nota ← 85\n  SE nota &gt;= 90 ENTÃO\n    ESCREVER \"Excelente!\"\n  SENÃO SE nota &gt;= 70 ENTÃO\n    ESCREVER \"Bom desempenho.\"\n  SENÃO SE nota &gt;= 60 ENTÃO\n    ESCREVER \"Você passou, mas precisa melhorar.\"\n  SENÃO\n    ESCREVER \"Reprovado.\"\n  FIM SE\nFIM\n\n\n\nPython\n\nnota = 85\n\nif nota &gt;= 90:\n    print(\"Excelente!\")\nelif nota &gt;= 70:\n    print(\"Bom desempenho.\")\nelif nota &gt;= 60:\n    print(\"Você passou, mas precisa melhorar.\")\nelse:\n    print(\"Reprovado.\")\n\n\n\n\n\n\n\n\n\n\nNoteObservações Importantes\n\n\n\n\nO bloco dentro do elsif deve sempre ser indentado (4 espaços ou 1 tabulação).",
    "crumbs": [
      "Introdução",
      "Condicionais em Python"
    ]
  },
  {
    "objectID": "introducao/CondicionaisEmPython.html#operadores-lógicos-em-condicionais",
    "href": "introducao/CondicionaisEmPython.html#operadores-lógicos-em-condicionais",
    "title": "Condicionais em Python",
    "section": "Operadores lógicos em condicionais",
    "text": "Operadores lógicos em condicionais\nEm Python (assim como em diversas outras linguagens de programação), é muito comum precisarmos testar mais de uma condição ao mesmo tempo. Isso acontece porque, na prática, a execução de um algoritmo raramente depende de apenas um único caso simples. Em muitos programas, a decisão sobre o que fazer a seguir depende de várias situações sendo verdadeiras ou falsas ao mesmo tempo.\nPara realizar esse tipo de verificação, utilizamos os operadores lógicos, que são os “elos” responsáveis por conectar diferentes condições dentro de uma mesma estrutura de decisão — como o comando if. Esses operadores trabalham com valores booleanos, ou seja, com os dois estados lógicos possíveis:True(verdadeiro) eFalse(falso).\nDe forma geral, eles permitem que o programa combine ou compare resultados de expressões lógicas, possibilitando tomadas de decisão mais complexas.\n\nOperador and – Representa o operador lógico E.\nRetornaTrueapenas se todas as condições forem verdadeiras.\n\nExemplo:\n\nPythonPesudocódigo\n\n\n\nif idade &gt;= 18 and possui_carteira:\n    print(\"Pode dirigir.\")\n\n\n\nINÍCIO\n  SE idade &gt;= 18 E possui_carteira ENTÃO\n      ESCREVA \"Pode dirigir.\"\n  FIM SE\nFIM\n\n\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nNo código exibido acima, as variáveis idade e possui_carteira não foram declaras ou inicializadas, portanto, se você tentar executar este código, ele não irá funcionar. Entretanto, abaixo segue uma tabela com as possíveis saídas com base em alguns valores que estas variáveis podem ter.\n\n\nAqui estão as possíveis combinações que este código pode gerar:\n\n\n\n\n\n\n\n\n\nidade\npossui_carteira\nidade &gt;= 18 and possui_carteira\nsaída\n\n\n\n\n17\nFalse\nFalse and False -&gt; False\n(Nenhuma saída)\n\n\n17\nTrue\nFalse and True -&gt; False\n(Nenhuma saída)\n\n\n18\nFalse\nTrue and False -&gt; False\n(Nenhuma saída)\n\n\n18\nTrue\nTrue and True -&gt; True\n“Pode dirigir”\n\n\n\n\n\n\nor – Representa o operador lógico OU.\nRetornaTruese pelo menos uma das condições for verdadeira.\n\nExemplo:\n\nPythonPseudocódigo\n\n\n\nif temperatura &lt; 10 or chovendo:\n    print(\"Leve um casaco.\")\n\n\n\nINÍCIO\n  SE temperatura &lt; 10 OU chovendo ENTÃO\n      ESCREVA \"Leve um casaco.\"\n  FIM SE\nFIM\n\n\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nNo código exibido acima, as variáveis temperatura, e chovendo não foram declaras ou inicializadas, portanto, se você tentar executar este código, ele não irá funcionar. Entretanto, abaixo segue uma tabela com as possíveis saídas com base em alguns valores que estas variáveis podem ter.\n\n\nAqui estão as possíveis combinações deste código:\n\n\n\n\n\n\n\n\n\ntemperatura\nchovendo\ntemperatura &lt; 10 or chovendo\nsaída\n\n\n\n\n11\nFalse\nFalse or False -&gt; False\n(Nenhuma saída)\n\n\n11\nTrue\nFalse or True -&gt; True\n“Leve um casaco.”\n\n\n9\nFalse\nTrue or False -&gt; True\n“Leve um casaco.”\n\n\n9\nTrue\nTrue or True -&gt; True\n“Leve um casaco.”\n\n\n\n\n\n\nOperador not – Representa o operador lógico NÃO.\nInverte o valor lógico de uma expressão, transformandoTrueemFalsee vice-versa.\n\nExemplo:\n\nPythonPseudocódigo\n\n\n\nif not conectado:\n    print(\"Sem conexão com a internet.\")\n\n\n\nINÍCIO\n  SE NÃO conectado ENTÃO\n      ESCREVA \"Sem conexão com a internet.\"\n  FIM SE\nFIM\n\n\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nNo código exibido acima, a variável conectado não foi declaras ou inicializadas, portanto, se você tentar executar este código, ele não irá funcionar. Entretanto, abaixo segue uma tabela com as possíveis saídas com base em alguns valores que estas variáveis podem ter.\n\n\nAqui estão todas as possíveis combinações do código acima\n\n\n\nconectado\nnot conectado\nsaída\n\n\n\n\nFalse\nTrue\n“Sem conexão com a internet.”\n\n\nTrue\nFalse\n(Nehuma saída)\n\n\n\n\n\n\nCondição composta\nUma condição pode ser composta pela combinação de vários operadores lógicos diferentes.\n\nPythonPseudocódigo\n\n\n\nif((idade &gt;= 18 or tem_permissao_dos_pais) and tem_ingresso):\n    print('Pode entrar no evento')\nelse:\n    print('Acesso Negado')\n\n\n\nINÍCIO\n  SE (idade &gt;= 18 OU tem_permissao_dos_pais) E tem_ingresso ENTÃO\n      ESCREVA \"Pode entrar no evento\"\n  SENÃO\n      ESCREVA \"Acesso Negado\"\n  FIM SE\nFIM\n\n\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nNo código exibido acima, as variáveis idade, tem_permissao_dos_pais e tem_ingresso não foram declaras ou inicializadas, portanto, se você tentar executar este código, ele não irá funcionar. Entretanto, abaixo segue uma tabela com as possíveis saídas com base em alguns valores que estas variáveis podem ter.\n\n\nAqui seguem os possíveis valores e saídas do código acima:\n\n\n\n\n\n\n\n\n\n\n\n\n\nidade\nidade ≥ 18\ntem_permissao_dos_pais\ntem_ingresso\n(idade ≥ 18 or tem_permissao_dos_pais)\nCondição final ( (idade ≥ 18 or tem_permissao_dos_pais) and tem_ingresso)\nSaída\n\n\n\n\n17\nFalse\nFalse\nFalse\nFalse\nFalse\nAcesso Negado\n\n\n17\nFalse\nFalse\nTrue\nFalse\nFalse\nAcesso Negado\n\n\n17\nFalse\nTrue\nFalse\nTrue\nFalse\nAcesso Negado\n\n\n17\nFalse\nTrue\nTrue\nTrue\nTrue\nPode entrar no evento\n\n\n19\nTrue\nFalse\nFalse\nTrue\nFalse\nAcesso Negado\n\n\n19\nTrue\nFalse\nTrue\nTrue\nTrue\nPode entrar no evento\n\n\n19\nTrue\nTrue\nFalse\nTrue\nFalse\nAcesso Negado\n\n\n19\nTrue\nTrue\nTrue\nTrue\nTrue\nPode entrar no evento",
    "crumbs": [
      "Introdução",
      "Condicionais em Python"
    ]
  },
  {
    "objectID": "introducao/CondicionaisEmPython.html#exercícios",
    "href": "introducao/CondicionaisEmPython.html#exercícios",
    "title": "Condicionais em Python",
    "section": "Exercícios",
    "text": "Exercícios\n\nExercício 1\nCrie um programa que pergunte a idade do usuário (um número inteiro) e escreva no terminal “Maior de idade” caso a idade seja maior ou igual a 18 anos e “Menor de idade” caso contrário.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAqui segue a solução do problema e o seu pseudocódigo para facilitar o entendimento.\n\nSolução (Python)Pseudocódigo\n\n\n\nidade = int(input('Insira a sua idade: '))\n\nif(idade &gt;= 18):\n    print('Maior de idade')\nelse:\n    print('Menor de idade')\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n  ESCREVA \"Insira a sua idade: \"\n  LEIA idade\n\n  SE idade &gt;= 18 ENTÃO\n      ESCREVA \"Maior de idade\"\n  SENÃO\n      ESCREVA \"Menor de idade\"\n  FIM SE\nFIM\n\n\n\n\n\n\n\n\nExercício 2\nPeça ao usuário um número inteiro e exiba “Número positivo” se for maior que zero.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAqui segue a solução do problema e o seu pseudocódigo para facilitar o entendimento.\n\nSolução (Python)Pseudocódigo\n\n\n\nnumero = int(input('Insira um número inteiro: '))\n\nif(numero &gt; 0):\n    print('Número maior que 0')\nelse:\n    print('Número menor que 0')\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n  ESCREVA \"Insira um número inteiro: \"\n  LEIA numero\n\n  SE numero &gt; 0 ENTÃO\n      ESCREVA \"Número maior que 0\"\n  SENÃO\n      ESCREVA \"Número menor que 0\"\n  FIM SE\nFIM\n\n\n\n\n\n\n\n\nExercício 3\nFaça um programa que pergunte a temperatura (um número que pode conter casas decimais) e exiba “Está calor!” se for maior que 30 °C e não faça nada caso contrário.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAqui segue a solução do problema e o seu pseudocódigo para facilitar o entendimento.\n\nSolução (Python)Pseudocódigo\n\n\n\ntemperatura = float(input('Insira a temperatura: '))\n\nif(temperatura &gt; 30):\n    print('Está calor!')\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n  ESCREVA \"Insira a temperatura: \"\n  LEIA temperatura\n\n  SE temperatura &gt; 30 ENTÃO\n      ESCREVA \"Está calor!\"\n  FIM SE\nFIM\n\n\n\n\n\n\n\n\nExercício 4\nCrie um programa que peça ao usuário um nome de usuário e uma senha. Se o nome for “admin” e a senha “1234”, exiba “Acesso permitido”. Caso contrário, exiba “Acesso negado”.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAqui segue a solução do problema e o seu pseudocódigo para facilitar o entendimento.\n\nSolução (Python)Pseudocódigo\n\n\n\nnome_de_usuario = input('Insira o nome de usuário: ')\nsenha = input('Insira a senha: ')\n\nif((nome_de_usuario == 'admin') and (senha == '1234')):\n    print('Acesso permitido')\nelse:\n    print('Acesso negado')\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n  ESCREVA \"Insira o nome de usuário: \"\n  LEIA nome_de_usuario\n\n  ESCREVA \"Insira a senha: \"\n  LEIA senha\n\n  SE (nome_de_usuario == \"admin\") E (senha == \"1234\") ENTÃO\n      ESCREVA \"Acesso perimitido\"\n  SENÃO\n      ESCREVA \"Acesso negado\"\n  FIM SE\nFIM\n\n\n\n\n\n\n\n\nExercício 5\nCrie uma lista de frutas com os seguintes valores: [“maçã”, “banana”, “laranja”, “uva”]. Pergunte ao usuário o nome de uma fruta.\n\nSe a fruta estiver na lista, exiba “Fruta disponível”.\nCaso contrário, exiba “Fruta indisponível”.\n\n\n\n\n\n\n\nNoteDica\n\n\n\nLembre-se do operador in para listas!\n\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAqui segue a solução do problema e o seu pseudocódigo para facilitar o entendimento.\n\nSolução (Python)Pseudocódigo\n\n\n\nlista_de_frutas: list = [\"maçã\", \"banana\", \"laranja\", \"uva\"]\n\nfruta = input('Insira o nome de uma fruta: ')\n\nif(fruta in lista_de_frutas):\n    print('Fruta disponível')\nelse:\n    print('Fruta indisponível')\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nEste código também pode ser implementado utilizando uma estrutura de repetição. Tente imageinar como isto seria feito (o fluxograma/pseudocódigo de tal estrutura).\n\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n    lista_de_frutas ← [\"maçã\", \"banana\", \"laranja\", \"uva\"]\n\n    ESCREVA: \"Insira o nome de uma fruta:\"\n    LEIA fruta\n\n    SE fruta ESTÁ EM lista_de_frutas ENTÃO\n        ESCREVA \"Fruta disponível\"\n    SENÃO\n        ESCREVA \"Fruta indisponível\"\n    FIM SE\nFIM\n\n\n\n\n\n\n\n\nExercício 6\nUtilizando o seguinte dicionário que relaciona alunos com suas notas:\n\nnotas = {\"Ana\": 9, \"Bruno\": 7, \"Carla\": 6} \n\nImplemente um algoritmo que faça o seguinte:\n\nPergunte ao usuário o nome de um aluno.\nExiba a nota do aluno se existir no dicionário; caso contrário, exiba “Aluno não encontrado”.\n\n\n\n\n\n\n\nNoteDica\n\n\n\nLembre-se do operador in para dicionários!\n\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAqui segue a solução do problema e o seu pseudocódigo para facilitar o entendimento.\n\nSolução (Python)Pseudocódigo\n\n\n\nnotas = {\"Ana\": 9, \"Bruno\": 7, \"Carla\": 6}\n\naluno = input('Insira o nome de um aluno: ')\n\nif(aluno in notas):\n    print(notas[aluno])\nelse:\n    print('Aluno não encontrado')\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nEste código também pode ser implementado utilizando uma estrutura de repetição. Tente imageinar como isto seria feito (o fluxograma/pseudocódigo de tal estrutura).\n\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n    notas ← {\"Ana\": 9, \"Bruno\": 7, \"Carla\": 6}\n\n    ESCREVER \"Insira o nome de um aluno:\"\n    LER aluno\n\n    SE aluno ESTÁ EM notas ENTÃO\n        ESCREVER notas[aluno]\n    SENÃO\n        ESCREVER \"Aluno não encontrado\"\n    FIM SE\nFIM",
    "crumbs": [
      "Introdução",
      "Condicionais em Python"
    ]
  },
  {
    "objectID": "introducao/Algoritmos.html",
    "href": "introducao/Algoritmos.html",
    "title": "Algorítmos",
    "section": "",
    "text": "Um algoritmo é um conjunto de instruções organizadas de maneira lógica e finita, criado para resolver um problema ou executar uma tarefa específica. Em termos simples, pode-se compará-lo a uma receita de cozinha: ele indica passo a passo o que deve ser feito, em que ordem e com quais dados, garantindo que qualquer pessoa ou sistema que siga essas instruções possa chegar ao resultado esperado. Cada passo tem um propósito claro, e a sequência completa define o caminho do início até a conclusão da tarefa.\nNa matemática, na ciência da computação e em diversas áreas da engenharia, os algoritmos são essenciais porque permitem que problemas sejam resolvidos de forma estruturada, eficiente e sem ambiguidades. Eles são capazes de lidar com situações simples, como somar dois números, até processos extremamente complexos, como organizar rotas de transporte, processar grandes volumes de dados, treinar modelos de inteligência artificial ou simular fenômenos naturais de alta complexidade.\nAlém de simplesmente seguir uma sequência de passos, um algoritmo geralmente trabalha com entradas e saídas. As entradas correspondem aos dados ou informações que o algoritmo recebe para processar, enquanto as saídas representam os resultados ou respostas produzidos ao final do processamento. Isso significa que, para funcionar corretamente, um algoritmo depende de informações de entrada confiáveis e gera resultados que podem ser utilizados por pessoas, outros sistemas ou processos automatizados. Em muitas situações, a mesma lógica pode produzir diferentes saídas dependendo dos dados fornecidos, demonstrando a flexibilidade e a importância do conceito de entradas e saídas no design de algoritmos.\nDessa forma, entender como projetar algoritmos claros, organizados e capazes de lidar adequadamente com entradas e saídas é fundamental para qualquer pessoa que trabalhe com resolução de problemas, programação ou análise de processos complexos, tornando o pensamento lógico uma habilidade central no desenvolvimento de soluções eficientes e confiáveis.\n\n\nUm algoritmo precisa obedecer a algumas regras essenciais para ser considerado válido:\n\nFinitude: o algoritmo deve terminar em algum momento. Isso significa que ele não pode entrar em um ciclo infinito de instruções — deve sempre chegar a um resultado ou a uma conclusão.\nPrecisão: cada etapa do algoritmo deve ser clara e bem definida. Não pode haver dúvidas sobre o que fazer em cada passo.\nEfetividade: as instruções devem ser simples e executáveis. Cada ação deve ser possível de ser realizada dentro de um tempo finito, usando os recursos disponíveis (computador, pessoa, máquina, etc.).\n\nEssas três propriedades garantem que o algoritmo seja entendível, funcional e confiável.\n\n\n\nUm exemplo clássico para entender o conceito é uma receita de bolo. Pense: para assar um bolo, você segue um conjunto de instruções como:\n\nMisture os ingredientes secos.\nAdicione os ovos e o leite.\nBata até formar uma massa homogênea.\nColoque em uma forma untada.\nLeve ao forno por 40 minutos.\n\nCada um desses passos é bem definido e precisa ser executado em ordem. Se você mudar a sequência ou omitir um passo, o resultado provavelmente será diferente do esperado. O mesmo acontece com os algoritmos — eles precisam de passos bem organizados e corretos para chegar ao resultado desejado.\n\n\n\nNem todos os algoritmos que resolvem o mesmo problema são igualmente bons. Dois algoritmos diferentes podem chegar à mesma resposta, mas um deles pode ser muito mais rápido ou usar menos memória do que o outro. Essa diferença é o que chamamos de eficiência.\nA eficiência de um algoritmo é estudada através da complexidade computacional, que mede o tempo e os recursos necessários para executá-lo. Por exemplo, há algoritmos de busca que examinam cada item de uma lista um por um, e outros que encontram o resultado em frações de tempo usando estruturas de dados mais adequadas.",
    "crumbs": [
      "Introdução",
      "Algorítmos"
    ]
  },
  {
    "objectID": "introducao/Algoritmos.html#o-que-é-um-algoritmo",
    "href": "introducao/Algoritmos.html#o-que-é-um-algoritmo",
    "title": "Algorítmos",
    "section": "",
    "text": "Um algoritmo é um conjunto de instruções organizadas de maneira lógica e finita, criado para resolver um problema ou executar uma tarefa específica. Em termos simples, pode-se compará-lo a uma receita de cozinha: ele indica passo a passo o que deve ser feito, em que ordem e com quais dados, garantindo que qualquer pessoa ou sistema que siga essas instruções possa chegar ao resultado esperado. Cada passo tem um propósito claro, e a sequência completa define o caminho do início até a conclusão da tarefa.\nNa matemática, na ciência da computação e em diversas áreas da engenharia, os algoritmos são essenciais porque permitem que problemas sejam resolvidos de forma estruturada, eficiente e sem ambiguidades. Eles são capazes de lidar com situações simples, como somar dois números, até processos extremamente complexos, como organizar rotas de transporte, processar grandes volumes de dados, treinar modelos de inteligência artificial ou simular fenômenos naturais de alta complexidade.\nAlém de simplesmente seguir uma sequência de passos, um algoritmo geralmente trabalha com entradas e saídas. As entradas correspondem aos dados ou informações que o algoritmo recebe para processar, enquanto as saídas representam os resultados ou respostas produzidos ao final do processamento. Isso significa que, para funcionar corretamente, um algoritmo depende de informações de entrada confiáveis e gera resultados que podem ser utilizados por pessoas, outros sistemas ou processos automatizados. Em muitas situações, a mesma lógica pode produzir diferentes saídas dependendo dos dados fornecidos, demonstrando a flexibilidade e a importância do conceito de entradas e saídas no design de algoritmos.\nDessa forma, entender como projetar algoritmos claros, organizados e capazes de lidar adequadamente com entradas e saídas é fundamental para qualquer pessoa que trabalhe com resolução de problemas, programação ou análise de processos complexos, tornando o pensamento lógico uma habilidade central no desenvolvimento de soluções eficientes e confiáveis.\n\n\nUm algoritmo precisa obedecer a algumas regras essenciais para ser considerado válido:\n\nFinitude: o algoritmo deve terminar em algum momento. Isso significa que ele não pode entrar em um ciclo infinito de instruções — deve sempre chegar a um resultado ou a uma conclusão.\nPrecisão: cada etapa do algoritmo deve ser clara e bem definida. Não pode haver dúvidas sobre o que fazer em cada passo.\nEfetividade: as instruções devem ser simples e executáveis. Cada ação deve ser possível de ser realizada dentro de um tempo finito, usando os recursos disponíveis (computador, pessoa, máquina, etc.).\n\nEssas três propriedades garantem que o algoritmo seja entendível, funcional e confiável.\n\n\n\nUm exemplo clássico para entender o conceito é uma receita de bolo. Pense: para assar um bolo, você segue um conjunto de instruções como:\n\nMisture os ingredientes secos.\nAdicione os ovos e o leite.\nBata até formar uma massa homogênea.\nColoque em uma forma untada.\nLeve ao forno por 40 minutos.\n\nCada um desses passos é bem definido e precisa ser executado em ordem. Se você mudar a sequência ou omitir um passo, o resultado provavelmente será diferente do esperado. O mesmo acontece com os algoritmos — eles precisam de passos bem organizados e corretos para chegar ao resultado desejado.\n\n\n\nNem todos os algoritmos que resolvem o mesmo problema são igualmente bons. Dois algoritmos diferentes podem chegar à mesma resposta, mas um deles pode ser muito mais rápido ou usar menos memória do que o outro. Essa diferença é o que chamamos de eficiência.\nA eficiência de um algoritmo é estudada através da complexidade computacional, que mede o tempo e os recursos necessários para executá-lo. Por exemplo, há algoritmos de busca que examinam cada item de uma lista um por um, e outros que encontram o resultado em frações de tempo usando estruturas de dados mais adequadas.",
    "crumbs": [
      "Introdução",
      "Algorítmos"
    ]
  },
  {
    "objectID": "introducao/Algoritmos.html#algoritmos-condicionais",
    "href": "introducao/Algoritmos.html#algoritmos-condicionais",
    "title": "Algorítmos",
    "section": "Algoritmos condicionais",
    "text": "Algoritmos condicionais\nNem todos os algoritmos seguem uma sequência de passos fixa. Em muitas situações, é necessário tomar decisões durante a execução de um processo. Para isso, utilizam-se as estruturas condicionais, que permitem ao algoritmo escolher caminhos diferentes dependendo das condições apresentadas.\nEm termos simples, uma condicional é uma instrução que faz o algoritmo verificar uma situação — por exemplo, comparar valores, verificar um estado ou analisar uma escolha — e, com base nesse resultado, decidir o que fazer em seguida.\nEssas decisões tornam os algoritmos muito mais inteligentes e flexíveis, pois permitem que eles se adaptem a diferentes contextos ou dados de entrada.\n\nO que é uma condição?\nUma condição é uma expressão lógica que pode resultar apenas em dois valores possíveis: verdadeiro (True) ou falso (False). O algoritmo avalia essa condição e, dependendo do resultado, executa um determinado conjunto de instruções.\nPor exemplo:\n\n“Se a temperatura for maior que 30 graus, ligar o ventilador.”\n“Se o usuário digitar a senha correta, permitir o acesso.”\n“Se o saldo for menor que zero, mostrar mensagem de saldo insuficiente.”\n\nEssas decisões baseiam-se sempre em testes lógicos — comparações e verificações que determinam qual caminho o algoritmo seguirá.\n\n\nEstrutura básica de uma decisão\nA estrutura lógica de um algoritmo condicional pode ser descrita da seguinte forma:\nSe (condição for verdadeira):\n    execute a ação A\nSenão:\n    execute a ação B\nEm outras palavras:\n\nSe algo for verdade, faça isso; caso contrário, faça aquilo.\n\nEsse tipo de estrutura é fundamental para qualquer programa, pois quase todas as aplicações precisam lidar com situações alternativas ou respostas diferentes de acordo com os dados fornecidos.\n\n\nEncadeamento de condições\nAlgumas vezes, é necessário verificar mais de uma possibilidade. Nesses casos, o algoritmo pode encadear várias condições, avaliando uma de cada vez até encontrar a que corresponde à situação atual.\nPor exemplo, em um algoritmo que determina o desempenho de um aluno:\n\nLeia a nota final.\nSe a nota for maior ou igual a 9, exiba “Excelente.”\nSenão, se a nota for maior ou igual a 7, exiba “Bom.”\nSenão, se a nota for maior ou igual a 5, exiba “Regular.”\nCaso contrário, exiba “Reprovado.”\n\nEsse tipo de encadeamento permite que o algoritmo classifique diferentes situações e produza resultados variados com base nas condições fornecidas.",
    "crumbs": [
      "Introdução",
      "Algorítmos"
    ]
  },
  {
    "objectID": "introducao/Algoritmos.html#importância-dos-operadores-lógicos-e-de-comparação",
    "href": "introducao/Algoritmos.html#importância-dos-operadores-lógicos-e-de-comparação",
    "title": "Algorítmos",
    "section": "Importância dos operadores lógicos e de comparação",
    "text": "Importância dos operadores lógicos e de comparação\nPara formular condições, os algoritmos utilizam operadores de comparação, como:\n\n“==” (igual a)\n“!=” (diferente de)\n“&gt;” (maior que)\n“&lt;” (menor que)\n“&gt;=” (maior ou igual a)\n“&lt;=” (menor ou igual a)\n\nAlém disso, também podem ser usados operadores lógicos, que combinam várias condições:\n\nand (e lógico) — todas as condições precisam ser verdadeiras.\nor (ou lógico) — basta que uma condição seja verdadeira.\nnot (não lógico) — inverte o valor lógico de uma condição.\n\nEsses operadores permitem criar decisões complexas e precisas, aumentando a capacidade do algoritmo de reagir a diferentes situações.",
    "crumbs": [
      "Introdução",
      "Algorítmos"
    ]
  },
  {
    "objectID": "introducao/Algoritmos.html#algoritmos-com-estruturas-de-repetição-simples",
    "href": "introducao/Algoritmos.html#algoritmos-com-estruturas-de-repetição-simples",
    "title": "Algorítmos",
    "section": "Algoritmos com estruturas de repetição simples",
    "text": "Algoritmos com estruturas de repetição simples\n\nO que é uma estutura de repetição?\nUma estrutura de repetição é um mecanismo que permite executar um conjunto de instruções diversas vezes de forma controlada. Cada repetição é chamada de iteração, e o processo continua até que uma condição específica indique que a repetição deve parar.\nEm termos conceituais, podemos imaginar uma estrutura de repetição como um ciclo que se mantém ativo enquanto algo for verdadeiro ou enquanto houver trabalho a ser feito. Esse ciclo garante que o algoritmo repita ações de forma organizada e previsível, economizando esforço e evitando redundâncias. Ao invés de escrever várias vezes a mesma instrução, podemos usar a repetição para executar a mesma ação diversas vezes de forma automática, clara e eficiente.\nÉ importante entender que, mesmo sendo uma estrutura específica, a repetição é um tipo de algoritmo. Isso significa que ela possui as mesmas características essenciais de um algoritmo: passos bem definidos, execução ordenada, capacidade de processar dados e de chegar a um resultado, e uma condição de término. A diferença é que, enquanto um algoritmo tradicional descreve uma sequência linear de ações, a estrutura de repetição permite que certas instruções sejam executadas múltiplas vezes de maneira controlada, dependendo de uma condição ou de um número determinado de repetições.\nAlém disso, uma estrutura de repetição não existe isoladamente: ela é frequentemente uma parte de outros algoritmos maiores. Em muitos casos, um algoritmo complexo é formado por diversas estruturas de repetição combinadas com decisões condicionais e operações sequenciais. Por exemplo, um algoritmo de processamento de dados pode conter uma repetição para ler cada registro de uma lista e, dentro dessa repetição, uma segunda repetição para analisar os elementos de cada registro individualmente. Dessa forma, cada repetição funciona como um bloco de construção dentro de um algoritmo maior, contribuindo para a execução do processo completo.\nEssa característica torna as estruturas de repetição extremamente poderosas e flexíveis: elas permitem que algoritmos se adaptem a diferentes quantidades de dados, respondam a condições variáveis e evitem a repetição manual de instruções, mantendo o código organizado e eficiente. Podemos pensar nelas como “pequenos algoritmos dentro de um grande algoritmo”, que funcionam de forma autônoma, mas sempre integrados ao processo maior, colaborando para que o objetivo final seja alcançado.\nEm resumo, uma estrutura de repetição é ao mesmo tempo um algoritmo completo, com começo, meio e fim, e uma parte de outros algoritmos, ajudando a organizar e automatizar tarefas repetitivas de forma controlada e eficiente. Compreender esse conceito é fundamental para entender como os algoritmos modernos funcionam e como processos complexos podem ser resolvidos de forma estruturada e lógica.\n\n\nPara que servem as esturturas de repetição?\nAs estruturas de repetição são essenciais para:\n\nAutomatizar tarefas repetitivas: quando a mesma ação precisa ser executada várias vezes, como verificar todos os itens de uma lista, calcular totais ou processar registros.\nControlar processos até que um objetivo seja alcançado: por exemplo, repetir um passo até que uma solução seja encontrada ou um resultado esperado seja atingido.\nReduzir a redundância: evita escrever múltiplas vezes o mesmo conjunto de instruções, tornando o algoritmo mais compacto, legível e fácil de manter.\nPermitir interação dinâmica: em situações onde o número de repetições depende de dados fornecidos durante a execução do algoritmo ou de condições externas que mudam com o tempo.\nGarantir eficiência: com a repetição, o algoritmo consegue processar grandes volumes de dados sem precisar duplicar instruções, aumentando sua escalabilidade.\n\n\n\nFuncionamento de estruturas de repetição\nO funcionamento básico de uma repetição pode ser descrito em três etapas conceituais:\n\nVerificação de condição: antes ou depois de cada ciclo, o algoritmo verifica se a condição para continuar a repetição ainda é verdadeira (tornando a esturtura de repetição uma espécie de algoritmo condicional).\nExecução do bloco de instruções: enquanto a condição for verdadeira, o algoritmo realiza todas as ações previstas no ciclo. Cada execução é chamada de iteração.\nEncerramento da repetição: quando a condição se torna falsa, o ciclo termina e o algoritmo segue para as instruções seguintes.\n\nDessa forma, a repetição garante que o algoritmo repita apenas o necessário e pare no momento certo, evitando loops infinitos e garantindo eficiência.\n\n\nTipos de repetição\nExistem diferentes formas de estruturar a repetição em algoritmos, dependendo da necessidade do problema que se deseja resolver. Cada tipo de repetição é mais adequado a uma situação específica e tem suas próprias características de funcionamento. Vamos detalhar as duas estruturas que são mais utilizadas na prática.\n\nRepetição controlada por condição\nEm estruturas de repetição controladas por uma condição, o ciclo continua enquanto uma condição lógica permanecer verdadeira Normalmente esta ideia corresponde ao que na programação é chamado de loop do tipo “while” ou repetição condicional. Para realização desta estrutura, um algoritmo verifica uma condição antes ou durante cada iteração. Enquanto essa condição for verdadeira, o bloco de instruções será repetido. Assim que a condição deixa de ser verdadeira, a repetição é interrompida.\nQuando usar: este tipo de repetição é ideal quando não se sabe exatamente quantas vezes será necessário repetir, mas existe uma regra clara que determina a continuidade (ou determina o caso de parada).\nExemplos de uso real:\n\nAguardar até que um sensor indique que uma tarefa foi concluída.\nProcessar dados de um fluxo até que não haja mais informações disponíveis.\nContinuar realizando verificações em um sistema até que uma condição de segurança seja satisfeita.\n\n\n\n\n\n\n\nTipDica didática\n\n\n\nPense nessa repetição como uma situação do dia a dia em que você continua fazendo algo “enquanto for necessário”. Por exemplo: “continue estudando enquanto não entender o conceito completamente”.\n\n\n\n\nRepetição controlada por contagem\nEm estruturas de repetição controladas por contagem, o ciclo é repetido um número pré-determinado de vezes. Este tipo de repetição corresponde ao que na programação é normalmente chamado de loop do tipo “for” ou repetição por contagem. Para o funcionamento desta estrutura, o algoritmo define antecipadamente quantas vezes o bloco de instruções deve ser executado. Cada repetição é contada até que o número estipulado seja atingido, momento em que a repetição termina automaticamente.\nQuando usar: este tipo de repetição é útil quando o número de repetições é conhecido de antemão e não depende de condições externas.\nExemplos de uso real:\n\nCalcular a média de cinco notas (ou a média de n notas, pois quando o código for rodado, o número n será conhecido).\nPercorrer todos os itens de uma lista de registros conhecida.\nRepetir um teste ou procedimento um número fixo de vezes.\n\n\n\n\n\n\n\nTipDica didática\n\n\n\nimagine como um cronômetro que conta até um número definido: você sabe exatamente quantas vezes precisa repetir a ação, e o ciclo termina assim que esse número é alcançado.\n\n\n\n\n\nExemplo visual\nAbaixo está um gif de como um índice percorre uma lista utilizando uma estrutura de repetição controlada por contagem. Neste caso, estamos percorrendo uma lista com 10 elementos, um por um, ou seja, utilizamos uma estrutura de repetição controlada por contagem, onde o número de repetições é 10.\n\n\nClique para ver a animação\n\n\n\n\n\n\n\n\n\nCautionObservação\n\n\n\nGeralmente na programação, os índices de acesso à listas não iniciam em 1, mas sim em 0. Isto será abordado postriormente, mas é importante destacar que o que está sendo mostrado neste gif não é usual.",
    "crumbs": [
      "Introdução",
      "Algorítmos"
    ]
  },
  {
    "objectID": "introducao/Algoritmos.html#algoritmos-com-estruturas-de-repetição-encadeadas",
    "href": "introducao/Algoritmos.html#algoritmos-com-estruturas-de-repetição-encadeadas",
    "title": "Algorítmos",
    "section": "Algoritmos com estruturas de repetição encadeadas",
    "text": "Algoritmos com estruturas de repetição encadeadas\nNem sempre uma única estrutura de repetição é suficiente para resolver um problema. Em muitos algoritmos, é necessário repetir um conjunto de ações dentro de outro ciclo de repetições, criando o que chamamos de estruturas de repetição alinhadas (ou repetições encadeadas, também conhecidas como loops aninhados).\nEssas estruturas permitem que um algoritmo execute várias camadas de repetições, controlando diferentes níveis de iteração. Em outras palavras, uma repetição é executada inteiramente a cada vez que a repetição externa realiza uma iteração. Isso cria um comportamento em que o algoritmo percorre combinações de valores ou estruturas mais complexas, como matrizes, listas duplas e conjuntos de dados multidimensionais.\n\nComo funcionam as estruturas de repetição alinhadas\nO princípio básico é simples:\n\nO algoritmo inicia o primeiro ciclo (o externo).\nDentro dele, inicia outro ciclo (o interno) que realiza suas repetições completas.\nQuando o ciclo interno termina, o controle retorna ao ciclo externo, que avança para a próxima iteração.\nEsse processo se repete até que ambas as condições de parada — a do ciclo interno e a do ciclo externo — sejam satisfeitas.\n\nAssim, as repetições funcionam como “camadas” organizadas, em que cada nível depende do anterior. O número total de repetições realizadas é o produto das iterações de cada estrutura envolvida. Por exemplo, se a repetição externa ocorre 3 vezes e a interna 2 vezes, o algoritmo executará o bloco interno 6 vezes ao todo.\n\n\nQuando utilizar repetições alinhadas\nEsse tipo de estrutura é usado quando o problema envolve duas ou mais dimensões de repetição, como:\n\nPercorrer uma tabela (linhas e colunas).\nComparar todos os elementos de uma lista com todos os elementos de outra lista.\nExecutar um conjunto de testes para cada variável de entrada.\nCriar combinações possíveis entre dois ou mais conjuntos de dados.\n\nEm resumo, as repetições alinhadas são indispensáveis quando o algoritmo precisa lidar com relações entre conjuntos de informações ou operações cruzadas entre dados.\n\n\nExemplo visual\nAbaixo está um gif de como um índice percorre duas listas, utilizando um sistema de encadeamento de estruturas de repetição. Para percorrer esta “tabela” com 5 linhas e 4 colunas, percorremos linha a linha, ou seja, um índice externo está fixo enquanto o outro é percorrido completamente até que o índice externo é incrementado.\n\n\nClique para ver a animação\n\n\n\n\n\n\n\n\n\nCautionObservação\n\n\n\nGeralmente na programação, os índices de acesso à listas não iniciam em 1, mas sim em 0. Isto será abordado postriormente, mas é importante destacar que o que está sendo mostrado neste gif não é usual.",
    "crumbs": [
      "Introdução",
      "Algorítmos"
    ]
  },
  {
    "objectID": "introducao/Algoritmos.html#algoritmos-na-computação",
    "href": "introducao/Algoritmos.html#algoritmos-na-computação",
    "title": "Algorítmos",
    "section": "Algoritmos na computação",
    "text": "Algoritmos na computação\nNos computadores, os algoritmos são a base de todos os programas e sistemas. Quando você abre um aplicativo, faz uma busca na internet, assiste a um vídeo ou joga um jogo, há algoritmos trabalhando em segundo plano — organizando dados, processando informações e tomando decisões automaticamente.\nPor exemplo:\n\nUm algoritmo de busca no Google analisa milhões de páginas e encontra a mais relevante para sua pesquisa.\nUm algoritmo de redes sociais decide quais postagens aparecem primeiro no seu feed.\nUm algoritmo de GPS calcula a rota mais rápida para o seu destino.\n\nEsses algoritmos seguem regras precisas, usam dados de entrada (como o texto digitado ou sua localização) e produzem saídas (como resultados, imagens, recomendações ou trajetos).",
    "crumbs": [
      "Introdução",
      "Algorítmos"
    ]
  },
  {
    "objectID": "introducao/Algoritmos.html#exercícios",
    "href": "introducao/Algoritmos.html#exercícios",
    "title": "Algorítmos",
    "section": "Exercícios",
    "text": "Exercícios\n\nExercício 1\nExplique com suas próprias palavras o que é um algoritmo. Dê um exemplo do seu cotidiano que não envolva computadores.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nUm algoritmo é um conjunto de instruções organizadas em uma sequência lógica e finita, criado para resolver um problema ou executar uma tarefa específica.\n\n\n\n\n\nExercício 2\nDê um exemplo de algoritmo que não tenha relação com programação\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nReceitas da culinária.\nSeguir uma rotina planejada\nHigiene do sono.\n\n\n\n\n\n\nExercício 3\nCite as três características principais de um algoritmo e explique por que cada uma delas é importante.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nFinitude, importante para que o algoritmo termine em algum momento do tempo.\nPrecisão, importante para que as etapas não possuam um duplo sentido.\nEfetividade, importante para que um algoritmo não seja custoso demais (em termos de memória, tempo e/ou processamento, pois todo são recursos finitos).\n\n\n\n\n\n\nExercício 4\nDescreva, como passos enumerados, um algorítmo que seja capaz de categorizar um número como negativo ou positivo\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nExistem duas maneiras principais de implementar este algoritmo, variando com a escolha de condicional a se utilizar: checar se o número é maior ou igual a 0 ou checar se o número é menor ou igual a 0.\n\ncaso 1caso 2\n\n\n\nIníciar o algoritmo.\nLer o número.\nPerguntar se o número é maior ou igual a 0 (número &gt;= 0).\nCaso seja, o número é positivo, caso contrário negativo.\nExibir resultados\nTerminar execução.\n\n\n\n\nIníciar o algoritmo.\nLer o número.\nPerguntar se o número é menor ou igual a 0 (número &lt;= 0).\nCaso seja, o número é negativo, caso contrário positivo.\nExibir resultados\nTerminar execução.\n\n\n\n\n\n\n\n\n\nExercício 5\nExplique com suas palavras para que servem as estruturas de repetição. Dê um exemplo que não seja relacionado a programação.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nEstruturas de repetição são mecanismo que permite executar um conjunto de instruções diversas vezes de forma controlada.",
    "crumbs": [
      "Introdução",
      "Algorítmos"
    ]
  },
  {
    "objectID": "funcoes/IntroducaoAFuncoes.html",
    "href": "funcoes/IntroducaoAFuncoes.html",
    "title": "Introdução à funções",
    "section": "",
    "text": "Desde a antiguidade, matemáticos do mundo inteiro buscaram maneiras cada vez mais eficientes de calcular o valor de \\(\\pi\\). Esse número, que nasce da geometria dos círculos, acabou se tornando essencial em áreas como física, computação, engenharia, astronomia e estatística. A busca por métodos rápidos e precisos para calcular \\(\\pi\\) é tão antiga quanto a própria matemática, e evoluiu de formas surpreendentes ao longo da história.\nPrimeiro vieram as aproximações geométricas, como as de Arquimedes. Mais tarde surgiram séries matemáticas que, ao somar infinitos termos, aproximavam \\(\\pi\\) com cada vez mais precisão. Algumas dessas séries funcionam, mas convergem tão lentamente que seriam impraticáveis para cálculos modernos que exigem milhões ou bilhões de casas decimais.\nO grande salto veio no século XX. O matemático indiano Srinivasa Ramanujan descobriu fórmulas extraordinárias, capazes de calcular \\(\\pi\\) com rapidez impressionante. Décadas depois, inspirado em seu trabalho, os irmãos David e Gregory Chudnovsky desenvolveram uma fórmula ainda mais eficiente. Ela se tornou a base dos recordes modernos de cálculo de \\(\\pi\\). Vários dos maiores valores já calculados — contendo trilhões de dígitos — foram obtidos usando essa fórmula.\nO motivo? A fórmula de Chudnovsky converge incrivelmente rápido. Cada termo adicionado à série já é suficiente para somar dezenas de casas decimais corretas.\nA fórmula de Chudnovsky é a seguinte:\n\\[\n\\frac{1}{\\pi} = 12 \\sum_{n = 0}^{\\infty} \\frac{(-1)^n (6n)! (545140134n+13591409)}{(3n)!(n!)^3 640320^{3n + \\frac{3}{2}}}\n\\]\nCada novo termo depende de algumas operações:\n\num sinal alternado: \\((-1)^n\\)\num polinômio: \\(545140134𝑛 +13591409\\)\ne, principalmente, fatoriais grandes, como\n\n\\((6n)!\\)\n\\((3n)!\\)\n\\((n!)^3\\)\n\n\nAgora vamos tentar montar um programa simples para calcular um único termo desta série, utilizando somente os conhecimentos que possuímos até o momento.\n\n\n\n\n\n\nNoteTente fazer! (clique para revelar a solução)\n\n\n\n\n\n\n# declaração de n (como 0 para o primeiro termo da série)\nn: int = 0\n\n# Cálculo do fatorial de 6n\nfatorial_6n = 1\nfor i in range(1, 6 * n + 1):\n    fatorial_6n *= i\n\n# Cálculo do fatorial de 3n\nfatorial_3n = 1\nfor i in range(1, 3 * n + 1):\n    fatorial_3n *= i\n\n# Cálculo do fatorial de n\nfatorial_n = 1\nfor i in range(1, n + 1):\n    fatorial_n *= i\n\n# calcular o numerador do termo da série\nnumerador: float = ((-1) ** n) * fatorial_6n * ((545140134 * n) + 13591409)\n\n# calcular o denominador do termo da série\ndenominador: float = fatorial_3n * (fatorial_n ** 3) * (640320 ** (3 * n)) * (640320 ** (1.5))\n\n# calcular a divisão dos dois\ntermo_da_serie: float = numerador / denominador\n\n# lembrando que 1/pi = 12 * termo_da_serie -&gt; pi = 1/(12 * termo_da_serie)\nprint(1/(12 * termo_da_serie))\n\nCaso não tenha conseguido implementar este código, execute esta implementação na sua máquina e busque entender o que está acontecendo exatamente.\nHá também, um detalhe importante no cálcuo do denominador, onde foi utilizado a propriedade que \\(a^{b + c} = a^b \\times a^c\\) para reescrever \\(640320^{3n + \\frac{3}{2}}\\) como \\(640320^{3n} \\times 640320^{\\frac{3}{2}}\\), para melhorar a precisão do resultado no computador.\n\n\n\nAo escrever o código dessa forma, percebemos uma situação curiosa: para calcular apenas um termo da série, tivemos que repetir várias vezes exatamente o mesmo tipo de processo — calcular o fatorial de um número.\nVeja que:\no cálculo de \\((6n)!\\) segue um passo a passo, o cálculo de \\((3n)!\\) segue o mesmo passo a passo e o cálculo de \\(n!\\) também segue o mesmo passo a passo!\nA única coisa que muda entre eles é qual número estamos utilizando, mas o que está sendo calculado é a mesma coisa: o fatorial.\nIsso significa que estamos copiando e colando o mesmo raciocínio várias vezes, mudando só um detalhe. Ou seja, estamos fazendo trabalho repetido, manual e desnecessário.\nE nos leva a duas reflexões:\n\n\nEssa repetição já é um problema por si só, pois deixa o código:\n\nmais longo\nmais difícil de ler\nmais cansativo de escrever\n\n\n\n\nImagine agora que, por algum motivo, cometemos um erro na forma como escrevemos o cálculo do fatorial. Talvez tenhamos começado o loop no número errado, ou multiplicado na ordem incorreta, ou simplesmente esquecido um detalhe importante. (No código acima tudo está correto — estamos apenas imaginando um cenário em que houvesse um erro.)\nComo copiamos esse cálculo três vezes, esse erro estaria:\n\nno fatorial de \\(6n\\)\nno fatorial de \\(3n\\)\nno fatorial de \\(n\\)\n\nE então, para corrigir esse erro, precisaríamos:\n\nlembrar de procurar cada trecho repetido\ncorrigir todos eles manualmente\ngarantir que não esquecemos nenhum\n\nEsse tipo de repetição é uma grande fonte de bugs em programas reais. Quanto mais partes iguais espalhadas pelo código, maior a chance de:\n\nesquecer de atualizar uma delas\ncorrigir uma versão e deixar outra errada\ncriar inconsistências difíceis de rastrear\nOu seja: além de trabalhoso, é arriscado.\n\n\n\n\nSerá que precisamos reescrever todo esse processo sempre que quisermos calcular um fatorial diferente?\nSeria muito mais prático se pudéssemos descrever esse processo uma única vez, de forma correta, e depois simplesmente pedir ao computador que o execute para qualquer número.\nComo se disséssemos ao computador:\n\n“Este é o procedimento para calcular um fatorial. Sempre que eu precisar, eu te digo o número e você faz isso pra mim.”\n\nA programação oferece exatamente esse mecanismo: a possibilidade de guardar um procedimento e reutilizá-lo sempre que necessário, mudando apenas a informação de entrada.\nIsso melhora tudo:\n\nevita repetição\nevita erros de manutenção\ndeixa o código mais curto\ndeixa o programa mais organizado\ndiminui a chance de bugs\n\nEsse mecanismo recebe um nome muito importante: função.",
    "crumbs": [
      "Funções",
      "Introdução à funções"
    ]
  },
  {
    "objectID": "funcoes/IntroducaoAFuncoes.html#exemplo-motivacional",
    "href": "funcoes/IntroducaoAFuncoes.html#exemplo-motivacional",
    "title": "Introdução à funções",
    "section": "",
    "text": "Desde a antiguidade, matemáticos do mundo inteiro buscaram maneiras cada vez mais eficientes de calcular o valor de \\(\\pi\\). Esse número, que nasce da geometria dos círculos, acabou se tornando essencial em áreas como física, computação, engenharia, astronomia e estatística. A busca por métodos rápidos e precisos para calcular \\(\\pi\\) é tão antiga quanto a própria matemática, e evoluiu de formas surpreendentes ao longo da história.\nPrimeiro vieram as aproximações geométricas, como as de Arquimedes. Mais tarde surgiram séries matemáticas que, ao somar infinitos termos, aproximavam \\(\\pi\\) com cada vez mais precisão. Algumas dessas séries funcionam, mas convergem tão lentamente que seriam impraticáveis para cálculos modernos que exigem milhões ou bilhões de casas decimais.\nO grande salto veio no século XX. O matemático indiano Srinivasa Ramanujan descobriu fórmulas extraordinárias, capazes de calcular \\(\\pi\\) com rapidez impressionante. Décadas depois, inspirado em seu trabalho, os irmãos David e Gregory Chudnovsky desenvolveram uma fórmula ainda mais eficiente. Ela se tornou a base dos recordes modernos de cálculo de \\(\\pi\\). Vários dos maiores valores já calculados — contendo trilhões de dígitos — foram obtidos usando essa fórmula.\nO motivo? A fórmula de Chudnovsky converge incrivelmente rápido. Cada termo adicionado à série já é suficiente para somar dezenas de casas decimais corretas.\nA fórmula de Chudnovsky é a seguinte:\n\\[\n\\frac{1}{\\pi} = 12 \\sum_{n = 0}^{\\infty} \\frac{(-1)^n (6n)! (545140134n+13591409)}{(3n)!(n!)^3 640320^{3n + \\frac{3}{2}}}\n\\]\nCada novo termo depende de algumas operações:\n\num sinal alternado: \\((-1)^n\\)\num polinômio: \\(545140134𝑛 +13591409\\)\ne, principalmente, fatoriais grandes, como\n\n\\((6n)!\\)\n\\((3n)!\\)\n\\((n!)^3\\)\n\n\nAgora vamos tentar montar um programa simples para calcular um único termo desta série, utilizando somente os conhecimentos que possuímos até o momento.\n\n\n\n\n\n\nNoteTente fazer! (clique para revelar a solução)\n\n\n\n\n\n\n# declaração de n (como 0 para o primeiro termo da série)\nn: int = 0\n\n# Cálculo do fatorial de 6n\nfatorial_6n = 1\nfor i in range(1, 6 * n + 1):\n    fatorial_6n *= i\n\n# Cálculo do fatorial de 3n\nfatorial_3n = 1\nfor i in range(1, 3 * n + 1):\n    fatorial_3n *= i\n\n# Cálculo do fatorial de n\nfatorial_n = 1\nfor i in range(1, n + 1):\n    fatorial_n *= i\n\n# calcular o numerador do termo da série\nnumerador: float = ((-1) ** n) * fatorial_6n * ((545140134 * n) + 13591409)\n\n# calcular o denominador do termo da série\ndenominador: float = fatorial_3n * (fatorial_n ** 3) * (640320 ** (3 * n)) * (640320 ** (1.5))\n\n# calcular a divisão dos dois\ntermo_da_serie: float = numerador / denominador\n\n# lembrando que 1/pi = 12 * termo_da_serie -&gt; pi = 1/(12 * termo_da_serie)\nprint(1/(12 * termo_da_serie))\n\nCaso não tenha conseguido implementar este código, execute esta implementação na sua máquina e busque entender o que está acontecendo exatamente.\nHá também, um detalhe importante no cálcuo do denominador, onde foi utilizado a propriedade que \\(a^{b + c} = a^b \\times a^c\\) para reescrever \\(640320^{3n + \\frac{3}{2}}\\) como \\(640320^{3n} \\times 640320^{\\frac{3}{2}}\\), para melhorar a precisão do resultado no computador.\n\n\n\nAo escrever o código dessa forma, percebemos uma situação curiosa: para calcular apenas um termo da série, tivemos que repetir várias vezes exatamente o mesmo tipo de processo — calcular o fatorial de um número.\nVeja que:\no cálculo de \\((6n)!\\) segue um passo a passo, o cálculo de \\((3n)!\\) segue o mesmo passo a passo e o cálculo de \\(n!\\) também segue o mesmo passo a passo!\nA única coisa que muda entre eles é qual número estamos utilizando, mas o que está sendo calculado é a mesma coisa: o fatorial.\nIsso significa que estamos copiando e colando o mesmo raciocínio várias vezes, mudando só um detalhe. Ou seja, estamos fazendo trabalho repetido, manual e desnecessário.\nE nos leva a duas reflexões:\n\n\nEssa repetição já é um problema por si só, pois deixa o código:\n\nmais longo\nmais difícil de ler\nmais cansativo de escrever\n\n\n\n\nImagine agora que, por algum motivo, cometemos um erro na forma como escrevemos o cálculo do fatorial. Talvez tenhamos começado o loop no número errado, ou multiplicado na ordem incorreta, ou simplesmente esquecido um detalhe importante. (No código acima tudo está correto — estamos apenas imaginando um cenário em que houvesse um erro.)\nComo copiamos esse cálculo três vezes, esse erro estaria:\n\nno fatorial de \\(6n\\)\nno fatorial de \\(3n\\)\nno fatorial de \\(n\\)\n\nE então, para corrigir esse erro, precisaríamos:\n\nlembrar de procurar cada trecho repetido\ncorrigir todos eles manualmente\ngarantir que não esquecemos nenhum\n\nEsse tipo de repetição é uma grande fonte de bugs em programas reais. Quanto mais partes iguais espalhadas pelo código, maior a chance de:\n\nesquecer de atualizar uma delas\ncorrigir uma versão e deixar outra errada\ncriar inconsistências difíceis de rastrear\nOu seja: além de trabalhoso, é arriscado.\n\n\n\n\nSerá que precisamos reescrever todo esse processo sempre que quisermos calcular um fatorial diferente?\nSeria muito mais prático se pudéssemos descrever esse processo uma única vez, de forma correta, e depois simplesmente pedir ao computador que o execute para qualquer número.\nComo se disséssemos ao computador:\n\n“Este é o procedimento para calcular um fatorial. Sempre que eu precisar, eu te digo o número e você faz isso pra mim.”\n\nA programação oferece exatamente esse mecanismo: a possibilidade de guardar um procedimento e reutilizá-lo sempre que necessário, mudando apenas a informação de entrada.\nIsso melhora tudo:\n\nevita repetição\nevita erros de manutenção\ndeixa o código mais curto\ndeixa o programa mais organizado\ndiminui a chance de bugs\n\nEsse mecanismo recebe um nome muito importante: função.",
    "crumbs": [
      "Funções",
      "Introdução à funções"
    ]
  },
  {
    "objectID": "funcoes/IntroducaoAFuncoes.html#introdução-a-funções",
    "href": "funcoes/IntroducaoAFuncoes.html#introdução-a-funções",
    "title": "Introdução à funções",
    "section": "Introdução a funções",
    "text": "Introdução a funções\nApós ver o exemplo motivacional sobre o cálculo do fatorial, você provavelmente percebeu que, ao repetir o mesmo processo várias vezes, estamos criando um código difícil de manter, suscetível a erros e redundante. Uma solução muito poderosa para esse problema é a utilização de funções. As funções são um dos conceitos mais importantes na programação, permitindo que você organize melhor o código, evite repetições e torne o programa mais legível.\nMas, o que são funções exatamente? Como elas funcionam? Como você as usa de forma eficiente? Para responder a essas perguntas, vamos explorar os principais conceitos por trás das funções, como entradas, saídas, parâmetros e retorno.\n\nO que é uma função (“formalização”)?\nUma função é um bloco de código que realiza uma tarefa específica. Podemos vê-la como um pequeno algoritmo dentro do programa, que você pode usar várias vezes, sempre que necessário. Funciona da seguinte maneira:\n\nEntrada: A função recebe alguns valores de entrada (chamados de parâmetros).\nProcessamento: A função realiza um processo interno com esses valores (como um cálculo ou qualquer outra operação).\nSaída: A função devolve um resultado (chamado de retorno), ou então realiza uma ação sem devolver nada.\n\nVamos agora olhar mais a fundo para os diferentes componentes de uma função, começando pelas entradas, que são essenciais para que a função saiba o que fazer.\n\n\nEntradas de uma função\nQuando chamamos uma função, passamos dados para ela. Esses dados são chamados de parâmetros. Eles são valores que a função usa para realizar seu trabalho. Pense nos parâmetros como ingredientes que você passa para a função, para que ela possa gerar um resultado. A principal vantagem dos parâmetros é que eles permitem que uma mesma função seja usada de maneiras diferentes, dependendo do que você fornecer.\nExemplos do mundo real:\n\nReceita de bolo:\nIngredientes como açúcar, ovos e farinha são os parâmetros da receita. Se você quiser fazer um bolo diferente, basta alterar a quantidade de um ou mais ingredientes.\nA mesma receita pode ser usada para diferentes bolos, mudando apenas os parâmetros (quantidade de açúcar, farinha, etc.).\nAplicativo de mapas:\nQuando você pede para o app calcular a rota de ponto A até o ponto B, os endereços de origem e destino são os parâmetros. O algoritmo de navegação é o mesmo, mas o ponto de partida e chegada que são alterados.\nMáquina de café:\nSe você passar o parâmetro “tipo de café”, a máquina pode preparar um café espresso, um cappuccino ou um latte, dependendo do que você escolher. O processo de fazer o café (aquecer a água, misturar o pó de café, etc.) é sempre o mesmo, mas o tipo de café que você recebe vai depender do parâmetro que você forneceu.\n\nNo contexto da programação, os parâmetros permitem que uma função tenha flexibilidade. A mesma função pode ser chamada várias vezes com valores diferentes e produzir resultados diferentes a partir dos mesmos passos internos.\nNo nosso exemplo do fatorial, o número que queremos calcular o fatorial é o parâmetro. Em vez de escrever o cálculo de fatorial várias vezes, com o número alterando de vez em quando, passamos o número como parâmetro para a função e ela faz o trabalho para nós.\n\n\nSaídas de uma função: o retorno\nDepois de executar o processo, a função geralmente devolve um resultado. Esse resultado é chamado de retorno. Dependendo do tipo de tarefa que a função realiza, ela pode retornar:\n\nUm valor específico, como um número ou texto\nNada (ou seja, ela realiza uma ação mas não retorna nenhum valor).\n\n\nFunções com retorno:\nUma função com retorno vai calcular algo com base nas entradas e devolver o resultado. Exemplos disso incluem:\n\nCalcular a soma de dois números.\nConverter temperatura de Celsius para Fahrenheit.\nCalcular o fatorial de um número.\n\nPor exemplo, a função que calcula o fatorial de um número deve retornar o resultado do cálculo, para que possamos usá-lo em outra parte do código.\nFunções sem retorno:\nJá uma função sem retorno não devolve um valor diretamente, mas realiza uma ação. Por exemplo:\n\nImprimir uma mensagem na tela.\nTocar um som.\nSalvar um arquivo no computador.\n\nEssas funções são úteis para executar tarefas que não precisam de um resultado imediato, como mostrar uma mensagem ou realizar um efeito visual no programa.\n\n\n\nPor que utilizar funções?\nAgora que entendemos o conceito básico de funções e seus componentes (parâmetros, entradas, saídas, retorno), vamos refletir sobre as principais vantagens de usá-las:\n\nEvita repetição\n\nAo usar funções, você escreve um conjunto de instruções uma única vez e pode chamá-lo quantas vezes for necessário. No caso do fatorial, você escreveria o cálculo uma vez dentro de uma função e poderia chamá-la sempre que precisasse calcular um fatorial para qualquer número.\n\nReduz erros\n\nSe você precisa corrigir ou otimizar algo, basta alterar a função em um único lugar. Sem funções, teríamos que atualizar várias partes do código, o que aumenta a chance de deixar algo passar batido. Com funções, isso fica bem mais seguro e eficiente.\n\nFacilita a manutenção\n\nCódigo que utiliza funções é muito mais fácil de entender e manter, porque você pode pensar nas funções como pequenos blocos de construção. Se você precisar alterar algo, pode se concentrar apenas na função específica, sem se preocupar em revisar o código inteiro.\n\nPermite a abstração\n\nFunções permitem que você se concentre no que uma parte do programa faz, sem se preocupar com o como ela faz. Em vez de entender todos os detalhes de um cálculo ou tarefa, você só precisa saber qual função chamar e qual valor passar para ela.\n\n\nResumo\n\n\n\n\n\n\n\nConceito\nDescrição\n\n\n\n\nParâmetro(s) / Entrada\nValores que a função recebe como entrada, dados fornecidos para a função\n\n\nProcesso\nAs instruções internas que a função executa com esses dados\n\n\nSaída\nO que a função produz após executar seu processo\n\n\nRetorno\nO valor que a função devolve (ou nada, se não houver retorno)",
    "crumbs": [
      "Funções",
      "Introdução à funções"
    ]
  },
  {
    "objectID": "funcoes/IntroducaoAFuncoes.html#funções-que-já-conhecemos",
    "href": "funcoes/IntroducaoAFuncoes.html#funções-que-já-conhecemos",
    "title": "Introdução à funções",
    "section": "Funções que já conhecemos",
    "text": "Funções que já conhecemos\nVocê já está usando funções no seu código, sem nem perceber! Dois exemplos que você provavelmente usa o tempo todo em Python são as funções print() e input(). Ambas são essenciais para a interação com o usuário e a exibição de informações. No entanto, embora você já as tenha usado, talvez não tenha notado que ambas são funções completas, com entradas (valores que você passa para elas) e saídas (valores que elas retornam ou ações que realizam).\nAgora que começamos a entender o que são funções, vamos analisar como essas duas funções que você já conhece funcionam internamente, e o que elas fazem com as entradas e saídas.\n\nFunção print()\nA função print() é provavelmente a função mais usada em Python. Ela permite que você mostre informações na tela durante a execução do seu programa. Sempre que você quer que algo apareça para o usuário — seja uma mensagem, um valor ou o resultado de um cálculo — você usa print().\n\nEntradas: o que a função print() recebe\nA função print() pode receber um ou mais parâmetros, que são os valores que você deseja exibir na tela. Cada valor é separado por vírgula dentro dos parênteses. Esses valores podem ser strings, números, ou variáveis.\nPor exemplo:\n\nprint(\"Olá, Mundo!\")\n\nAqui, a função print() recebe uma string (“Olá, Mundo!”) como parâmetro e exibe essa string na tela. Você pode também passar várias informações de uma vez, separadas por vírgulas, e o Python irá automaticamente adicionar espaços entre elas:\n\nnome = \"Maria\"\nidade = 25\nprint(\"Nome:\", nome, \"Idade:\", idade)\n\nNeste caso, a função print() recebe três parâmetros: a string “Nome:”, a variável nome e a string “Idade:”. Ela imprime esses valores na tela, com espaços entre eles.\n\n\nSaída: o que a função print() retorna\nA função print() não retorna nenhum valor. Ela apenas exibe as entradas fornecidas na tela. Em outras palavras, não há um valor retornado por print() que você possa usar em outros cálculos ou variáveis. Se quisermos usar a terminologia de funções:\n\nSaída/Retorno: None (não há um valor retornado, a saída é apenas o efeito de exibir algo na tela)\n\n\n\nResumo da função print()\n\n\n\n\n\n\n\nConceito\nDescrição\n\n\n\n\nParâmetro(s)\nO(s) valor(es) que você quer exibir (ex: uma string ou variável)\n\n\nEntrada\nO que você quer mostrar na tela\n\n\nSaída/Retorno\nNão retorna valor, apenas exibe a informação\n\n\n\n\n\n\nFunção input()\nA função input() é outra função muito comum em Python. Ela permite que você obtenha dados do usuário. Sempre que você precisa fazer uma pergunta ao usuário e obter uma resposta, você usa input().\n\nEntradas: o que a função input() recebe\nA função input() pode receber um parâmetro, que é o texto que você deseja exibir para o usuário antes que ele digite a resposta. Esse texto é normalmente uma pergunta ou uma mensagem explicativa.\nPor exemplo:\n\nnome = input(\"Qual é o seu nome? \")\nprint(\"Olá, \" + nome + \"!\")\n\nAqui, a função input() recebe o parâmetro “Qual é o seu nome?” e exibe essa mensagem na tela. O Python então espera que o usuário digite uma resposta. Quando o usuário digita, a função retorna a resposta como uma string. A resposta do usuário é armazenada na variável nome, que pode ser utilizada posteriormente.\n\n\nSaída: o que a função input() retorna\nA função input() sempre retorna uma string, independentemente do que o usuário digite. Isso significa que, mesmo que o usuário digite números, a entrada será interpretada como texto.\nPor exemplo, se o usuário digitar “25” (para idade), ele será armazenado como a string “25”. Se quisermos tratar esse valor como um número, precisamos convertê-lo para o tipo correto usando funções como int() ou float().\n\nidade = input(\"Quantos anos você tem? \")\nidade = int(idade)  # Converte a resposta para um número inteiro\nprint(\"Você tem\", idade, \"anos.\")\n\nAqui, a função input() retorna a resposta do usuário como uma string. Depois, usamos int() para converter essa string em um número inteiro.\n\n\nResumo da função input()\n\n\n\n\n\n\n\nConceito\nDescrição\n\n\n\n\nParâmetro(s)\nO texto exibido para o usuário (ex: uma pergunta ou mensagem)\n\n\nEntrada\nO que o usuário digita como resposta\n\n\nSaída/Retorno\nA função retorna uma string (mesmo que o usuário digite números)",
    "crumbs": [
      "Funções",
      "Introdução à funções"
    ]
  },
  {
    "objectID": "funcoes/IntroducaoAFuncoes.html#sintaxe-de-utilização-de-funções",
    "href": "funcoes/IntroducaoAFuncoes.html#sintaxe-de-utilização-de-funções",
    "title": "Introdução à funções",
    "section": "Sintaxe de utilização de funções",
    "text": "Sintaxe de utilização de funções\nAgora que já sabemos o que são funções e por que elas são úteis, vamos entender como chamá-las corretamente. Chamar uma função significa pedir ao Python para executar o código dentro daquela função. Quando você chama uma função, o programa “vai até a função”, executa as instruções que estão nela e, em muitos casos, retorna um resultado.\nEm termos simples, chamar uma função é como fazer um pedido para o programa realizar uma tarefa específica. Quando você chama a função, ela faz algo por você, seja exibindo algo na tela, realizando um cálculo, ou até recebendo dados de entrada do usuário.\nAgora, vamos ver como a sintaxe de uma função funciona em Python, incluindo como passar parâmetros, como chamar funções sem parâmetros e como lidar com valores retornados.\n\nChamar uma função\nEm Python, chamar uma função é bem simples, mas precisa seguir uma estrutura específica. Toda vez que você quiser usar uma função, você deve incluir parênteses após o nome da função.\n\nnome_da_funcao()\n\n\n\nFunções com parâmetros\nAs funções podem receber parâmetros, que são os valores que você passa para elas para que possam realizar algum processamento. Esses parâmetros são colocados dentro dos parênteses ao chamar a função.\n\nnome_da_funcao(parametro_1, parametro_2, ...)\n\n\n\nFunções sem parâmetro\nAlgumas funções não exigem nenhum parâmetro. Nesse caso, você ainda deve usar os parênteses ao chamar a função, mas não há necessidade de colocar nada dentro deles.\n\nnome_da_funcao()\n\n\n\nFunções com retorno\nFunções podem retornar um valor após a execução. O valor retornado pode ser armazenado em uma variável ou utilizado diretamente em cálculos ou outras operações.\nQuando uma função tem retorno, a sintaxe para usá-la fica da seguinte forma:\n\nvariavel = nome_da_funcao(parametros)\n\n\n\nFunções com parâmetros opcionais\nÀs vezes, as funções podem ter parâmetros com valores padrão, o que significa que, se você não passar um valor para aquele parâmetro, o Python usará algum valor pré-definido.\nOu seja, se temos uma função, por exemplo, que tem um parâmetro “parametro_1” pré-definido para o valor 10, se um novo valor de a não for especificado na chamada, da seguinte forma:\n\nnome_da_funcao(parametro_1 = 3)\n\nA função é executada com o valor de “parametro_1” igual a 10.",
    "crumbs": [
      "Funções",
      "Introdução à funções"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sobre o curso",
    "section": "",
    "text": "Python instalado;\n\nVS Code instalado;\n\nConta no GitHub.",
    "crumbs": [
      "Sobre o curso"
    ]
  },
  {
    "objectID": "index.html#pré-requisitos",
    "href": "index.html#pré-requisitos",
    "title": "Sobre o curso",
    "section": "",
    "text": "Python instalado;\n\nVS Code instalado;\n\nConta no GitHub.",
    "crumbs": [
      "Sobre o curso"
    ]
  },
  {
    "objectID": "index.html#matérias-do-curso",
    "href": "index.html#matérias-do-curso",
    "title": "Sobre o curso",
    "section": "Matérias do curso",
    "text": "Matérias do curso\n\nIntrodução a algoritmos\nNesta disciplina, o aluno aprenderá o que são algoritmos, como eles funcionam e por que são fundamentais para a computação. Serão abordados conceitos como sequência lógica, decisões e fluxo de execução. O objetivo é desenvolver o raciocínio lógico e a capacidade de transformar um problema do mundo real em uma sequência clara de passos que o computador possa entender e executar.\nAo final dessa parte, o estudante será capaz de descrever algoritmos utilizando linguagem natural, fluxogramas ou pseudocódigo, compreendendo como cada decisão e ação afeta o resultado final de um processo.\n\n\n\nIntrodução à programação\nDepois de compreender o que é um algoritmo, o aluno começará a transformar suas ideias em código. Essa disciplina introduz os conceitos básicos de programação utilizando a linguagem Python, por sua simplicidade e clareza. Serão estudados temas como variáveis, tipos de dados, operadores e estruturas condicionais.\nO foco é entender como um computador interpreta instruções escritas pelo programador e como transformar lógica em ações reais, permitindo criar pequenos programas funcionais e interativos.\n\n\n\nFunções\nNesta etapa, o aluno aprenderá a dividir um programa em partes menores e mais organizadas por meio das funções. Serão explicados conceitos como parâmetros, retorno de valores e escopo de variáveis.\nO objetivo é mostrar como funções ajudam a evitar repetições de código, facilitam a manutenção e tornam os programas mais claros e reutilizáveis. Ao final, o estudante conseguirá criar suas próprias funções para resolver tarefas específicas dentro de um projeto maior.\n\n\n\nMódulos\nOs módulos permitem organizar e reutilizar códigos de forma eficiente. Nesta matéria, o aluno aprenderá a importar e utilizar módulos já existentes no Python, bem como criar seus próprios. Serão apresentados módulos padrão, como math e datetime, e também a forma de integrar bibliotecas externas.\nEssa parte do curso reforça a importância de estruturar programas em partes independentes e reaproveitáveis, promovendo boas práticas de organização e modularidade no desenvolvimento de software.\n\n\n\nObjetos e classes\nAqui, o foco será entender a base da programação orientada a objetos (POO). O aluno aprenderá o que são classes, objetos, atributos e métodos, e como eles se relacionam. A ideia é compreender como representar entidades do mundo real dentro de um programa, criando estruturas que combinam dados e comportamentos.\nAo final desta seção, o estudante será capaz de criar classes simples e instanciar objetos, compreendendo a importância desse paradigma para o desenvolvimento de sistemas mais organizados e escaláveis.\n\n\n\nProgramação orientada a objetos\nNesta matéria, os conceitos de objetos e classes serão aprofundados. Serão estudados princípios fundamentais da POO, como herança, encapsulamento, polimorfismo e abstração. O objetivo é capacitar o aluno a escrever programas mais robustos, flexíveis e reutilizáveis.\nCom exemplos práticos, o estudante verá como a programação orientada a objetos é aplicada em projetos reais e entenderá por que ela é amplamente usada em linguagens modernas como Python, Java e C#.\n\n\n\nIntrodução a estruturas de dados\nPor fim, o curso abordará as estruturas de dados, que são formas de armazenar e organizar informações dentro de um programa. O aluno aprenderá a trabalhar com listas, dicionários, tuplas e conjuntos, entendendo suas diferenças e aplicações.\nEssa etapa é essencial para desenvolver programas mais eficientes, capazes de lidar com grandes quantidades de dados de maneira organizada. Também será o primeiro passo para entender conceitos mais avançados como filas, pilhas e árvores em cursos futuros.",
    "crumbs": [
      "Sobre o curso"
    ]
  },
  {
    "objectID": "index.html#boas-fontes-adicionais",
    "href": "index.html#boas-fontes-adicionais",
    "title": "Sobre o curso",
    "section": "Boas fontes adicionais",
    "text": "Boas fontes adicionais\n\ngeeksforgeeks\nw3schools\nDocumentação oficial de Python",
    "crumbs": [
      "Sobre o curso"
    ]
  },
  {
    "objectID": "introducao/CasosDeTeste.html",
    "href": "introducao/CasosDeTeste.html",
    "title": "Casos de Teste — TP1",
    "section": "",
    "text": "Introdução aos Casos de Teste\nOs casos de teste são cenários ou exemplos que são utilizados para verificar se o comportamento de um programa ou sistema está de acordo com o esperado. Em programação, os casos de teste são essenciais para validar que a implementação de uma funcionalidade está correta, funcionando corretamente e atendendo aos requisitos especificados.\n\nO que é um Caso de Teste?\nUm caso de teste é uma descrição de uma entrada (ou várias entradas) que um programa deve processar, o comportamento esperado do sistema para essas entradas e o resultado que deve ser gerado. Os casos de teste podem ser utilizados para:\n\nVerificar a correção do código: Garantir que as funções ou métodos estejam funcionando conforme o esperado.\nValidar o comportamento esperado: Testar se o sistema responde corretamente a diferentes cenários ou entradas.\nIdentificar falhas: Detectar erros ou falhas que podem ocorrer em partes do código, ajudando a melhorar a qualidade do software.\n\n\n\nComo Utilizar um Caso de Teste?\nPara utilizar um caso de teste, o processo geralmente envolve as seguintes etapas:\n\nDefinir as entradas: Estabelecer o conjunto de dados que serão usados como entrada para o sistema. Isso pode incluir variáveis, parâmetros ou dados de teste predefinidos.\nExecutar o teste: Submeter as entradas ao sistema ou programa, observando como ele reage às entradas e qual saída é gerada.\nComparar os resultados: Comparar a saída do sistema com a saída esperada. Se o comportamento do sistema corresponder ao esperado, o caso de teste é considerado bem-sucedido. Caso contrário, é necessário investigar e corrigir os erros.\nDocumentar o caso de teste: Registrar os detalhes do teste, incluindo entradas, saídas esperadas, comportamento observado e resultados. Isso pode ser feito de forma estruturada, utilizando ferramentas de testes automatizados ou, como neste caso, de forma manual para testes mais simples.\n\n\n\n\nComo Interpretar os Casos de Teste\nCada caso de teste foi projetado para testar um conjunto específico de entradas e condições, e verificar se o programa reage conforme o esperado. Eles ajudam a garantir que a implementação do software esteja funcionando corretamente sob diferentes condições e com diferentes tipos de dados.\nA seguir, serão apresentados casos de teste específicos para um sistema de análise de insolação, cada um com entradas e resultados esperados. Estes testes ajudam a validar a precisão e confiabilidade do programa desenvolvido.\n\n\nCaso de teste 1\n\nTodos os Andares e Apartamentos com Insolação:\n\n\n\nAndar\nJanela 1\nJanela 2\nJanela 3\n\n\n\n\n10°\n7\n5\n1\n\n\n9°\n1\n2\n0\n\n\n8°\n6\n0\n8\n\n\n7°\n3\n3\n1\n\n\n6°\n8\n7\n0\n\n\n5°\n7\n3\n4\n\n\n4°\n7\n3\n7\n\n\n3°\n4\n5\n7\n\n\n2°\n7\n7\n7\n\n\n1°\n9\n3\n6\n\n\n\n\n\nSoma das Insolações de Cada janela:\n\\(\\sum{\\text{insolação de cada janela}} = 138\\)\n\n\nInsolação Média Geral:\n\\(I_{media} = \\frac{\\sum{\\text{insolação de cada janela}}}{\\text{quantidade de janelas}} = \\frac{138}{30} = 4.6\\)\n\n\nQuantidade de Janelas com Insolação Excessiva:\n\\(Q_{exc} = 3\\)\n\n\nQuantidade de Janelas com Insolação Insuficiente:\n\\(Q_{ins} = 7\\)\n\n\nPorcentagem de Janelas com Insolação Excessiva:\n\\(P_{exc} = \\frac{Q_{exc}}{\\text{total de janelas}} = \\frac{3}{30} = 0.1\\)\n\n\nPorcentagem de Janelas com Insolação Insuficiente:\n\\(P_{ins} = \\frac{Q_{ins}}{\\text{total de janelas}} = \\frac{7}{30} = 0.23333333333333334\\)\n\n\nPorcentagem de Janelas Problemáticas:\n\\(P_{prob} = \\frac{Q_{exc} + Q_{ins}}{\\text{total de janelas}} = \\frac{3 + 7}{30} = \\frac{10}{30} = 0.3333333333333333\\)\n\n\nMensagem:\n“Porcentagem aceitável de janelas problemáticas.”\n\n\n\nCaso de teste 2\n\nTodos os Andares e Apartamentos com Insolação:\n\n\n\nAndar\nJanela 1\nJanela 2\nJanela 3\n\n\n\n\n10°\n5\n3\n6\n\n\n9°\n7\n3\n3\n\n\n8°\n5\n8\n10\n\n\n7°\n5\n4\n7\n\n\n6°\n1\n3\n9\n\n\n5°\n2\n7\n9\n\n\n4°\n5\n6\n6\n\n\n3°\n3\n7\n7\n\n\n2°\n6\n6\n8\n\n\n1°\n4\n9\n9\n\n\n\n\n\nSoma das Insolações de Cada janela:\n\\(\\sum{\\text{insolação de cada janela}} = 173\\)\n\n\nInsolação Média Geral:\n\\(I_{media} = \\frac{\\sum{\\text{insolação de cada janela}}}{\\text{quantidade de janelas}} = \\frac{173}{30} = 5.766666666666667\\)\n\n\nQuantidade de Janelas com Insolação Excessiva:\n\\(Q_{exc} = 7\\)\n\n\nQuantidade de Janelas com Insolação Insuficiente:\n\\(Q_{ins} = 2\\)\n\n\nPorcentagem de Janelas com Insolação Excessiva:\n\\(P_{exc} = \\frac{Q_{exc}}{\\text{total de janelas}} = \\frac{7}{30} = 0.23333333333333334\\)\n\n\nPorcentagem de Janelas com Insolação Insuficiente:\n\\(P_{ins} = \\frac{Q_{ins}}{\\text{total de janelas}} = \\frac{2}{30} = 0.06666666666666667\\)\n\n\nPorcentagem de Janelas Problemáticas:\n\\(P_{prob} = \\frac{Q_{exc} + Q_{ins}}{\\text{total de janelas}} = \\frac{7 + 2}{30} = \\frac{9}{30} = 0.3\\)\n\n\nMensagem:\n“Porcentagem aceitável de janelas problemáticas.”\n\n\n\nCaso de teste 3\n\nTodos os Andares e Apartamentos com Insolação:\n\n\n\nAndar\nJanela 1\nJanela 2\nJanela 3\n\n\n\n\n10°\n2\n7\n9\n\n\n9°\n5\n8\n6\n\n\n8°\n3\n8\n6\n\n\n7°\n5\n0\n6\n\n\n6°\n0\n0\n4\n\n\n5°\n7\n1\n3\n\n\n4°\n9\n8\n3\n\n\n3°\n2\n0\n3\n\n\n2°\n5\n9\n6\n\n\n1°\n7\n2\n2\n\n\n\n\n\nSoma das Insolações de Cada janela:\n\\(\\sum{\\text{insolação de cada janela}} = 136\\)\n\n\nInsolação Média Geral:\n\\(I_{media} = \\frac{\\sum{\\text{insolação de cada janela}}}{\\text{quantidade de janelas}} = \\frac{136}{30} = 4.533333333333333\\)\n\n\nQuantidade de Janelas com Insolação Excessiva:\n\\(Q_{exc} = 6\\)\n\n\nQuantidade de Janelas com Insolação Insuficiente:\n\\(Q_{ins} = 9\\)\n\n\nPorcentagem de Janelas com Insolação Excessiva:\n\\(P_{exc} = \\frac{Q_{exc}}{\\text{total de janelas}} = \\frac{6}{30} = 0.2\\)\n\n\nPorcentagem de Janelas com Insolação Insuficiente:\n\\(P_{ins} = \\frac{Q_{ins}}{\\text{total de janelas}} = \\frac{9}{30} = 0.3\\)\n\n\nPorcentagem de Janelas Problemáticas:\n\\(P_{prob} = \\frac{Q_{exc} + Q_{ins}}{\\text{total de janelas}} = \\frac{6 + 9}{30} = \\frac{15}{30} = 0.5\\)\n\n\nMensagem:\n“Maior porcentagem de janelas problemáticas do que é permitido!”\n\n\n\nCaso de teste 4\n\nTodos os Andares e Apartamentos com Insolação:\n\n\n\nAndar\nJanela 1\nJanela 2\nJanela 3\n\n\n\n\n10°\n7\n5\n6\n\n\n9°\n6\n0\n0\n\n\n8°\n6\n6\n3\n\n\n7°\n6\n9\n8\n\n\n6°\n5\n6\n4\n\n\n5°\n3\n1\n7\n\n\n4°\n9\n2\n7\n\n\n3°\n4\n0\n5\n\n\n2°\n1\n6\n3\n\n\n1°\n8\n5\n10\n\n\n\n\n\nSoma das Insolações de Cada janela:\n\\(\\sum{\\text{insolação de cada janela}} = 148\\)\n\n\nInsolação Média Geral:\n\\(I_{media} = \\frac{\\sum{\\text{insolação de cada janela}}}{\\text{quantidade de janelas}} = \\frac{148}{30} = 4.933333333333334\\)\n\n\nQuantidade de Janelas com Insolação Excessiva:\n\\(Q_{exc} = 5\\)\n\n\nQuantidade de Janelas com Insolação Insuficiente:\n\\(Q_{ins} = 6\\)\n\n\nPorcentagem de Janelas com Insolação Excessiva:\n\\(P_{exc} = \\frac{Q_{exc}}{\\text{total de janelas}} = \\frac{5}{30} = 0.16666666666666666\\)\n\n\nPorcentagem de Janelas com Insolação Insuficiente:\n\\(P_{ins} = \\frac{Q_{ins}}{\\text{total de janelas}} = \\frac{6}{30} = 0.2\\)\n\n\nPorcentagem de Janelas Problemáticas:\n\\(P_{prob} = \\frac{Q_{exc} + Q_{ins}}{\\text{total de janelas}} = \\frac{5 + 6}{30} = \\frac{11}{30} = 0.36666666666666664\\)\n\n\nMensagem:\n“Porcentagem aceitável de janelas problemáticas.”\n\n\n\nCaso de teste 5\n\nTodos os Andares e Apartamentos com Insolação:\n\n\n\nAndar\nJanela 1\nJanela 2\nJanela 3\n\n\n\n\n10°\n8\n9\n4\n\n\n9°\n8\n10\n6\n\n\n8°\n4\n8\n5\n\n\n7°\n6\n4\n1\n\n\n6°\n2\n8\n6\n\n\n5°\n3\n5\n3\n\n\n4°\n9\n8\n1\n\n\n3°\n0\n7\n5\n\n\n2°\n3\n6\n8\n\n\n1°\n6\n2\n10\n\n\n\n\n\nSoma das Insolações de Cada janela:\n\\(\\sum{\\text{insolação de cada janela}} = 165\\)\n\n\nInsolação Média Geral:\n\\(I_{media} = \\frac{\\sum{\\text{insolação de cada janela}}}{\\text{quantidade de janelas}} = \\frac{165}{30} = 5.5\\)\n\n\nQuantidade de Janelas com Insolação Excessiva:\n\\(Q_{exc} = 10\\)\n\n\nQuantidade de Janelas com Insolação Insuficiente:\n\\(Q_{ins} = 5\\)\n\n\nPorcentagem de Janelas com Insolação Excessiva:\n\\(P_{exc} = \\frac{Q_{exc}}{\\text{total de janelas}} = \\frac{10}{30} = 0.3333333333333333\\)\n\n\nPorcentagem de Janelas com Insolação Insuficiente:\n\\(P_{ins} = \\frac{Q_{ins}}{\\text{total de janelas}} = \\frac{5}{30} = 0.16666666666666666\\)\n\n\nPorcentagem de Janelas Problemáticas:\n\\(P_{prob} = \\frac{Q_{exc} + Q_{ins}}{\\text{total de janelas}} = \\frac{10 + 5}{30} = \\frac{15}{30} = 0.5\\)\n\n\nMensagem:\n“Maior porcentagem de janelas problemáticas do que é permitido!”",
    "crumbs": [
      "Introdução",
      "Projeto",
      "Casos de Teste — TP1"
    ]
  },
  {
    "objectID": "introducao/EstruturasDeRepeticaoEmPython.html",
    "href": "introducao/EstruturasDeRepeticaoEmPython.html",
    "title": "Estruturas de repetição em python",
    "section": "",
    "text": "Em Python, as repetições são realizadas principalmente com duas estruturas: while (controlada por condição) e for (controlada por contagem ou iteração sobre coleções).\n\n\nO comando while repete um bloco de instruções enquanto uma condição lógica for verdadeira. É ideal quando não se sabe quantas vezes será necessário repetir o processo, mas existe uma condição de parada bem definida.\nAbaixo segue sintaxe de um loop do tipo while e o mesmo trecho escrito em pseudocódigo:\n\n\n\n\n\nINÍCIO\n    ENQUANTO condição FAÇA\n        // bloco de instruções\n    FIM ENQUANTO\nFIM\n\n\n\n\n\nwhile condição:\n    # bloco de instruções\n\n\n\n\n\nA condição deve resultar em um valor booleano (True ou False).\nQuando a condição se torna False, o laço é encerrado.\n\n\n\n\n\n\n\nNoteObservação importante\n\n\n\nÉ de extrema importância garantir que a condição de parada se torne em algum momento falsa, pois se isso não ocorrer, o loop nunca é encerrado.\n\n\n\n\nO código abaixo simplesmente conta de 1 até 5, imprimindo o resultado a cada iteração.\n\nPythonPseudocódigo\n\n\n\ncontador = 1\nwhile contador &lt;= 5:\n    print(contador)\n    contador += 1  # incrementa o contador, evitando o loop infinito\nprint(\"Fim do loop!\")\n\n\n\nINÍCIO\n    contador ← 1\n\n    ENQUANTO contador ≤ 5 FAÇA\n        ESCREVA contador\n        contador ← contador + 1 //incrementa o contador, evitando o loop infinito\n    FIM ENQUANTO\n\n    ESCREVA(\"Fim do loop!\")\nFIM\n\n\n\n\n\n\nO código abaixo permanece no loop até que a palavra “sair” seja digitada.\n\nPythonPseudocódigo\n\n\n\nresposta = \"\"\nwhile resposta != \"sair\":\n    resposta = input(\"Digite algo (ou 'sair' para encerrar): \")\nprint(\"Programa encerrado.\")\n\n\n\nINÍCIO\n    resposta ← \"\"\n\n    ENQUANTO contador != \"sair\" FAÇA\n        ESCREVA \"Digite algo (ou 'sair para encerrar): \"\n        resposta ← LEIA resposta\n    FIM ENQUANTO\n\n    ESCREVA \"Programa encerrado.\"\nFIM\n\n\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nO uso deste tipo de estrutura mais simples é quando a quantidade de repetições é desconhecida, mas a continuidade destas repetições é altamente dependente de alguma condição conhecida.\n\n\n\n\n\nO comando for em Python é utilizado para realizar iterações sobre uma sequência de itens, como listas, strings (que são, na verade, coleções de caracteres), ou outros objetos iteráveis. Ele é ideal quando você sabe exatamente quantas vezes precisa repetir um bloco de código ou quando precisa percorrer todos os elementos de uma sequência.\nO for em Python pode ser utilizado de duas formas principais:\n\nFor com range(): controla o número de iterações, ou seja, repete o bloco de código um número específico de vezes.\nFor “each”: percorre diretamente os elementos de uma sequência (lista, string, etc.), um a um.\n\nA seguir, vamos entender as diferenças entre essas duas abordagens.\n\n\nO for com range() é usado quando você deseja realizar uma iteração com um número específico de repetições. A função range() gera uma sequência de números, que é utilizada para controlar o número de iterações.\nA sintaxe básica do for com range() é a seguinte:\n\n\n\n\n\n\nINÍCIO\n    PARA i ← início ATÉ fim - 1 PASSO passo FAÇA\n        // bloco de instruções\n    FIM PARA\nFIM\n\n\n\n\n\nfor i in range(início, fim, passo):\n    # bloco de instruções\n\n\n\n\n\ninício: valor inicial (inclusivo) da sequência (padrão é 0).\nfim: valor final (exclusivo) da sequência.\npasso: o intervalo entre os números (padrão é 1).\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nA função range(início, fim, passo) gera uma sequência de números inteiros que começa em início, avança de acordo com o valor definido em passo e termina antes de alcançar o valor de fim.\nEla não cria exatamente uma lista, mas sim um objeto especial do tipo iterável, que pode ser percorrido em estruturas de repetição como o for. Caso seja necessário visualizar todos os valores da sequência de uma só vez, é possível convertê-lo em uma lista utilizando: list(range(...))\n\n\n\n\n\n\n\n\nForma\nExemplo\nSignificado\n\n\n\n\nrange(fim)\nrange(5) → gera 0, 1, 2, 3, 4\nComeça em 0 e vai até antes de fim (passo padrão = 1)\n\n\nrange(início, fim)\nrange(2, 6) → gera 2, 3, 4, 5\nComeça em início e vai até antes de fim (passo padrão = 1)\n\n\nrange(início, fim, passo)\nrange(1, 10, 2) → gera 1, 3, 5, 7, 9\nComeça em início, vai até antes de fim, saltando de passo em passo\n\n\n\nOu seja, alguns dos valores passados entre os parênteses da função range() são opcionais, e o Python preenche automaticamente os que não forem informados, dependendo da necessidade e da saída desejada. A tabela a seguir mostra quais parâmetros são obrigatórios e quais são opcionais:\n\n\n\n\n\n\n\n\nParâmetro\nObrigatório\nDescrição\n\n\n\n\ninício\n(opcional)\nIndica o primeiro número da sequência (padrão = 0).\n\n\nfim\n(obrigatório)\nIndica onde parar — não é incluído na sequência.\n\n\npasso\n(opcional)\nIndica o incremento (ou decremento) entre os números (padrão = 1).\n\n\n\n\n\n\n\n\nPythonPseudocódigo\n\n\n\nfor i in range(1, 6, 1): #gera a sequência 1, 2, 3, 4, 5\n    print(i)\n\n\n\nINÍCIO\n    PARA i ← 1 ATÉ 5 FAÇA\n        ESCREVA(i)\n    FIM PARA\nFIM\n\n\n\nEste código imprime os números de 1 a 5. O valor 6 não é incluído, pois o range é exclusivo do valor final.\n\n\n\nO for “each” é uma forma de percorrer diretamente os elementos de uma sequência (lista, string, etc.). Ao invés de usar o índice, o for percorre diretamente os elementos da sequência, um por um, sem a necessidade de controlar manualmente o índice.\nA sintaxe básica é:\nOnde:",
    "crumbs": [
      "Introdução",
      "Estruturas de repetição em python"
    ]
  },
  {
    "objectID": "introducao/EstruturasDeRepeticaoEmPython.html#estruturas-de-repetição-em-python",
    "href": "introducao/EstruturasDeRepeticaoEmPython.html#estruturas-de-repetição-em-python",
    "title": "Estruturas de repetição em python",
    "section": "",
    "text": "Em Python, as repetições são realizadas principalmente com duas estruturas: while (controlada por condição) e for (controlada por contagem ou iteração sobre coleções).\n\n\nO comando while repete um bloco de instruções enquanto uma condição lógica for verdadeira. É ideal quando não se sabe quantas vezes será necessário repetir o processo, mas existe uma condição de parada bem definida.\nAbaixo segue sintaxe de um loop do tipo while e o mesmo trecho escrito em pseudocódigo:\n\n\n\n\n\nINÍCIO\n    ENQUANTO condição FAÇA\n        // bloco de instruções\n    FIM ENQUANTO\nFIM\n\n\n\n\n\nwhile condição:\n    # bloco de instruções\n\n\n\n\n\nA condição deve resultar em um valor booleano (True ou False).\nQuando a condição se torna False, o laço é encerrado.\n\n\n\n\n\n\n\nNoteObservação importante\n\n\n\nÉ de extrema importância garantir que a condição de parada se torne em algum momento falsa, pois se isso não ocorrer, o loop nunca é encerrado.\n\n\n\n\nO código abaixo simplesmente conta de 1 até 5, imprimindo o resultado a cada iteração.\n\nPythonPseudocódigo\n\n\n\ncontador = 1\nwhile contador &lt;= 5:\n    print(contador)\n    contador += 1  # incrementa o contador, evitando o loop infinito\nprint(\"Fim do loop!\")\n\n\n\nINÍCIO\n    contador ← 1\n\n    ENQUANTO contador ≤ 5 FAÇA\n        ESCREVA contador\n        contador ← contador + 1 //incrementa o contador, evitando o loop infinito\n    FIM ENQUANTO\n\n    ESCREVA(\"Fim do loop!\")\nFIM\n\n\n\n\n\n\nO código abaixo permanece no loop até que a palavra “sair” seja digitada.\n\nPythonPseudocódigo\n\n\n\nresposta = \"\"\nwhile resposta != \"sair\":\n    resposta = input(\"Digite algo (ou 'sair' para encerrar): \")\nprint(\"Programa encerrado.\")\n\n\n\nINÍCIO\n    resposta ← \"\"\n\n    ENQUANTO contador != \"sair\" FAÇA\n        ESCREVA \"Digite algo (ou 'sair para encerrar): \"\n        resposta ← LEIA resposta\n    FIM ENQUANTO\n\n    ESCREVA \"Programa encerrado.\"\nFIM\n\n\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nO uso deste tipo de estrutura mais simples é quando a quantidade de repetições é desconhecida, mas a continuidade destas repetições é altamente dependente de alguma condição conhecida.\n\n\n\n\n\nO comando for em Python é utilizado para realizar iterações sobre uma sequência de itens, como listas, strings (que são, na verade, coleções de caracteres), ou outros objetos iteráveis. Ele é ideal quando você sabe exatamente quantas vezes precisa repetir um bloco de código ou quando precisa percorrer todos os elementos de uma sequência.\nO for em Python pode ser utilizado de duas formas principais:\n\nFor com range(): controla o número de iterações, ou seja, repete o bloco de código um número específico de vezes.\nFor “each”: percorre diretamente os elementos de uma sequência (lista, string, etc.), um a um.\n\nA seguir, vamos entender as diferenças entre essas duas abordagens.\n\n\nO for com range() é usado quando você deseja realizar uma iteração com um número específico de repetições. A função range() gera uma sequência de números, que é utilizada para controlar o número de iterações.\nA sintaxe básica do for com range() é a seguinte:\n\n\n\n\n\n\nINÍCIO\n    PARA i ← início ATÉ fim - 1 PASSO passo FAÇA\n        // bloco de instruções\n    FIM PARA\nFIM\n\n\n\n\n\nfor i in range(início, fim, passo):\n    # bloco de instruções\n\n\n\n\n\ninício: valor inicial (inclusivo) da sequência (padrão é 0).\nfim: valor final (exclusivo) da sequência.\npasso: o intervalo entre os números (padrão é 1).\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nA função range(início, fim, passo) gera uma sequência de números inteiros que começa em início, avança de acordo com o valor definido em passo e termina antes de alcançar o valor de fim.\nEla não cria exatamente uma lista, mas sim um objeto especial do tipo iterável, que pode ser percorrido em estruturas de repetição como o for. Caso seja necessário visualizar todos os valores da sequência de uma só vez, é possível convertê-lo em uma lista utilizando: list(range(...))\n\n\n\n\n\n\n\n\nForma\nExemplo\nSignificado\n\n\n\n\nrange(fim)\nrange(5) → gera 0, 1, 2, 3, 4\nComeça em 0 e vai até antes de fim (passo padrão = 1)\n\n\nrange(início, fim)\nrange(2, 6) → gera 2, 3, 4, 5\nComeça em início e vai até antes de fim (passo padrão = 1)\n\n\nrange(início, fim, passo)\nrange(1, 10, 2) → gera 1, 3, 5, 7, 9\nComeça em início, vai até antes de fim, saltando de passo em passo\n\n\n\nOu seja, alguns dos valores passados entre os parênteses da função range() são opcionais, e o Python preenche automaticamente os que não forem informados, dependendo da necessidade e da saída desejada. A tabela a seguir mostra quais parâmetros são obrigatórios e quais são opcionais:\n\n\n\n\n\n\n\n\nParâmetro\nObrigatório\nDescrição\n\n\n\n\ninício\n(opcional)\nIndica o primeiro número da sequência (padrão = 0).\n\n\nfim\n(obrigatório)\nIndica onde parar — não é incluído na sequência.\n\n\npasso\n(opcional)\nIndica o incremento (ou decremento) entre os números (padrão = 1).\n\n\n\n\n\n\n\n\nPythonPseudocódigo\n\n\n\nfor i in range(1, 6, 1): #gera a sequência 1, 2, 3, 4, 5\n    print(i)\n\n\n\nINÍCIO\n    PARA i ← 1 ATÉ 5 FAÇA\n        ESCREVA(i)\n    FIM PARA\nFIM\n\n\n\nEste código imprime os números de 1 a 5. O valor 6 não é incluído, pois o range é exclusivo do valor final.\n\n\n\nO for “each” é uma forma de percorrer diretamente os elementos de uma sequência (lista, string, etc.). Ao invés de usar o índice, o for percorre diretamente os elementos da sequência, um por um, sem a necessidade de controlar manualmente o índice.\nA sintaxe básica é:",
    "crumbs": [
      "Introdução",
      "Estruturas de repetição em python"
    ]
  },
  {
    "objectID": "introducao/EstruturasDeRepeticaoEmPython.html#pseudocódigo-5",
    "href": "introducao/EstruturasDeRepeticaoEmPython.html#pseudocódigo-5",
    "title": "Estruturas de repetição em python",
    "section": "Pseudocódigo",
    "text": "Pseudocódigo\nINÍCIO\n    PARA CADA item EM sequência FAÇA\n        // bloco de instruções\n    FIM PARA\nFIM",
    "crumbs": [
      "Introdução",
      "Estruturas de repetição em python"
    ]
  },
  {
    "objectID": "introducao/EstruturasDeRepeticaoEmPython.html#python-5",
    "href": "introducao/EstruturasDeRepeticaoEmPython.html#python-5",
    "title": "Estruturas de repetição em python",
    "section": "Python",
    "text": "Python\n\nfor item in sequência:\n    # bloco de instruções",
    "crumbs": [
      "Introdução",
      "Estruturas de repetição em python"
    ]
  },
  {
    "objectID": "introducao/EstruturasDeRepeticaoEmPython.html#exercícios",
    "href": "introducao/EstruturasDeRepeticaoEmPython.html#exercícios",
    "title": "Estruturas de repetição em python",
    "section": "Exercícios",
    "text": "Exercícios\n\nExercício 1\nUtilize uma estrutura do tipo for each para exibir no terminal todos os elementos da seguinte lista:\n\nlista_de_nomes: list = ['João', 'Pedro', 'Augusto', 'Yuri']\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nSolução (Python)Pseudocódigo\n\n\nCódigo isolado (sem a definição da lista):\n\n# estrutura de repetição para os nomes da lista de nomes\nfor nome in lista_de_nomes:\n    # exibir cada nome\n    print(nome)\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n    PARA CADA nome EM lista_de_nomes FAÇA\n        ESCREVA(nome)\n    FIM PARA\nFIM\n\n\n\n\n\n\n\n\nExercício 2\nRecebe números inteiros do usuário até que ele digite 0, e calcule a soma de todos estes números. No final, exiba esta soma. (Dica: lembre-se de utilizar int(input()) para converter entradas no terminal para números do tipo int).\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nSolução (Python)Pseudocódigo\n\n\n\n# inicializar a soma como 0\nsoma = 0\n\n# adiquirir o número inicial\nnumero = int(input(\"Digite um número inteiro (0 para encerrar): \"))\n\n# estrutura de repetição que se repete até numero ser 0\nwhile numero != 0:\n    # adicionar o número à soma\n    soma += numero\n\n    # adiquirir o novo número\n    numero = int(input(\"Digite outro número inteiro (0 para encerrar): \"))\n\n# exibir o resultado final\nprint(\"Soma total =\", soma)\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n    soma ← 0\n    ESCREVA \"Digite um número inteiro (0 para encerrar): \"\n    LEIA numero\n\n    ENQUANTO numero != 0 FAÇA\n        soma += numero\n        ESCREVA \"Digite outro número inteiro (0 para encerrar): \"\n        LEIA numero\n    FIM ENQUANTO\n\n    ESCREVA \"Soma total = \", soma\nFIM\n\n\n\n\n\n\n\n\nExercício 3\nCrie um algoritmo que utilize um for com range() para imprimir todo os números de 1 a 10.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nSolução (Python)Pseudocódigo\n\n\n\n# estrutura de repetição que vai de 1 a 10\nfor i in range(1, 11):\n    # exibir cada número\n    print(i)\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n    PARA i ← 1 ATÉ 10 FAÇA\n        ESCREVA i\n    FIM PARA\nFIM\n\n\n\n\n\n\n\n\nExercício 4\nCrie um algoritmo que utilize um for com range() para imprimir todo os números de 10 a 1, em ordem decrescente.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nSolução (Python)Pseudocódigo\n\n\n\n# estrutura de repetição que vai de 10 a 1\nfor i in range(10, 0, -1):\n    # exibir cada número\n    print(i)\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n    PARA i ← 10 ATÉ 1 PASSO -1 FAÇA\n        ESCREVA i\n    FIM PARA\nFIM\n\n\n\n\n\n\n\n\nExercício 5\nAdapte a resposta do exercício 4 para que o ponto de início da contagem regressiva seja um número escolhido pelo usuário. Ou seja, seu código deve perguntar um número ao usuário e contar regressivamente até 1 a partir do número informado.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nSolução (Python)Pseudocódigo\n\n\n\n# inicializar o número com a entrada do usuário\nnumero = int(input('Digite um número inteiro: '))\n\n# estrutura de repetição que vai de numero até 1 \nfor i in range(numero, 0, -1):\n    # exibir o número\n    print(i)\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n    ESCREVA 'Digite um número inteiro: '\n    LEIA numero\n\n    PARA i ← numero ATÉ 1 PASSO -1 FAÇA\n        ESCREVA i\n    FIM PARA\nFIM\n\n\n\n\n\n\n\n\nExercício 6\nUtilize alguma estrutura de repetição para somar os números de 1 até 10 e depois escrever o resultado desta operação.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nSolução (Python)Pseudocódigo\n\n\n\n# inicializar a soma como 0\nsoma: int = 0\n\n# estrutura de repetição que vai de 1 a 10\nfor i in range(1, 11):\n    # adicionar cada número à soma\n    soma += i\n\n# exibir o resultado final\nprint('O resultado da soma é: ', soma)\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n    soma ← 0\n\n    PARA i ← 1 ATÉ 10 FAÇA\n        soma ← soma + i\n    FIM PARA\n\n    ESCREVA \"O resultado da soma é: \", soma\nFIM\n\n\n\n\n\n\n\n\nExercício 7\nDada a seguinte lista:\n\nlista: list = [\"elemento 1\", \"elemento 2\", \"elemento 3\"]\n\nFaça um programa capaz de imprimir os elementos e suas posições, com indexação de computador. Ou seja, a saída esperada para a lista acima é:\n0 elemento 1\n1 elemento 2\n2 elemento 3\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nSolução (Python)Pseudocódigo\n\n\nCódigo isolado (sem a definição da lista):\n\n# estrutura de repetição que vai de 0 a 2\nfor i in range(0, 3):\n    # exibir o índice e o elemento no índice\n    print(i, lista[i])\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n    PARA i ← 0 ATÉ 2 FAÇA\n        ESCREVA i, lista[i]\n    FIM PARA\nFIM\n\n\n\n\n\n\n\n\nExercício 8\nUse uma estrutura do tipo for each para contar a quantidade de letras em uma palavra digitada pelo usuário (lembre-se da função input()).\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nSolução (Python)Pseudocódigo\n\n\n\n# adquirir a palavra\npalavra: str = input('Insira uma palavra: ')\n\n# incializar o contador com 0\ncontador: int = 0\n\n# estrutura de repetição para cada letra na palavra\nfor letra in palavra:\n    # incrementar o contador a cada letra\n    contador += 1\n\n# exibir o resultado\nprint(contador)\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n    LER palavra\n    contador ← 0\n\n    PARA CADA letra EM palavra FAÇA\n        contador ← contador + 1\n    FIM PARA\n\n    escrever contador\nFIM\n\n\n\n\n\n\n\n\nExercício 9\nDada a seguinte lista:\n\nnumeros = [10, 20, 30, 40, 50]\n\n\nEscreva um código que seja capaz de imprimir cada valor da lista multiplicado por 2.\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nSolução (Python)Pseudocódigo\n\n\n\n# declaração da lista\nnumeros = [10, 20, 30, 40, 50]\n\n# estrutura de repetição que passa por cada número\nfor numero in numeros:\n    # exibir o número multiplicado por 2\n    print(numero * 2)\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n    numeros ← [10, 20, 30, 40, 50]\n\n    PARA CADA numero EM numeros FAÇA\n        escrever (numero * 2)\n    FIM PARA\nFIM\n\n\n\n\n\n\n\nAdapate o código para que ele altere os valores na lista (e depois imprima a lista toda)\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nSolução (Python)Pseudocódigo\n\n\n\n# declaração da lista\nnumeros = [10, 20, 30, 40, 50]\n\n# declaração de uma variável auxiliar\nquantidade_de_numeros: int = 5\n\n# estrutura de repetição que percorre toda a lista\nfor i in range(quantidade_de_numeros):\n    # alterar cada posição pelo seu valor vezes 2\n    numeros[i] = numeros[i] * 2\n\n# exibir o resultado final\nprint(numeros)\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n    numeros ← [10, 20, 30, 40, 50]\n    quantidade_de_numeros ← 5\n\n    PARA i DE 0 ATÉ quantidade_de_numeros - 1 FAÇA\n        numeros[i] ← numeros[i] * 2\n    FIM PARA\n\n    escrever numeros\nFIM\n\n\n\n\n\n\n\n\nExercício 10\n\nCrie um programa que leia um número n e imprima os números de 1 até n (não inclui n), mas apenas os que sejam múltiplos de 2.\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nSolução (Python)Pseudocódigo\n\n\n\n# ler o número n\nn: int = int(input('Insira um número: '))\n\n# estrutura de repetição que percorre valores de 0 até n, de 2 em 2\nfor i in range(0, n, 2):\n    # imprimir o número\n    print(i)\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n    ler n\n\n    PARA i DE 0 ATÉ n PASSO 2 FAÇA\n        escrever i\n    FIM PARA\nFIM\n\n\n\n\n\n\n\n\nAdapate o programa para incluir n.\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nSolução (Python)Pseudocódigo\n\n\n\n# ler o número n\nn: int = int(input('Insira um número: '))\n\n# estrutura de repetição que percorre valores de 0 até n + 1, de 2 em 2\nfor i in range(0, n + 1, 2):\n    # imprimir o número\n    print(i)\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n    ler n\n\n    PARA i DE 0 ATÉ n PASSO 2 FAÇA\n        escrever i\n    FIM PARA\nFIM\n\n\n\n\n\n\n\n\nExercício 11\nUtilizando um while, exiba a contagem de 1 a 20.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nSolução (Python)Pseudocódigo\n\n\n\n# inicializar o contador com 1\ncontador: int = 1\n\n# estrutura de repetição que para quanto contador é maior que 20\nwhile (contador &lt;= 20):\n    # exibir o contador\n    print(contador)\n\n    # incrementar o contador\n    contador += 1\n\nExecute este código na sua máquina!\n\n\nINÍCIO\n    contador ← 1\n\n    ENQUANTO contador ≤ 20 FAÇA\n        escrever contador\n        contador ← contador + 1\n    FIM ENQUANTO\nFIM\n\n\n\n\n\n\n\n\nExercício 12\nPeça ao usuário uma palavra e repita-a 5 vezes, usando while.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nSolução (Python)Pseudocódigo\n\n\n\n# receber a palavra\npalavra: str = input('Insira um palavra: ')\n\n# inicializar o contador de impressões da palavra\ncontador_palavra: int = 0\n\n# estrutura while para repetir isto 5 vezes\nwhile contador_palavra &lt; 5:\n    # exibir a palavra\n    print(palavra)\n\n    # incrementar o contador\n    contador_palavra += 1\n\nÉ importante destacar que isto também pode ser feito incializando contador_palavra com o valor 1 e utilizando uma condição no while de &lt;= 5.\nExecute este código na sua máquina!\n\n\nINÍCIO\n    ler palavra\n    contador_palavra ← 0\n\n    ENQUANTO contador_palavra &lt; 5 FAÇA\n        escrever palavra\n        contador_palavra ← contador_palavra + 1\n    FIM ENQUANTO\nFIM",
    "crumbs": [
      "Introdução",
      "Estruturas de repetição em python"
    ]
  },
  {
    "objectID": "introducao/IntroducaoAProgramacao.html",
    "href": "introducao/IntroducaoAProgramacao.html",
    "title": "Introdução A Programação",
    "section": "",
    "text": "As variáveis são elementos fundamentais da programação e da computação. Elas funcionam como “caixinhas” que armazenam informações que podem ser usadas e alteradas durante a execução de um programa. Cada variável tem um nome que a identifica e permite que o computador e o programador acessem o valor guardado. Sem variáveis, seria impossível manipular dados de forma dinâmica ou realizar cálculos que dependem de entradas diferentes.\nCada variável também possui um tipo, que define o tipo de dado que ela pode armazenar. Por exemplo, existem variáveis do tipo inteiro, que guardam números sem casas decimais; variáveis do tipo ponto flutuante, que armazenam números com decimais; e variáveis do tipo string, que contêm textos. Escolher o tipo correto para cada variável é importante, porque influencia como o computador interpreta e processa a informação.\nAs variáveis funcionam armazenando valores na memória do computador. Quando um programa atribui um valor a uma variável, o computador reserva um espaço de memória para guardar esse dado. Esse espaço é identificado por um endereço, que é uma espécie de “localização” dentro da memória. Cada variável, portanto, além de possuir um nome e um valor, também está associada a um endereço específico, que indica exatamente onde seu conteúdo está guardado fisicamente na memória do sistema. Esse endereço é representado por um número único, e é através dele que o processador consegue acessar, ler e modificar o valor da variável.\nO conceito de endereço de memória é essencial para entender como o computador realmente manipula dados. Embora, em linguagens de alto nível como Python, C# ou Java, o programador normalmente não precise lidar diretamente com endereços, em linguagens de baixo nível como C ou Assembly é possível (e muitas vezes necessário) trabalhar com esses endereços usando ponteiros. Um ponteiro é uma variável especial que armazena o endereço de outra variável, permitindo acesso indireto aos dados. Essa abordagem é extremamente poderosa, pois permite manipular memória de forma eficiente, criar estruturas dinâmicas como listas ligadas e otimizar o desempenho de programas que exigem alto controle sobre os recursos de hardware.\nDurante a execução do programa, o valor da variável pode ser alterado, lido ou usado em cálculos e decisões. Essa capacidade de armazenar e modificar dados permite que programas sejam flexíveis e realizem tarefas complexas de forma automatizada. Quando uma variável é modificada, o novo valor é gravado no mesmo endereço de memória, substituindo o anterior. No entanto, em algumas linguagens, como Python, certas variáveis são imutáveis (como strings e tuplas), e nesse caso, uma nova área de memória é alocada para armazenar o novo valor, enquanto o endereço antigo é descartado pelo gerenciador de memória.\nAlém disso, variáveis permitem que algoritmos sejam reutilizáveis. Em vez de escrever um código diferente para cada valor, o programador usa variáveis para representar dados que podem mudar. Por exemplo, em um programa que calcula a média de duas notas, as variáveis podem armazenar as notas dos alunos, e o mesmo algoritmo funciona para qualquer conjunto de valores, tornando o código mais eficiente e organizado.\nPor fim, compreender variáveis é essencial para entender como programas funcionam. Elas são a base para estruturas mais complexas, como listas, matrizes e objetos, que armazenam múltiplos valores e permitem manipulações avançadas de dados. Saber como criar, nomear e usar variáveis corretamente — e compreender que por trás de cada uma delas existe um endereço físico na memória — é um passo fundamental para qualquer pessoa que queira aprender programação ou entender o funcionamento de computadores em um nível mais profundo.\n\n\nVariáveis de conjunto são tipos de variáveis que têm a função de representar uma coleção de elementos, nos quais cada elemento individual pode ser considerado, por si só, uma variável com valor próprio. Diferentemente de variáveis simples, que armazenam um único dado, as variáveis de conjunto permitem agrupar múltiplos itens sob um mesmo nome, facilitando operações coletivas como iteração, adição, remoção e consulta de elementos. Elas são especialmente úteis quando se deseja trabalhar com grupos de dados relacionados, permitindo manipular toda a coleção de forma organizada, enquanto ainda se mantém a possibilidade de acessar e modificar cada item individualmente. Exemplos típicos de variáveis de conjunto incluem listas, tuplas, arrays, conjuntos e dicionários em linguagens de programação modernas, cada um oferecendo características específicas como ordenação, mutabilidade ou unicidade dos elementos.",
    "crumbs": [
      "Introdução",
      "Introdução A Programação"
    ]
  },
  {
    "objectID": "introducao/IntroducaoAProgramacao.html#variáveis",
    "href": "introducao/IntroducaoAProgramacao.html#variáveis",
    "title": "Introdução A Programação",
    "section": "",
    "text": "As variáveis são elementos fundamentais da programação e da computação. Elas funcionam como “caixinhas” que armazenam informações que podem ser usadas e alteradas durante a execução de um programa. Cada variável tem um nome que a identifica e permite que o computador e o programador acessem o valor guardado. Sem variáveis, seria impossível manipular dados de forma dinâmica ou realizar cálculos que dependem de entradas diferentes.\nCada variável também possui um tipo, que define o tipo de dado que ela pode armazenar. Por exemplo, existem variáveis do tipo inteiro, que guardam números sem casas decimais; variáveis do tipo ponto flutuante, que armazenam números com decimais; e variáveis do tipo string, que contêm textos. Escolher o tipo correto para cada variável é importante, porque influencia como o computador interpreta e processa a informação.\nAs variáveis funcionam armazenando valores na memória do computador. Quando um programa atribui um valor a uma variável, o computador reserva um espaço de memória para guardar esse dado. Esse espaço é identificado por um endereço, que é uma espécie de “localização” dentro da memória. Cada variável, portanto, além de possuir um nome e um valor, também está associada a um endereço específico, que indica exatamente onde seu conteúdo está guardado fisicamente na memória do sistema. Esse endereço é representado por um número único, e é através dele que o processador consegue acessar, ler e modificar o valor da variável.\nO conceito de endereço de memória é essencial para entender como o computador realmente manipula dados. Embora, em linguagens de alto nível como Python, C# ou Java, o programador normalmente não precise lidar diretamente com endereços, em linguagens de baixo nível como C ou Assembly é possível (e muitas vezes necessário) trabalhar com esses endereços usando ponteiros. Um ponteiro é uma variável especial que armazena o endereço de outra variável, permitindo acesso indireto aos dados. Essa abordagem é extremamente poderosa, pois permite manipular memória de forma eficiente, criar estruturas dinâmicas como listas ligadas e otimizar o desempenho de programas que exigem alto controle sobre os recursos de hardware.\nDurante a execução do programa, o valor da variável pode ser alterado, lido ou usado em cálculos e decisões. Essa capacidade de armazenar e modificar dados permite que programas sejam flexíveis e realizem tarefas complexas de forma automatizada. Quando uma variável é modificada, o novo valor é gravado no mesmo endereço de memória, substituindo o anterior. No entanto, em algumas linguagens, como Python, certas variáveis são imutáveis (como strings e tuplas), e nesse caso, uma nova área de memória é alocada para armazenar o novo valor, enquanto o endereço antigo é descartado pelo gerenciador de memória.\nAlém disso, variáveis permitem que algoritmos sejam reutilizáveis. Em vez de escrever um código diferente para cada valor, o programador usa variáveis para representar dados que podem mudar. Por exemplo, em um programa que calcula a média de duas notas, as variáveis podem armazenar as notas dos alunos, e o mesmo algoritmo funciona para qualquer conjunto de valores, tornando o código mais eficiente e organizado.\nPor fim, compreender variáveis é essencial para entender como programas funcionam. Elas são a base para estruturas mais complexas, como listas, matrizes e objetos, que armazenam múltiplos valores e permitem manipulações avançadas de dados. Saber como criar, nomear e usar variáveis corretamente — e compreender que por trás de cada uma delas existe um endereço físico na memória — é um passo fundamental para qualquer pessoa que queira aprender programação ou entender o funcionamento de computadores em um nível mais profundo.\n\n\nVariáveis de conjunto são tipos de variáveis que têm a função de representar uma coleção de elementos, nos quais cada elemento individual pode ser considerado, por si só, uma variável com valor próprio. Diferentemente de variáveis simples, que armazenam um único dado, as variáveis de conjunto permitem agrupar múltiplos itens sob um mesmo nome, facilitando operações coletivas como iteração, adição, remoção e consulta de elementos. Elas são especialmente úteis quando se deseja trabalhar com grupos de dados relacionados, permitindo manipular toda a coleção de forma organizada, enquanto ainda se mantém a possibilidade de acessar e modificar cada item individualmente. Exemplos típicos de variáveis de conjunto incluem listas, tuplas, arrays, conjuntos e dicionários em linguagens de programação modernas, cada um oferecendo características específicas como ordenação, mutabilidade ou unicidade dos elementos.",
    "crumbs": [
      "Introdução",
      "Introdução A Programação"
    ]
  },
  {
    "objectID": "introducao/IntroducaoAProgramacao.html#tipos-básicos-de-variáveis",
    "href": "introducao/IntroducaoAProgramacao.html#tipos-básicos-de-variáveis",
    "title": "Introdução A Programação",
    "section": "Tipos básicos de variáveis",
    "text": "Tipos básicos de variáveis\n\nTipos básicos de variáveis simples\n\nInteiro: Geralmente denominado como tipo int (do inglês integer), o tipo inteiro é a representação de um número que não contém nenhuma parte decimal, seja este número 0, positivo ou negativo.\n\nExemplos: 0, 45, -3, 56, 28, 1024, 77\n\nNúmero não-inteiro: Geralmente denominado como tipo float (do inglês *floating point number), os números float são representações de números que podem possuir uma parte decimal diferente de 0.\n\nExemplos: 0.0, 45.4, -3.2, 56.0, -90.1, 1024.002, 77.4\n\nValor booleano: Geralmente denominado como tipo bool (do nome George Boole, um dos primeiros que descreveu estes valores na álgebra booleana), um valor booleano é um valor binário, que pode ser verdadeiro ou falso (representados na memória como 0 ou 1).\n\nExemplo: True, False, 0, 1\n\n\n\n\nTipos básicos de variáveis de conjunto\n\nSequência de caracteres: Geralmente denominado como string, as sequências de caracteres são a maneira com que um computador guarda as representações e trechos de um texto.\n\nExemplos: “Olá”, “Muito obrigado!”, “先生”\n\n\n\n\n\n\n\nNoteObservações importantes\n\n\n\n\nUma string é geralmente definida como caracteres entre aspas duplas (““), mas em Python podemos escolher utilizar (”“) ou (’’).\nUma string pode conter números, inclusive, uma string pode ser apenas números, mas a string “5” não é a mesma coisa que o inteiro 5.\n\n\n\nLista: geralmente denominado como list(do inglês list), uma lista simples é nada mais do que uma coleção de elementos armazenados em posições de memória sequncial, como uma verdadeira lista de elementos reais, um atrás do outro.\n\nExemplo: lista_de_inteiros = [1, 3, 5, 2, 3, 4], lista_de_booleanos = [True, False, False, True]\n\nDicionários: geralmente denominados como dict (do inglês dictionary), o princípio de funcionamento de um dicionário é associar a cada elemento uma chave, armazenando então pares de chave-valor, onde a todas as chaves são únicas.\n\nExemplo: dict_materias_notas = {“Cálculo 1” : 86, “GAAL”: 80, “PDS 1” : 79}\n\n\n\n\n\n\n\nNoteObservação importante\n\n\n\nNo exemplo acima, temos um dict que associa à cada nome de matéria (representado como uma string) uma nota (representado como um núnero inteiro).",
    "crumbs": [
      "Introdução",
      "Introdução A Programação"
    ]
  },
  {
    "objectID": "introducao/IntroducaoAProgramacao.html#operadores",
    "href": "introducao/IntroducaoAProgramacao.html#operadores",
    "title": "Introdução A Programação",
    "section": "Operadores",
    "text": "Operadores\nEm programação, operadores são símbolos ou palavras reservadas que indicam ao computador que deve realizar uma operação sobre um ou mais valores ou variáveis. Eles são fundamentais para manipular dados e construir expressões que produzem novos resultados. De maneira geral, os operadores podem ser classificados em várias categorias, como aritméticos (soma, subtração, multiplicação, divisão), de atribuição (armazenamento e atualização de valores em variáveis), de comparação (igualdade, desigualdade, maior ou menor) e lógicos (combinação de expressões booleanas usando “e”, “ou” e “não”), além de operadores específicos da linguagem, como incremento e decremento. Um ponto importante é que o mesmo operador pode se comportar de maneira diferente dependendo do tipo de dado com que está trabalhando. Por exemplo, o operador de adição (+) realiza a soma de números inteiros ou de ponto flutuante, mas quando aplicado a sequências de caracteres (string), ele realiza a concatenação, unindo textos em vez de somar valores numéricos. Essa flexibilidade permite que os operadores sejam usados de forma intuitiva em diferentes contextos, mas também exige atenção do programador para evitar resultados inesperados. Em resumo, os operadores são a base das manipulações de dados, cálculos e tomadas de decisão em qualquer programa, adaptando-se ao tipo de variável para realizar a operação mais apropriada.\n\nOperadores aritiméticos\n\n+ (Adição) — Soma dois valores numéricos, retornando o resultado da operação matemática básica de adição.\n\nSeja a uma variável do tipo inteiro (int) e b outra variável do tipo inteiro (int), é possível somar ambas as variáveis utilizando o operador + da seguinte maneira: a + b.\n\n- (Subtração) — Subtrai o segundo valor do primeiro, retornando a diferença entre os dois operandos.\n\nSeja a uma variável do tipo inteiro (int) e b outra variável do tipo inteiro (int), é possível subtrair b de a utilizando o operador - da seguinte maneira: a - b.\n\n* (Multiplicação) — Multiplica dois valores, retornando o produto da operação de multiplicação.\n\nSeja a uma variável do tipo inteiro (int) e b outra variável do tipo inteiro (int), é possível multiplicar a por b utilizando o operador * da seguinte maneira: a * b.\n\n/ (Divisão) — Divide o primeiro valor pelo segundo, retornando o quociente da operação de divisão.\n\nSeja a uma variável do tipo inteiro (int) e b outra variável do tipo inteiro (int), é possível dividir a por b utilizando o operador / da seguinte maneira: a / b.\n\n% (Módulo) — Retorna o resto da divisão inteira entre dois números, útil para verificar divisibilidade.\n\nSeja a uma variável do tipo inteiro (int) e b outra variável do tipo inteiro (int), é possível realizar a operação de a módulo b utilizando o operador % da seguinte maneira: a % b.\n\n** (Exponenciação) — Eleva o primeiro número à potência do segundo, calculando valores exponenciais.\n\nSeja a uma variável do tipo inteiro (int) e b outra variável do tipo inteiro (int), é possível calcular a^b utilizando o operador ** da seguinte maneira: a ** b.\n\n// (Divisão inteira) — Divide dois números e retorna apenas a parte inteira do resultado, descartando decimais.\n\nSeja a uma variável do tipo inteiro (int) e b outra variável do tipo inteiro (int), é possível descobrir o resultado da divisão inteira de a por b utilizando o operador // da seguinte maneira: a // b.\n\n\n\n\nOperadores de atribuição\n\n= (Atribuição simples) — Atribui um valor a uma variável.\n\nSeja a uma variável, é possível atribuir a ela um valor utilizando o operador = da seguinte maneira:\na = 10\nApós essa operação, a variável a passa a conter o valor 10.\n\n+= (Atribuição com adição) — Soma o valor atual da variável a outro valor e armazena o resultado na própria variável.\n\nSeja a uma variável com valor 5, é possível realizar:\na += 3\nIsso é equivalente a a = a + 3, resultando em a = 8.\n\n-= (Atribuição com subtração) — Subtrai um valor do conteúdo atual da variável e armazena o resultado.\n\nSeja a uma variável com valor 10, ao executar:\na -= 4\nÉ equivalente a a = a - 4, resultando em a = 6.\n\n*= (Atribuição com multiplicação) — Multiplica o valor atual da variável por outro valor e guarda o resultado na mesma variável.\n\nExemplo:\na = 2\na *= 5\nÉ equivalente a a = a * 5, resultando em a = 10.\n\n/= (Atribuição com divisão) — Divide o valor atual da variável por outro valor e guarda o resultado (como número de ponto flutuante).\n\nExemplo:\na = 10\na /= 4\nÉ equivalente a a = a / 4, resultando em a = 2.5.\n\n//= (Atribuição com divisão inteira) — Divide o valor atual da variável por outro valor e guarda apenas a parte inteira do resultado.\n\nExemplo:\na = 10\na //= 3\nÉ equivalente a a = a // 3, resultando em a = 3.\n\n%= (Atribuição com módulo) — Calcula o resto da divisão inteira e armazena o resultado na própria variável.\n\nExemplo:\na = 10\na %= 4\nÉ equivalente a a = a % 4, resultando em a = 2.\n\n**= (Atribuição com exponenciação) — Eleva o valor atual da variável a uma potência e guarda o resultado.\n\nExemplo:\na = 3\na **= 2\nÉ equivalente a a = a ** 2, resultando em a = 9.\n\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nOs operadores de atribuição combinada (+=, -=, *=, etc.) tornam o código mais conciso e legível, permitindo realizar uma operação e reatribuir o resultado à mesma variável em uma única instrução.\n\n\n\n\nOperadores de comparação\n\n== (Igual a) — Verifica se dois valores são iguais. Retorna True se forem iguais, caso contrário, retorna False.\n\nExemplo:\na = 5\nb = 5\na == b resulta em True.\n\n!= (Diferente de) — Verifica se dois valores são diferentes. Retorna True se forem diferentes, caso contrário, False.\n\nExemplo:\na = 5\nb = 3\na != b resulta em True.\n\n&gt; (Maior que) — Verifica se o valor à esquerda é maior que o valor à direita.\n\nExemplo:\na = 10\nb = 7\na &gt; b resulta em True.\n\n&lt; (Menor que) — Verifica se o valor à esquerda é menor que o valor à direita.\n\nExemplo:\na = 4\nb = 9\na &lt; b resulta em True.\n\n&gt;= (Maior ou igual a) — Verifica se o valor à esquerda é maior ou igual ao valor à direita.\n\nExemplo:\na = 6\nb = 6\na &gt;= b resulta em True.\n\n&lt;= (Menor ou igual a) — Verifica se o valor à esquerda é menor ou igual ao valor à direita.\n\nExemplo:\na = 3\nb = 8\na &lt;= b resulta em True.\n\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nOs operadores de comparação são usados para comparar valores e retornam sempre um resultado booleano (True ou False). Eles são amplamente utilizados em expressões condicionais, como nas instruções if, while e nas compreensões de listas.\n\n\n\n\nOperadores lógicos\n\nand (E lógico) — Retorna True se ambas as condições forem verdadeiras; caso contrário, retorna False.\n\nSeja a uma variável booleana (bool) e b outra variável booleana (bool), é possível combinar as duas condições utilizando o operador lógico and da seguinte maneira:\na and b\n\n\nExemplo: se a = True e b = False, então a and b resulta em False.\n\nor (OU lógico) — Retorna True se pelo menos uma das condições for verdadeira; retorna False apenas se todas forem falsas.\n\nSeja a uma variável booleana (bool) e b outra variável booleana (bool), é possível combinar as duas condições utilizando o operador lógico or da seguinte maneira:\na or b\n\n\nExemplo: se a = True e b = False, então a or b resulta em True.\n\nnot (NÃO lógico) — Inverte o valor lógico de uma expressão. Se a condição for True, retorna False; se for False, retorna True.\n\nSeja a uma variável booleana (bool), é possível inverter seu valor utilizando o operador lógico not da seguinte maneira:\nnot a\n\n\nExemplo: se a = False, então not a resulta em True.\n\n\n\n\nOperadores de acesso a variáveis de coleção\nComo dito anteriormente, coleções como sequências de caracteres, listas e dicionários são tipos de variáveis que armazenam múltiplos valores. Para utilizar esses valores, precisamos acessá-los de maneira direta. Cada tipo de coleção possui uma forma específica de acesso:\n\nStrings\nVariáveis do tipo string são sequências de caracteres organizadas de forma ordenada e indexada, muito parecidas com listas, mas voltadas para textos. Cada caractere da string pode ser acessado individualmente utilizando colchetes [ ] com o índice desejado:\n\nExemplo: Seja texto uma string com n caracteres. Para recuperar o caractere na posição i, utiliza-se texto[i].\n\n\n\n\n\n\n\nNoteObservação importante\n\n\n\nOs índices em strings também começam em 0 e vão até o comprimento da string menos 1. Por exemplo, se texto = “Python”:\n\nO primeiro caractere ‘P’ é acessado com texto[0].\nO segundo caractere ‘y’ é acessado com texto[1].\nO último caractere ‘n’ é acessado com texto[5], pois a string tem 6 caracteres.\n\nEm suma:\n\nAcessar o primeiro caractere de uma string com n caracteres -&gt; texto[0].\nAcessar o último caractere de uma string com n caracteres -&gt; texto[n-1].\n\n\n\n\n\nListas\nlistas (list) organizam elementos em uma ordem sequencial, numerada a partir do índice 0. Para acessar um elemento específico, usamos colchetes [ ] com o índice desejado:\n\nExemplo: Seja A uma lista com n elementos. Para recuperar algum elemento na posição i, utiliza-se o operador de acesso em A, ou seja A[i].\n\n\n\n\n\n\n\nNoteObservação importante\n\n\n\nOs índices de acesso de objetos iteráveis em lingaugens de programação vai de 0 até a quantidade de elementos do objeto iterável - 1. Por exemplo, se A é uma lista com 3 elementos, para acessar o primeiro elemento de A, é utilizado o índice 0, para o segundo elemento o índice 1 e para o último elemento o índice 2. Ou seja, o primeiro elemento é acessado com A[0], o segundo com A[1] e o terceiro (e último) com A[2].\nEm suma:\n\nAcessar o primeiro elemento de uma lista com n elementos -&gt; acessar a lista na posição 0.\nAcessar o último elemento de uma lista com n elementos -&gt; acessar a lista na posição n - 1.\n\n\n\n\n\nDicionários\nDicionários (dict) armazenam valores associados a chaves únicas. Para acessar um valor associado a uma certa chave, utilizamos a chave entre colchetes [ ]:\n\nExemplo: Seja A um dict com um elemento armazenado associado a uma chave c. Para acessaor o elemento p, basta escrever A[c].\n\n\n\n\n\n\n\nNoteObservação\n\n\n\n\nAs chaves podem ser strings, números ou outros tipos imutáveis.\nO acesso é feito diretamente pela chave, não pelo índice.\nEssa forma de acesso é a base para trabalhar com coleções. A partir dela, é possível ler, alterar ou usar os valores em expressões e cálculos.",
    "crumbs": [
      "Introdução",
      "Introdução A Programação"
    ]
  },
  {
    "objectID": "introducao/IntroducaoAProgramacao.html#exercícios",
    "href": "introducao/IntroducaoAProgramacao.html#exercícios",
    "title": "Introdução A Programação",
    "section": "Exercícios",
    "text": "Exercícios\n\nExercício 1\nAssocie cada variável a seguir com um tipo de dado apropriado:\n\n\n\nInformação\nTipo de dado\n\n\n\n\n27\n\n\n\n“Maria”\n\n\n\nVerdadeiro\n\n\n\n8.75\n\n\n\n“Rua das Flores, 120”\n\n\n\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\n\n\n\n\n\n\n\nInformação\nTipo de dado\nExplicação\n\n\n\n\n27\nint\n27 é um número inteiro, portanto o tipo int é adequado\n\n\n“Maria”\nstring\n“Maria” é um texto, portanto o tipo string é adequado\n\n\nVerdadeiro\nbool\nVerdadeiro é um valor booleano, portanto o tipo bool é adequado\n\n\n8.75\nfloat\n8.75 é um valor não inteiro, portanto o tipo float é adequado\n\n\n“Rua das Flores, 120”\nstring\n“Rua das Flores, 120” é um texto, portanto o tipo string é adequado\n\n\n\n\n\n\n\n\nExercício 2\nExplique a diferença entre um tipo int e float.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nO tipo int é utilizado para representar números inteiros, ou seja, números sem casas decimais. Já variáveis do tipo float são utilizadas para representar números que podem ou não conter casas decimais.\n\n\n\n\n\nExercício 3\nPor que é importante escolher o tipo de variável correto em um algoritmo?\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nEscolher o tipo de variável correto é essencial para um algoritmo, pois as variáveis de um programa são exatamente as representações da realidade no computador. Ou seja, escolher tipos de variáveis errados causa representações erradas nos algoritmos implementados.\n\n\n\n\n\nExercício 4\nDê um exemplo de variável de texto e uma variável numérica usadas juntas em um mesmo algoritmo (Não é necessário definir o algoritmo, apenas explicar o que faz).\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nComo o enunciado não especificou o tipo de número, aqui estão soluções com tipo int e float.\n\nExemplos de algoritmos que utilizam os tipos de variável string e int:\n\n\nEx. 1Ex 2.Ex 3\n\n\nUm algoritmo que conta a quantidade de letras que um texto tem. Para implementar este algoritmo, é necessário armazenar o texto (em uma ou mais variáveis do tipo string) e depois utilizar um contador (do tipo int) para passar por todas as letras do texto e contá-las.\n\n\nUm algoritmo que leia o nome e altura de uma pessoa. Para implementar este algoritmo, é necessário armazenar o nome em uma variável do tipo string e a altura em uma variável do tipo float.\n\n\nUm algoritmo que escreve um número inteiro por extenso. Para implementar este algoritmo, é necessário armazenar o número (em uma variável do tipo int) e fazer checagems acerca de seu valor para escrever cada parte dele por extenso (em uma variável do tipo string).\n\n\n\n\n\nExemplos de algoritmos que utilizam os tipos de variável string e float:\n\n\nEx. 1Ex 2.Ex 3\n\n\nUm algoritmo que checa a proporção de espaços para letras em um texto. Para implementar este algoritmo, é necessário armazenar o texto (em uma ou mais variáveis do tipo string) e checar cada posição dele, para descobrir se é uma letra ou espaço, atualizando dois contadores distintos (variáveis do tipo float). Após isto, basta dividir um contador pelo outro para descobrir a proporção corretamente.\n\n\nUm algoritmo que calcula a frequência de uma letra específica em um texto. Para implementar este algoritmo, é necessário armazenar o texto (em uma ou mais variáveis do tipo string), a letra para checar (também uma variável do tipo string) e percorrer o texto, incrementando um contador (uma variável do tipo int) cada vez que a letra específica aparece no texto.\n\n\nUm algoritmo que escreve um número com casas decimais por extenso. Para implementar este algoritmo, é necessário armazenar o número (em uma variável do tipo float) e fazer checagems acerca de seu valor para escrever cada parte dele por extenso (em uma variável do tipo string).\n\n\n\n\n\nExemplo com ambos os tipos:\n\nUm algoritmo que calcula o tamanho médio das palavras em um texto. Para implementar este algoritmo, é necessário armazer o texto (em uma ou mais variáveis do tipo string) e utilizar contadores do tipo ìnt para contar cada tamanho de palavra, adicionando estes valores a uma lista (uma variável do tipo list). Após isto, basta calcular a média dos valores nesta lista, que será um valor do tipo float.\n\n\n\n\n\nExercício 5\nComplete a tabela, indicando se cada expressão a seguir será avaliada como True ou False, dado que A = 7 e B = 8.\n\n\n\nExpressão\nResultado\n\n\n\n\nA = B\n\n\n\nA ≠ B\n\n\n\nA &gt; B\n\n\n\nA &lt; B\n\n\n\nA ≥ B\n\n\n\nA ≤ B\n\n\n\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpressão\nResultado\nExplicação\n\n\n\n\nA = B\nFalse\nO valor de A (7) não é igual ao valor de B (8)\n\n\nA ≠ B\nTrue\nO valor de A (7) é difenre do valor de B (8)\n\n\nA &gt; B\nFalse\nO valor de A (7) não é maior que o valor de B (8)\n\n\nA &lt; B\nTrue\nO valor de A (7) é menor do que o valor de B (8)\n\n\nA ≥ B\nFalse\nO valor de A (7) não é maior ou igual o valor de B (8)\n\n\nA ≤ B\nTrue\nO valor de A (7) é menor ou igual o valor de B (8)\n\n\n\n\n\n\n\n\nExercício 6\nComplete a tabela, indicando o resultado (True ou False) de cada expressão seguinte, considerando que A = True e B = false.\n\n\n\nExpressão\nResultado\n\n\n\n\nA E B\n\n\n\nA OU B\n\n\n\nNÃO A\n\n\n\nNÃO (A OU B)\n\n\n\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpressão\nResultado\nLógica\n\n\n\n\nA E B\nFalse\nTrue E False -&gt; False (operador E retorna True somente se ambos forem True)\n\n\nA OU B\nTrue\nTrue OU False -&gt; True (operador OU retorna True se algum for True)\n\n\nNÃO A\nFalse\nNÃO True -&gt; False (operador NÃO inverte o valor booleano)\n\n\nNÃO (A OU B)\nFalse\nNÃO (True OU False) -&gt; NÃO (True) -&gt; False (operador NÃO inverte o valor booleano)\n\n\n\n\n\n\n\n\nExercício 7\nEm um certo algoritmo, uma variável x (do tipo int) tem valor 20. Preencha a tabela com o novo valor de x após as seguintes atribuições:\n\n\n\nOperação\nNovo valor de x\n\n\n\n\nx = 22\n\n\n\nx += 5\n\n\n\nx -= 3\n\n\n\nx *= 2\n\n\n\nx /= 4\n\n\n\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\n\n\nOperação\nNovo valor de x\nOperação equivalente\n\n\n\n\nx = 22\n22\nx recebe 20 -&gt; x = 20\n\n\nx += 5\n25\nx recebe x + 5 -&gt; x = 20 + 5 -&gt; x = 25\n\n\nx -= 3\n17\nx recebe x - 3 -&gt; x = 20 - 3 -&gt; x = 17\n\n\nx *= 2\n40\nx recebe x * 2 -&gt; x = 20 * 2 -&gt; x = 40\n\n\nx /= 4\n5\nx recebe x / 4 -&gt; x = 20 / 4 -&gt; x = 5\n\n\n\n\n\n\n\n\nExercício 8\nUma escola deseja guardar os nomes dos alunos de uma turma associados a suas notas. Qual tipo de variável é mais adequado para isso?\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nO tipo de variável mais apropriado para esta situação é o dict, pois é possível criar um dict com os nomes dos alunos como chaves e suas notas como valores\n\n\n\n\n\nExercício 9\nUma empresa quer armazenar a lista de funcionários e associar, a cada funcionário, um valor booleano que indica se ele é elegível para receber um certo bônus. O que muda (uma chave ou um valor) se um funcionário anteriormente inélegivel se tornar elegível ao bonus?\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nO que é alterado quando um funcionário torna-se elegível ao bonus é o valor booleano associado à sua chave.\nPor exemplo: Imagine que este é o dict da empresa em um determinado momento:\n\ndict_funcionarios_elegiveis = {‘João’ : False, ‘Roberto’ : True, ‘Leila’ : False, ‘Maria’ : False}\n\nEste dict indica que apenas o Roberto está elegível ao bônus. Agora, imagine que a Maria tambpem tenha se tornado elegível ao bônus, o dict deve ser alterado para o seguinte:\n\ndict_funcionarios_elegiveis = {‘João’ : False, ‘Roberto’ : True, ‘Leila’ : False, ‘Maria’ : True}\n\nOu seja, o valor guardado em dict_funcionarios_elegiveis[‘Maria’] foi alterado de False Para True.\n\n\n\n\n\nExercício 10\nSuponha que existe uma variável de conjunto do tipo list, chamada lista_de_cidades, contendo 5 nomes de cidades (variáveis do tipo string).\n\nComo você faria para identificar a primeira cidade?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nPara indentificar a primeira cidade, basta acessar o primeiro valor da variável lista_de_cidades. Como os índices de acessos à variáveis do tipo list iniciam no 0, para acessar a priemra cidade, deve-se acessar lista_de_cidades[0].\n\n\n\n\n\n\nImportantObservação importante\n\n\n\nO que foi demonstrado aqui não é uma coincidência. Para acessar a primeiro posição de uma lista com n elementos, basta acessar a lista na posição 0.\n\n\n\n\n\n\nE a última?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nComo a variável lista_de_cidades possui 5 elemtos, conseguimos calcular qual o índice que acessa o útlimo elemento.\nPrimeiramente, vamos enumerar todos os 5 elementos da lista:\n\nlista_de_cidades[0]\nlista_de_cidades[1]\nlista_de_cidades[2]\nlista_de_cidades[3]\nlista_de_cidades[4]\n\nAssim, o último elemento da lista está localizado no índice 4, e pode ser acessado com o comando lista_de_cidades[4]\n\n\n\n\n\n\nImportantObservação importante\n\n\n\nO que foi demonstrado aqui não é uma coincidência. Para acessar a última posição de uma lista com n elementos, basta acessar a lista na posição n - 1.\n\n\n\n\n\n\nO que significaria dizer que “cada cidade ocupa uma posição no conjunto”?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nDizer que cada cidade ocupa uma posição na lista significa que cada um destes elementos possui um índice específico (Variando de 0 até 4) que pode ser utilizado para acessá-lo na lista.",
    "crumbs": [
      "Introdução",
      "Introdução A Programação"
    ]
  },
  {
    "objectID": "introducao/Matrizes.html",
    "href": "introducao/Matrizes.html",
    "title": "Matrizes",
    "section": "",
    "text": "Uma matriz é uma estrutura matemática bidimensional composta por linhas e colunas. Cada elemento de uma matriz é identificado por dois índices: o índice da linha (geralmente chamado de \\(i\\)) e o índice da coluna (geralmente chamado de \\(j\\)).\nUma matriz pode ser representada como uma tabela de números, e a sua principal característica é que ela organiza os dados de forma estruturada. A matriz é uma ferramenta amplamente usada em áreas como álgebra linear, computação gráfica, estatísticas, e muitos outros campos da matemática e ciência da computação.\n\nRepresentação de tabelaRepresentação matemática\n\n\n\n\n\n\nColuna 1\nColuna 2\nColuna 3\n\n\n\n\nLinha 1\n1\n2\n3\n\n\nLinha 2\n4\n5\n6\n\n\n\n\n\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6\n\\end{bmatrix}\n\\]\n\n\n\nNeste caso, a matriz tem 2 linhas e 3 colunas. Podemos referir-nos a cada valor dessa tabela através de dois índices: o índice da linha (que nos diz em qual linha o número está) e o índice da coluna (que nos diz em qual coluna o número está).\n\n\nPara acessar um número específico na matriz, usamos um par de índices: o primeiro índice corresponde à linha, e o segundo índice corresponde à coluna.\nVamos ver como funciona com o exemplo acima:\n\nO valor 1 está na primeira linha e na primeira coluna. Logo, podemos referir-se a ele como o elemento (1,1).\nO valor 6 está na segunda linha e na terceira coluna, então ele é o elemento (2,3).\n\nA estrutura de uma matriz pode ser estendida para dimensões maiores (com mais linhas e colunas), dependendo da necessidade, e seu uso é muito comum em várias áreas da matemática e ciência da computação, como:\n\nÁlgebra Linear: Matrizes são fundamentais para resolver sistemas de equações e operações com vetores.\nComputação Gráfica: Para transformar, rotacionar ou redimensionar imagens e objetos em gráficos 3D.\nEstatísticas e Análise de Dados: Para organizar grandes quantidades de dados de maneira tabular, como uma planilha de cálculo.",
    "crumbs": [
      "Introdução",
      "Matrizes"
    ]
  },
  {
    "objectID": "introducao/Matrizes.html#o-que-são-matrizes",
    "href": "introducao/Matrizes.html#o-que-são-matrizes",
    "title": "Matrizes",
    "section": "",
    "text": "Uma matriz é uma estrutura matemática bidimensional composta por linhas e colunas. Cada elemento de uma matriz é identificado por dois índices: o índice da linha (geralmente chamado de \\(i\\)) e o índice da coluna (geralmente chamado de \\(j\\)).\nUma matriz pode ser representada como uma tabela de números, e a sua principal característica é que ela organiza os dados de forma estruturada. A matriz é uma ferramenta amplamente usada em áreas como álgebra linear, computação gráfica, estatísticas, e muitos outros campos da matemática e ciência da computação.\n\nRepresentação de tabelaRepresentação matemática\n\n\n\n\n\n\nColuna 1\nColuna 2\nColuna 3\n\n\n\n\nLinha 1\n1\n2\n3\n\n\nLinha 2\n4\n5\n6\n\n\n\n\n\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6\n\\end{bmatrix}\n\\]\n\n\n\nNeste caso, a matriz tem 2 linhas e 3 colunas. Podemos referir-nos a cada valor dessa tabela através de dois índices: o índice da linha (que nos diz em qual linha o número está) e o índice da coluna (que nos diz em qual coluna o número está).\n\n\nPara acessar um número específico na matriz, usamos um par de índices: o primeiro índice corresponde à linha, e o segundo índice corresponde à coluna.\nVamos ver como funciona com o exemplo acima:\n\nO valor 1 está na primeira linha e na primeira coluna. Logo, podemos referir-se a ele como o elemento (1,1).\nO valor 6 está na segunda linha e na terceira coluna, então ele é o elemento (2,3).\n\nA estrutura de uma matriz pode ser estendida para dimensões maiores (com mais linhas e colunas), dependendo da necessidade, e seu uso é muito comum em várias áreas da matemática e ciência da computação, como:\n\nÁlgebra Linear: Matrizes são fundamentais para resolver sistemas de equações e operações com vetores.\nComputação Gráfica: Para transformar, rotacionar ou redimensionar imagens e objetos em gráficos 3D.\nEstatísticas e Análise de Dados: Para organizar grandes quantidades de dados de maneira tabular, como uma planilha de cálculo.",
    "crumbs": [
      "Introdução",
      "Matrizes"
    ]
  },
  {
    "objectID": "introducao/Matrizes.html#matrizes-em-python",
    "href": "introducao/Matrizes.html#matrizes-em-python",
    "title": "Matrizes",
    "section": "Matrizes em Python",
    "text": "Matrizes em Python\nNo contexto da programação, uma matriz pode ser representada como uma estrutura de dados chamada lista de listas. Essencialmente, você pode pensar em uma lista de listas como uma tabela, onde cada linha da tabela é representada por uma lista, e todas as listas juntas formam a matriz.\nPor exemplo, em Python, uma matriz de 3 linhas e 3 colunas poderia ser representada da seguinte forma:\nMatriz 3x3:\n\nM = [ [1, 2, 3],\n      [4, 5, 6],\n      [7, 8, 9] ]\n\nAqui, a primeira linha é [1, 2, 3], a segunda linha é [4, 5, 6] e a terceira linha é [7, 8, 9].\n\nComo acessar um elemento em uma matriz?\nNa programação, quando queremos acessar um elemento específico de uma matriz, usamos dois índices: o primeiro índice corresponde à linha e o segundo índice à coluna. Esses índices nos permitem “navegar” pela matriz de forma organizada.\nPor exemplo, para acessar o valor 5 da matriz abaixo, precisamos olhar na segunda linha e segunda coluna. Assim, o valor 5 pode ser acessado através dos índices 1 e 1 (lembrando que em Python, as contagens de índices começam a partir de 0).\n\n\n\nÍndices\n0\n1\n2\n\n\n\n\n0\n1\n4\n7\n\n\n1\n2\n5\n8\n\n\n2\n3\n6\n9\n\n\n\nEntão, para acessar o número 5, usamos:\n\nmatriz[1][1]  # Saída: 5\n\nNa linha de código acima:\nmatriz[1] se refere à segunda linha: [4, 5, 6].\nmatriz[1][1] nos dá o segundo elemento da segunda linha, que é 5.\nEste conceito de acessar dados em posições específicas é fundamental quando estamos lidando com grandes conjuntos de dados ou estruturas organizadas.\n\n\nAcessando Elementos de uma Matriz de Forma Generalizada\nComo vimos anteriormente, para acessar elementos de uma matriz, usamos dois índices: o primeiro índice \\(i\\) representa a linha e o segundo índice \\(j\\) representa a coluna. De forma geral, podemos acessar qualquer elemento da matriz M na posição de linha \\(i\\) e coluna \\(j\\) da seguinte forma:\n\nM[i][j]\n\nOnde:\n\n\\(i\\) é o índice da linha, que começa em 0.\n\\(j\\) é o índice da coluna, que também começa em 0.\n\n\nGeneralização para uma Matriz de Qualquer Tamanho\nIndependentemente do tamanho da matriz (seja 2x2, 3x3, 4x4 ou maior), o processo para acessar os elementos permanece o mesmo. Suponhamos que temos uma matriz M de m linhas e n colunas. Para acessar um elemento específico M[i][j]:\n\n\\(i\\) varia de 0 até m-1 (porque os índices começam em 0).\n\\(j\\) varia de 0 até n-1 (também por causa do início do índice em 0).\n\n\nExemplo com uma Matriz 4x3\nConsidere a seguinte matriz 4x3 (com 4 linhas e 3 colunas):\n\\[\n\\text{matriz} = \\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9 \\\\\n10 & 11 & 12\n\\end{bmatrix}\n\\]\nA matriz em Python seria representada como:\n\nmatriz = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n    [10, 11, 12]\n]\n\nAgora, para acessar qualquer posição específica na matriz, basta usar os índices correspondentes.\nPara acessar o valor 5, que está na segunda linha e segunda coluna, usamos:\n\nmatriz[1][1]  # Resultado: 5\n\nPara acessar o valor 8, que está na terceira linha e segunda coluna, usamos:\n\nmatriz[2][1]  # Resultado: 8\n\nPara acessar o valor 12, que está na quarta linha e terceira coluna, usamos:\n\nmatriz[3][2]  # Resultado: 12\n\nEsse padrão se aplica a qualquer matriz, independentemente do seu tamanho.\n\n\n\n\nIteração em Matrizes com Estruturas de Repetição\nAo trabalhar com matrizes, uma das tarefas mais comuns é iterar sobre os elementos para preencher ou ler dados. Como as matrizes têm uma estrutura bidimensional (linhas e colunas), isso implica percorrer as linhas e as colunas de maneira sistemática. Para isso, podemos usar estruturas de repetição como o loop for (ou while) para acessar cada elemento individualmente.\n\nIteração para Preencher uma Matriz\nPara preencher uma matriz, basta utilizar um laço for aninhado: o primeiro laço percorre as linhas e o segundo percorre as colunas. Este processo pode ser útil quando precisamos gerar ou modificar dados em uma matriz.\nExemplo: Preenchendo uma Matriz com Multiplicação de Índices\nVamos preencher uma matriz 3x3 com o produto dos índices das linhas e das colunas. A matriz inicial contém apenas valores 0.\n\n# Definindo uma matriz 3x3 com todos os elementos iguais a 0\nmatriz = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n\n# Preenchendo a matriz com o produto de i e j\nfor i in range(3):  # Laço para as linhas\n    for j in range(3):  # Laço para as colunas\n        matriz[i][j] = i * j  # Preenchendo o elemento na linha i, coluna j\n\n# Exibindo a matriz preenchida\nfor linha in matriz:\n    print(linha)\n\nResultado:\n\n[0, 0, 0]\n[0, 1, 2]\n[0, 2, 4]\n\nExplicação:\n\nO primeiro for percorre as linhas da matriz.\nO segundo for percorre as colunas de cada linha.\nA matriz é preenchida com o produto de \\(i\\) (índice da linha) e \\(j\\) (índice da coluna).\n\n\n\nIteração para Ler os Elementos de uma Matriz\nAgora, vamos ver como podemos ler os dados de uma matriz já preenchida utilizando apenas o laço for.\nExemplo: Lendo uma Matriz 3x3\nAqui, temos uma matriz 3x3 com valores predefinidos. O objetivo é percorrer cada linha e coluna para imprimir o valor de cada elemento.\n\n# Definindo uma matriz 3x3 com valores predefinidos\nmatriz = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# Lendo e imprimindo os elementos da matriz\nfor i in range(3):  # Laço para as linhas\n    for j in range(3):  # Laço para as colunas\n        print(\"Elemento na linha:\", i, \"coluna:\", j, \": \", matriz[i][j])\n\nResultado:\nElemento na linha 0, coluna 0: 1\nElemento na linha 0, coluna 1: 2\nElemento na linha 0, coluna 2: 3\nElemento na linha 1, coluna 0: 4\nElemento na linha 1, coluna 1: 5\nElemento na linha 1, coluna 2: 6\nElemento na linha 2, coluna 0: 7\nElemento na linha 2, coluna 1: 8\nElemento na linha 2, coluna 2: 9\nExplicação:\n\nO primeiro for percorre as linhas da matriz.\nO segundo for percorre as colunas de cada linha.\nA matriz é lida e cada valor é acessado e impresso na tela com a posição de linha e coluna correspondente",
    "crumbs": [
      "Introdução",
      "Matrizes"
    ]
  },
  {
    "objectID": "introducao/Matrizes.html#o-que-uma-matriz-pode-representar",
    "href": "introducao/Matrizes.html#o-que-uma-matriz-pode-representar",
    "title": "Matrizes",
    "section": "O que uma Matriz pode Representar?",
    "text": "O que uma Matriz pode Representar?\nAgora que entendemos como as matrizes são estruturadas e como acessamos seus elementos, vamos explorar alguns exemplos simples de como elas são usadas no mundo real. Matrizes são bastante comuns em diversas áreas, como ciência de dados, computação gráfica, álgebra e muito mais. Vamos ver alguns exemplos de como elas podem ser aplicadas fora da programação.\n\nTabela de Pontuação de Times em um Campeonato\nUma matriz pode ser usada para representar a pontuação de diferentes times em várias rodadas de um campeonato. Cada linha pode corresponder a um time, e as colunas podem representar a pontuação de cada time em diferentes partidas.\nImagine um campeonato com 3 times (Time A, Time B e Time C) e 3 rodadas. A tabela de pontuação ficaria assim:\n\n\n\nTime\nRodada 1\nRodada 2\nRodada 3\n\n\n\n\nTime A\n3\n2\n1\n\n\nTime B\n0\n1\n3\n\n\nTime C\n1\n3\n2\n\n\n\nEm Python, isso poderia ser representado da seguinte forma:\n\npontuacoes = [\n    [3, 2, 1],  # Time A\n    [0, 1, 3],  # Time B\n    [1, 3, 2]   # Time C\n]\n\nExplicação:\n\nCada linha da matriz corresponde a um time (Time A, Time B, Time C).\nCada coluna da matriz representa a pontuação do time em uma rodada do campeonato.\nPara acessar a pontuação do Time A na segunda rodada, por exemplo, podemos acessar o elemento pontuacoes[0][1], que nos dá o valor 2.\n\nEste exemplo mostra como uma matriz pode ser útil para organizar dados de várias variáveis (neste caso, pontuações de diferentes times em diferentes rodadas) de forma compacta e eficiente.\n\n\nRepresentação de Imagens (Preto e Branco)\nEm computação gráfica, as imagens podem ser representadas como matrizes, onde cada célula da matriz é um pixel. Em uma imagem em preto e branco, cada pixel pode ser representado por um valor numérico: 0 para preto e 1 para branco.\nVamos usar uma matriz 3x3 para representar uma imagem simples em preto e branco:\n\n\n\n\nColuna 1\nColuna 2\nColuna 3\n\n\n\n\nLinha 1\n0\n1\n0\n\n\nLinha 2\n1\n0\n1\n\n\nLinha 3\n0\n1\n0\n\n\n\nA representação em Python seria:\n\nimagem_pb = [\n    [0, 1, 0],\n    [1, 0, 1],\n    [0, 1, 0]\n]\n\nExplicação:\n\nCada número na matriz corresponde a um pixel da imagem.\nO valor 0 representa o preto, e o valor 1 representa o branco.\n\nManipular essa matriz, como inverter as cores ou aplicar filtros, pode ser feito facilmente modificando os valores dessa matriz.\n\n\nTabela de Multiplicação\nMatrizes também podem ser usadas para representar a tabela de multiplicação. Em uma matriz 10x10, por exemplo, cada elemento seria o produto de dois números.\nAqui está a tabela de multiplicação de 1 a 3 representada em uma matriz 3x3:\n\n\n\n\nColuna 1\nColuna 2\nColuna 3\n\n\n\n\nLinha 1\n1\n2\n3\n\n\nLinha 2\n2\n4\n6\n\n\nLinha 3\n3\n6\n9\n\n\n\nA matriz em Python seria:\n\ntabela_multiplicacao = [\n    [1, 2, 3],\n    [2, 4, 6],\n    [3, 6, 9]\n]\n\nExplicação:\n\nCada linha e cada coluna representam um número multiplicado por outro.\nPor exemplo, o valor na segunda linha e terceira coluna é 6, que é o produto de 2 * 3.\nEste é um exemplo simples de como as matrizes podem ser usadas para representar tabelas matemáticas e ajudar na visualização de operações matemáticas.\n\n\n\n\n\n\n\nNoteObservação\n\n\n\nApesar de este exemplo ser útil, é importante ressaltar que como índices em python iniciam do 0, seria necessário levar este ajuste em consideração para pensar em cálculos deste tipo de matriz.",
    "crumbs": [
      "Introdução",
      "Matrizes"
    ]
  },
  {
    "objectID": "introducao/Matrizes.html#exercícios",
    "href": "introducao/Matrizes.html#exercícios",
    "title": "Matrizes",
    "section": "Exercícios",
    "text": "Exercícios\n\nExercício 1\nComplete a matriz abaixo com os índices de cada posição (considerando a indexação de python):\n\\[\n\\begin{bmatrix}\n- & - & - \\\\\n- & - & - \\\\\n- & - & -\n\\end{bmatrix}\n\\]\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAs indexações corretas para esta matriz são as seguintes:\n\\[\n\\begin{bmatrix}\n(0, 0) & (0, 1) & (0, 2) \\\\\n(1, 0) & (1, 1) & (1, 2) \\\\\n(2, 0) & (2, 1) & (2, 2)\n\\end{bmatrix}\n\\]\n\n\n\n\n\nExercício 2\nResponda as perguntados considerando a seguinte matriz (e utilizando indexação de python):\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{bmatrix}\n\\]\n\nQual elemento está na posição \\((0, 0)\\)?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\\((0, 0)\\) se refere ao elemento \\(1\\).\n\n\n\n\nQual elemento está na posição \\((2, 1)\\)?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\\((2, 1)\\) se refere ao elemento \\(8\\)\n\n\n\n\nQual é a posição do elemento \\(9\\)?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\\((2, 2)\\)\n\n\n\n\n\nExercício 3\nEscreva em Python a seguinte matriz:\n\\[\n\\begin{bmatrix}\n10 & 20 & 30 \\\\\n40 & 50 & 60 \\\\\n70 & 80 & 90\n\\end{bmatrix}\n\\]\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nmatriz = [\n    [10, 20, 30],\n    [40, 50, 60],\n    [70, 80, 90]\n]\n\n\n\n\n\n\nExercício 4\nEm uma matriz \\(n \\times n\\), responda (considerando indexação de Python):\n\nQual é o índice do elemento localizado na posição mais à direita e mais embaixo da matriz?\nQual é o índice do elemento localizado na posição mais à esquerda e mais acima da matriz?\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nUma matriz \\(n \\times n\\) em Python possui a seguinte indexação:\n\\[\n\\begin{bmatrix}\na_{00} & a_{01} & \\cdots & a_{0(n-1)} \\\\\na_{10} & a_{11} & \\cdots & a_{1(n-1)} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{(n-1)0} & a_{(n-1)1} & \\cdots & a_{(n-1)(n-1)}\n\\end{bmatrix}\n\\]\nPortanto, as respostas são:\n\nO elemento mais a direita e mais embaixo é o elemento com índice \\(((n-1), (n-1))\\):\n\n\\[\n\\begin{bmatrix}\na_{00} & a_{01} & \\cdots & a_{0(n-1)} \\\\\na_{10} & a_{11} & \\cdots & a_{1(n-1)} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{(n-1)0} & a_{(n-1)1} & \\cdots & \\boxed{a_{(n-1)(n-1)}}\n\\end{bmatrix}\n\\]\n\nO elemento mais a esquerda e mais acima da matriz é o elemento com índice \\((0, 0)\\):\n\n\\[\n\\begin{bmatrix}\n\\boxed{a_{00}} & a_{01} & \\cdots & a_{0(n-1)} \\\\\na_{10} & a_{11} & \\cdots & a_{1(n-1)} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{(n-1)0} & a_{(n-1)1} & \\cdots & a_{(n-1)(n-1)}\n\\end{bmatrix}\n\\]\n\n\n\n\n\nExercício 5\nConsiderando a seguinte matriz:\n\\[\n\\text{A} = \\begin{bmatrix}\n1 & 0 & 0 & 0 & 1\\\\\n0 & 1 & 1 & 0 & 1\\\\\n1 & 0 & 0 & 1 & 1\n\\end{bmatrix}\n\\]\n\nDeclare esta matriz em Python\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nA = [\n    [1, 0, 0, 0, 1],\n    [0, 1, 1, 0, 1],\n    [1, 0, 0, 1, 1]\n]\n\n\n\n\n\nEscreva o código em Python que seja capaz de acessar a matriz A na posição \\((0, 0)\\):\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nA[0][0]\n\n\n\n\n\nEscreva o código que seja capaz de acessar a matriz A na posição \\((1, 3)\\):\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\n\nA[1][3]\n\n\n\n\n\n\nExercício 6\nConsidere a seguinte matriz em Python:\n\nM = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12]\n]\n\n\nIndique o resultado da expressão: M[1][2]\nIndique o resultado da expressão: M[2][3]\nIndique o resultado da expressão: M[0][3]\nIndique o resultado da expressão: M[2][0]\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nConsiderando que esta é a matriz M representada:\n\\[\nM = \\begin{bmatrix}\n1 & 2 & 3 & 4 \\\\\n5 & 6 & 7 & 8 \\\\\n9 & 10 & 11 & 12\n\\end{bmatrix}\n\\]\nAqui estão os índices corretos da matriz:\n\\[\nM = \\begin{bmatrix}\n1_{00} & 2_{01} & 3_{02} & 4_{03} \\\\\n5_{10} & 6_{11} & 7_{12} & 8_{13} \\\\\n9_{20} & 10_{21} & 11_{22} & 12_{23}\n\\end{bmatrix}\n\\]\n\nAcessar M[1][2] significa acessar a matriz na linha 1 (começando de 0) e coluna 2 (começando de 0). Aqui está este elemeto:\n\n\\[\nM = \\begin{bmatrix}\n1_{00} & 2_{01} & 3_{02} & 4_{03} \\\\\n5_{10} & 6_{11} & \\boxed{7_{12}} & 8_{13} \\\\\n9_{20} & 10_{21} & 11_{22} & 12_{23}\n\\end{bmatrix}\n\\]\nOu seja, acessar M[1][2] significa acessar o elemento igual a \\(7\\).\n\nAcessar M[2][3] significa acessar a matriz na linha 2 (começando de 0) e coluna 3 (começando de 0). Aqui está este elemeto:\n\n\\[\nM = \\begin{bmatrix}\n1_{00} & 2_{01} & 3_{02} & 4_{03} \\\\\n5_{10} & 6_{11} & 7_{12} & 8_{13} \\\\\n9_{20} & 10_{21} & 11_{22} & \\boxed{12_{23}}\n\\end{bmatrix}\n\\]\nOu seja, acessar M[2][3] significa acessar o elemento igual a \\(12\\).\n\nAcessar M[0][3] significa acessar a matriz na linha 2 (começando de 0) e coluna 3 (começando de 0). Aqui está este elemeto:\n\n\\[\nM = \\begin{bmatrix}\n1_{00} & 2_{01} & 3_{02} & \\boxed{4_{03}} \\\\\n5_{10} & 6_{11} & 7_{12} & 8_{13} \\\\\n9_{20} & 10_{21} & 11_{22} & 12_{23}\n\\end{bmatrix}\n\\]\nOu seja, acessar M[0][3] significa acessar o elemento igual a \\(4\\).\n\nAcessar M[2][0] significa acessar a matriz na linha 2 (começando de 0) e coluna 3 (começando de 0). Aqui está este elemeto:\n\n\\[\nM = \\begin{bmatrix}\n1_{00} & 2_{01} & 3_{02} & 4_{03} \\\\\n5_{10} & 6_{11} & 7_{12} & 8_{13} \\\\\n\\boxed{9_{20}} & 10_{21} & 11_{22} & 12_{23}\n\\end{bmatrix}\n\\]\nOu seja, acessar M[2][0] significa acessar o elemento igual a \\(9\\).\n\n\n\n\nQual será o resultado do seguinte código:\n\n\nprint(M[1])\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nComo na programação uma matriz é nada mais que uma lista de listas (pelo menos por enquanto), acessar a matriz M na posição 1, sem especificar um segundo índice, siginifica acessar uma lista inteira da lista de listas.\nOu seja, o resultado deste código é:\n\n[5, 6, 7, 8]\n\nExecute o código na sua máquina!\n\n\n\n\nEscreva o código de python que altere o elemento \\((0, 0)\\) da matriz M para o valor de 90.\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nPara alterar um elemento da matriz, basta acessá-lo e alterar seu valor, portanto, este é o código que altera o elemento \\((0, 0)\\) para 90:\n\nM[0][0] = 90\n\nExecute o código na sua máquina!\n\n\n\n\n\nExercício 7\nConsidere a seguinte matriz:\n\nM = [\n    [1, 2],\n    [3, 4]\n]\n\n\nEscreva um código que, utilizando duas estruturas de repetição do tipo for com range(), seja capaz de imprimir todos os elementos, ou seja, a saída deve ser:\n\n\n1\n2\n3\n4\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAqui está o código capaz de realizar isto:\n\n# declaração da matriz\nM = [\n    [1, 2],\n    [3, 4]\n]\n\n# declaração de variáveis auxiliares\nquantidade_de_linhas: int = 2\nquantidade_de_colunas: int = 2\n\n# estrutura de repetição para as linhas\nfor i in range(quantidade_de_colunas):\n    # estrutura de repetição para as colunas\n    for j in range(quantidade_de_colunas):\n        # impressão dos elementos\n        print(M[i][j])\n\nExecute este código na sua máquina!\n\n\n\n\nAgora adapte o código para funcionar com duas estruturas de repetição do tipo for each.\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAqui está o código adaptado:\n\n# declaração da matriz\nM = [\n    [1, 2],\n    [3, 4]\n]\n\n# estrutura de repetição para as linhas\nfor linha in M:\n    # estrutura de repetição para os elementos das linhas\n    for elemento in linha:\n        # impressão dos elementos\n        print(elemento)\n\nExecute este código na sua máquina!\n\n\n\n\n\nExercício 8\nConsiderando a seguinte matriz:\n\nA = [\n    [5, 6, 7],\n    [8, 9, 10]\n]\n\nEscreva um código que seja capaz de passar linha a linha desta matriz, imprimindo uma linha inteira cada vez.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAqui está o código capaz de realizar isto:\n\n# declaração da matriz\nA = [\n    [5, 6, 7],\n    [8, 9, 10]\n]\n\n# estrutura para passar pelas linhas da matriz\nfor linha in A:\n    # impressão das linhas\n    print(linha)\n\nExecute este código na sua máquina!\n\n\n\n\n\nExercício 9\nConsiderando a seguinte matriz:\n\nmatriz_valores = [\n    [0, 1],\n    [2, 3]\n]\n\n\nUtilizando estruturas de repetição do tipo for com a função range(), escreva um código que seja capaz de percorrer cada posição da matriz e somar todos os seus valores (ou seja, o resutlado deve ser \\(6\\)).\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAqui está um código capaz de realizar isto:\n\n# declaração da matriz\nmatriz_valores = [\n    [0, 1],\n    [2, 3],\n]\n\n# variáveis auxiliares para clareza do código\nquantidade_de_linhas: int = 2\nquantidade_de_colunas: int = 2\nsoma_total: int = 0\n\n# estrutura de repetição para linhas\nfor i in range(quantidade_de_linhas):\n    # estrutura de repetição para colunas\n    for j in range(quantidade_de_colunas):\n        # adicionar o valor de cada elemento à soma\n        soma_total += matriz_valores[i][j]\n\n# imprimir o valor final da soma\nprint(soma_total)\n\nExecute este código na sua máquina!\n\n\n\n\nAgora adapte o código para que ao ínves de somar todos os números, ele multiplique todos os números (ou seja, o resultado deve ser \\(0\\)).\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAs únicas modificações necessárias são a troca do valor inicial da variável de multiplicação para 1 e a troca do operador += para *=. Aqui está o código adaptado:\n\n# declaração da matriz\nmatriz_valores = [\n    [0, 1],\n    [2, 3],\n]\n\n# variáveis auxiliares para clareza do código\nquantidade_de_linhas: int = 2\nquantidade_de_colunas: int = 2\nmultiplicacao_total: int = 1\n\n# estrutura de repetição para linhas\nfor i in range(quantidade_de_linhas):\n    # estrutura de repetição para colunas\n    for j in range(quantidade_de_colunas):\n        # multiplicar o valor de cada elemento\n        multiplicacao_total *= matriz_valores[i][j]\n\n# imprimir o valor final da soma\nprint(multiplicacao_total)\n\nExecute este código na sua máquina!\n\n\n\n\nAdapte o código do item 2 para utilizar estruturas do tipo for each:\n\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAqui está o código adaptado:\n\n# declaração da matriz\nmatriz_valores = [\n    [0, 1],\n    [2, 3],\n]\n\n# variáveis auxiliares\nmultiplicacao_total: int = 1\n\n# estrutura de repetição para as linhas\nfor linha in matriz_valores:\n    # estrutura de repetição para os elementos das linhas\n    for elemento in linha:\n        # multiplicação dos elementos\n        multiplicacao_total *= elemento\n\n# imprimir o valor final da soma\nprint(multiplicacao_total)\n\nExecute este código na sua máquina!",
    "crumbs": [
      "Introdução",
      "Matrizes"
    ]
  },
  {
    "objectID": "introducao/Matrizes.html#desafio",
    "href": "introducao/Matrizes.html#desafio",
    "title": "Matrizes",
    "section": "Desafio",
    "text": "Desafio\nUma matriz transposta é obtida ao trocar suas linhas por colunas. Em termos formais, cada elemento \\(a_{ij}\\) da matriz original passa a ocupar a posição \\(a_{ji}\\) na matriz transposta.\nPor exemplo, para a matriz:\n\\[\nM = \\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6  \\\\\n7 & 8 & 9\n\\end{bmatrix}\n\\]\nA matriz transposta é:\n\\[\nM^{T} = \\begin{bmatrix}\n1 & 4 & 7 \\\\\n2 & 5 & 8  \\\\\n3 & 6 & 9\n\\end{bmatrix}\n\\]\nGere um código que seja capaz de ler os valores de uma matriz \\(3 \\times 3\\), calcular sua transposta e corretamente imprimir ambas.\n\n\n\n\n\n\nTipVer Solução\n\n\n\n\n\nAqui segue uma possível solução simples:\n\n# declaração da matriz original\nmatriz_original = [\n    [0, 0, 0],\n    [0, 0, 0],\n    [0, 0, 0]\n]\n\n# variáveis auxiliares\nquantidade_de_linhas: int = 3\nquantidade_de_colunas: int = 3\n\n# estrutura de repetição para percorrer as linhas da matriz original\nfor i in range(quantidade_de_linhas):\n    # estrutura de repetição para percorrer as colunas da matriz original\n    for j in range(quantidade_de_colunas):\n        # ler um valor para a posição (i, j)\n        matriz_original[i][j] = int(input('Insira um número: '))\n\n# declaração da matriz que recebera os valores da transposta\nmatriz_transposta = [\n    [0, 0, 0],\n    [0, 0, 0],\n    [0, 0, 0]\n]\n\n# estrutura de repetição para percorrer as linhas da matriz original\nfor i in range(quantidade_de_linhas):\n    # estrutura de repetição para percorrer as colunas da matriz original\n    for j in range(quantidade_de_colunas):\n        # colocar, na posição (j, i) da transposta cada elemento (i, j) da matriz original\n        matriz_transposta[j][i] = matriz_original[i][j]\n\n# percorrer todas as linhas da matriz original\nfor linha in matriz_original:\n    # imprimir cada linha\n    print(linha)\n\n# percorrer todas as linhas da matriz transposta\nfor linha in matriz_transposta:\n    # imprimir cada linha\n    print(linha)",
    "crumbs": [
      "Introdução",
      "Matrizes"
    ]
  },
  {
    "objectID": "introducao/Projeto.html",
    "href": "introducao/Projeto.html",
    "title": "Trabalho Prático 1",
    "section": "",
    "text": "O arquiteto Johanius Mazochus está conduzindo uma pesquisa detalhada sobre o impacto da insolação nas fachadas de diversos edifícios residenciais. O foco de seu estudo são prédios com 10 andares e 3 janelas por andar, nos quais cada janela recebe um nível de insolação variando entre 0 e 10. Para isso, ele coletará dados sobre os níveis de insolação em vários edifícios que seguem esse modelo. O objetivo é analisar os efeitos da insolação em cada edifício, identificar potenciais problemas críticos e fornecer recomendações arquitetônicas para otimizar o aproveitamento da luz natural e melhorar o conforto térmico nas construções.\nPara facilitar essa análise, o arquiteto te contratou para desenvolver um programa que será capaz de realizar as seguintes tarefas: coletar e armazenar as informações de insolação de um edifício dentro do formato especificado e calcular diversas métricas deste edifício a partir dos dados obtidos, fornecendo insights importantes sobre o impacto da insolação em cada caso.",
    "crumbs": [
      "Introdução",
      "Projeto",
      "Trabalho Prático 1"
    ]
  },
  {
    "objectID": "introducao/Projeto.html#entrega",
    "href": "introducao/Projeto.html#entrega",
    "title": "Trabalho Prático 1",
    "section": "Entrega",
    "text": "Entrega\nA entrega do proejto deverá ser realizada através deste link, onde você irá enviar o seu repositório do github. Lembre-se de deixar o respositório do github público.",
    "crumbs": [
      "Introdução",
      "Projeto",
      "Trabalho Prático 1"
    ]
  }
]