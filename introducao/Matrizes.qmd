---
title: "Matrizes"
toc: true
toc-title: "Conteúdos da página"
---

## O que são Matrizes?

Uma matriz é uma estrutura matemática bidimensional composta por linhas e colunas. Cada elemento de uma matriz é identificado por dois índices: o índice da linha (geralmente chamado de $i$) e o índice da coluna (geralmente chamado de $j$).

Uma matriz pode ser representada como uma tabela de números, e a sua principal característica é que ela organiza os dados de forma estruturada. A matriz é uma ferramenta amplamente usada em áreas como álgebra linear, computação gráfica, estatísticas, e muitos outros campos da matemática e ciência da computação.

|         | Coluna 1 | Coluna 2 | Coluna 3 |
| ------- | -------- | -------- | -------- |
| Linha 1 | 1        | 2        | 3        |
| Linha 2 | 4        | 5        | 6        |


Neste caso, a matriz tem 2 linhas e 3 colunas. Podemos referir-nos a cada valor dessa tabela através de dois índices: o índice da linha (que nos diz em qual linha o número está) e o índice da coluna (que nos diz em qual coluna o número está).

### Como acessar os elementos de uma matriz?

Para acessar um número específico na matriz, usamos um par de índices: o primeiro índice corresponde à linha, e o segundo índice corresponde à coluna.

Vamos ver como funciona com o exemplo acima:

* O valor 1 está na primeira linha e na primeira coluna. Logo, podemos referir-se a ele como o elemento (1,1).

* O valor 6 está na segunda linha e na terceira coluna, então ele é o elemento (2,3).

A estrutura de uma matriz pode ser estendida para dimensões maiores (com mais linhas e colunas), dependendo da necessidade, e seu uso é muito comum em várias áreas da matemática e ciência da computação, como:

* Álgebra Linear: Matrizes são fundamentais para resolver sistemas de equações e operações com vetores.

* Computação Gráfica: Para transformar, rotacionar ou redimensionar imagens e objetos em gráficos 3D.

* Estatísticas e Análise de Dados: Para organizar grandes quantidades de dados de maneira tabular, como uma planilha de cálculo.

## Matrizes em Python

No contexto da programação, uma matriz pode ser representada como uma estrutura de dados chamada lista de listas. Essencialmente, você pode pensar em uma lista de listas como uma tabela, onde cada linha da tabela é representada por uma lista, e todas as listas juntas formam a matriz.

Por exemplo, em Python, uma matriz de 3 linhas e 3 colunas poderia ser representada da seguinte forma:

Matriz 3x3:

```{python}
#| eval: false
M = [ [1, 2, 3],
      [4, 5, 6],
      [7, 8, 9] ]
```

Aqui, a primeira linha é [1, 2, 3], a segunda linha é [4, 5, 6] e a terceira linha é [7, 8, 9].

### Como acessar um elemento em uma matriz?

Na programação, quando queremos acessar um elemento específico de uma matriz, usamos dois índices: o primeiro índice corresponde à linha e o segundo índice à coluna. Esses índices nos permitem "navegar" pela matriz de forma organizada.

Por exemplo, para acessar o valor 5 da matriz acima, precisamos olhar na segunda linha e segunda coluna. Assim, o valor 5 pode ser acessado através dos índices 1 e 1 (lembrando que em Python, as contagens de índices começam a partir de 0).

| Índices  | Linha 1 | Linha 2 | Linha 3 |
| -------- | ------- | ------- | ------- |
| Coluna 1 | 1       | 4       | 7       |
| Coluna 2 | 2       | 5       | 8       |
| Coluna 3 | 3       | 6       | 9       |

Então, para acessar o número 5, usamos:

```{python}
#| eval: false
matriz[1][1]  # Saída: 5
```

Aqui:

`matriz[1]` se refere à segunda linha: [4, 5, 6].

`matriz[1][1]` nos dá o segundo elemento da segunda linha, que é 5.

Este conceito de acessar dados em posições específicas é fundamental quando estamos lidando com grandes conjuntos de dados ou estruturas organizadas.

### Acessando Elementos de uma Matriz de Forma Generalizada

Como vimos anteriormente, para acessar elementos de uma matriz, usamos dois índices: o primeiro índice $i$ representa a linha e o segundo índice $j$ representa a coluna. De forma geral, podemos acessar qualquer elemento da matriz M na posição de linha $i$ e coluna $j$ da seguinte forma:

```{python}
#| eval: false
M[i][j]
```

Onde:

* $i$ é o índice da linha, que começa em 0.

* $j$ é o índice da coluna, que também começa em 0.

#### Generalização para uma Matriz de Qualquer Tamanho

Independentemente do tamanho da matriz (seja 2x2, 3x3, 4x4 ou maior), o processo para acessar os elementos permanece o mesmo. Suponhamos que temos uma matriz M de m linhas e n colunas. Para acessar um elemento específico M[i][j]:

* $i$ varia de 0 até m-1 (porque os índices começam em 0).

* $j$ varia de 0 até n-1 (também por causa do início do índice em 0).

##### Exemplo com uma Matriz 4x3

Considere a seguinte matriz 4x3 (com 4 linhas e 3 colunas):

|         | Coluna 1 | Coluna 2 | Coluna 3 |
| ------- | -------- | -------- | -------- |
| Linha 1 | 1        | 2        | 3        |
| Linha 2 | 4        | 5        | 6        |
| Linha 3 | 7        | 8        | 9        |
| Linha 4 | 10       | 11       | 12       |


A matriz em Python seria representada como:

```{python}
#| eval: false
matriz = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
    [10, 11, 12]
]
```

Agora, para acessar qualquer posição específica na matriz, basta usar os índices correspondentes.

Para acessar o valor 5, que está na segunda linha e segunda coluna, usamos:

```{python}
#| eval: false
matriz[1][1]  # Resultado: 5
```


Para acessar o valor 8, que está na terceira linha e segunda coluna, usamos:

```{python}
#| eval: false
matriz[2][1]  # Resultado: 8
```


Para acessar o valor 12, que está na quarta linha e terceira coluna, usamos:

```{python}
#| eval: false
matriz[3][2]  # Resultado: 12
```

Esse padrão se aplica a qualquer matriz, independentemente do seu tamanho.

### Iteração em Matrizes com Estruturas de Repetição

Ao trabalhar com matrizes, uma das tarefas mais comuns é iterar sobre os elementos para preencher ou ler dados. Como as matrizes têm uma estrutura bidimensional (linhas e colunas), isso implica percorrer as linhas e as colunas de maneira sistemática. Para isso, podemos usar estruturas de repetição como o *loop* for (ou while) para acessar cada elemento individualmente.

#### Iteração para Preencher uma Matriz

Para preencher uma matriz, basta utilizar um laço for aninhado: o primeiro laço percorre as linhas e o segundo percorre as colunas. Este processo pode ser útil quando precisamos gerar ou modificar dados em uma matriz.

Exemplo: Preenchendo uma Matriz com Multiplicação de Índices

Vamos preencher uma matriz 3x3 com o produto dos índices das linhas e das colunas. A matriz inicial contém apenas valores 0.

```{python}
#| eval: false
# Definindo uma matriz 3x3 com todos os elementos iguais a 0
matriz = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]

# Preenchendo a matriz com o produto de i e j
for i in range(3):  # Laço para as linhas
    for j in range(3):  # Laço para as colunas
        matriz[i][j] = i * j  # Preenchendo o elemento na linha i, coluna j

# Exibindo a matriz preenchida
for linha in matriz:
    print(linha)
```

Resultado:

```{python}
#| eval: false
[0, 0, 0]
[0, 1, 2]
[0, 2, 4]
```

Explicação:

* O primeiro for percorre as linhas da matriz.

* O segundo for percorre as colunas de cada linha.

* A matriz é preenchida com o produto de $i$ (índice da linha) e $j$ (índice da coluna).

#### Iteração para Ler os Elementos de uma Matriz

Agora, vamos ver como podemos ler os dados de uma matriz já preenchida utilizando apenas o laço for.

Exemplo: Lendo uma Matriz 3x3

Aqui, temos uma matriz 3x3 com valores predefinidos. O objetivo é percorrer cada linha e coluna para imprimir o valor de cada elemento.

```{python}
#| eval: false
# Definindo uma matriz 3x3 com valores predefinidos
matriz = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# Lendo e imprimindo os elementos da matriz
for i in range(3):  # Laço para as linhas
    for j in range(3):  # Laço para as colunas
        print("Elemento na linha:", i, "coluna:", j, ": ", matriz[i][j])
```

Resultado:

```{ObjectiveC}
Elemento na linha 0, coluna 0: 1
Elemento na linha 0, coluna 1: 2
Elemento na linha 0, coluna 2: 3
Elemento na linha 1, coluna 0: 4
Elemento na linha 1, coluna 1: 5
Elemento na linha 1, coluna 2: 6
Elemento na linha 2, coluna 0: 7
Elemento na linha 2, coluna 1: 8
Elemento na linha 2, coluna 2: 9
```

Explicação:

* O primeiro for percorre as linhas da matriz.

* O segundo for percorre as colunas de cada linha.

* A matriz é lida e cada valor é acessado e impresso na tela com a posição de linha e coluna correspondente

## O que uma Matriz pode Representar?

Agora que entendemos como as matrizes são estruturadas e como acessamos seus elementos, vamos explorar alguns exemplos simples de como elas são usadas no mundo real. Matrizes são bastante comuns em diversas áreas, como ciência de dados, computação gráfica, álgebra e muito mais. Vamos ver alguns exemplos de como elas podem ser aplicadas fora da programação.

### Tabela de Pontuação de Times em um Campeonato

Uma matriz pode ser usada para representar a pontuação de diferentes times em várias rodadas de um campeonato. Cada linha pode corresponder a um time, e as colunas podem representar a pontuação de cada time em diferentes partidas.

Imagine um campeonato com 3 times (Time A, Time B e Time C) e 3 rodadas. A tabela de pontuação ficaria assim:

| Time   | Rodada 1 | Rodada 2 | Rodada 3 |
| ------ | -------- | -------- | -------- |
| Time A | 3        | 2        | 1        |
| Time B | 0        | 1        | 3        |
| Time C | 1        | 3        | 2        |

Em Python, isso poderia ser representado da seguinte forma:

```{python}
#| eval: false
pontuacoes = [
    [3, 2, 1],  # Time A
    [0, 1, 3],  # Time B
    [1, 3, 2]   # Time C
]
```

Explicação:

* Cada linha da matriz corresponde a um time (Time A, Time B, Time C).

* Cada coluna da matriz representa a pontuação do time em uma rodada do campeonato.

* Para acessar a pontuação do Time A na segunda rodada, por exemplo, podemos acessar o elemento pontuacoes[0][1], que nos dá o valor 2.

Este exemplo mostra como uma matriz pode ser útil para organizar dados de várias variáveis (neste caso, pontuações de diferentes times em diferentes rodadas) de forma compacta e eficiente.

### Representação de Imagens (Preto e Branco)

Em computação gráfica, as imagens podem ser representadas como matrizes, onde cada célula da matriz é um pixel. Em uma imagem em preto e branco, cada pixel pode ser representado por um valor numérico: 0 para preto e 1 para branco.

Vamos usar uma matriz 3x3 para representar uma imagem simples em preto e branco:

|         | Coluna 1 | Coluna 2 | Coluna 3 |
| ------- | -------- | -------- | -------- |
| Linha 1 | 0        | 1        | 0        |
| Linha 2 | 1        | 0        | 1        |
| Linha 3 | 0        | 1        | 0        |


A representação em Python seria:

```{python}
#| eval: false
imagem_pb = [
    [0, 1, 0],
    [1, 0, 1],
    [0, 1, 0]
]
```

Explicação:

* Cada número na matriz corresponde a um pixel da imagem.

* O valor 0 representa o preto, e o valor 1 representa o branco.

Manipular essa matriz, como inverter as cores ou aplicar filtros, pode ser feito facilmente modificando os valores dessa matriz.

### Tabela de Multiplicação

Matrizes também podem ser usadas para representar a tabela de multiplicação. Em uma matriz 10x10, por exemplo, cada elemento seria o produto de dois números.

Aqui está a tabela de multiplicação de 1 a 3 representada em uma matriz 3x3:

|         | Coluna 1 | Coluna 2 | Coluna 3 |
| ------- | -------- | -------- | -------- |
| Linha 1 | 1        | 2        | 3        |
| Linha 2 | 2        | 4        | 6        |
| Linha 3 | 3        | 6        | 9        |


A matriz em Python seria:

```{python}
#| eval: false
tabela_multiplicacao = [
    [1, 2, 3],
    [2, 4, 6],
    [3, 6, 9]
]
```


Explicação:

* Cada linha e cada coluna representam um número multiplicado por outro.

* Por exemplo, o valor na segunda linha e terceira coluna é 6, que é o produto de 2 * 3.

* Este é um exemplo simples de como as matrizes podem ser usadas para representar tabelas matemáticas e ajudar na visualização de operações matemáticas.

::: {.callout-note title="Observação"}

Apesar de este exemplo ser útil, é importante ressaltar que como índices em python iniciam do 0, seria necessário levar este ajuste em consideração para pensar em cálculos deste tipo de matriz.

:::

## Exercícios

### Exercício 1

Complete a matriz abaixo com os índices de cada posição (considerando a indexação de python):

$$
\begin{bmatrix}
- & - & - \\
- & - & - \\
- & - & - 
\end{bmatrix}
$$

::: {.callout-tip collapse="true" title="Ver Solução"}

As indexações corretas para esta matriz são as seguintes:

$$
\begin{bmatrix}
(0, 0) & (0, 1) & (0, 2) \\
(1, 0) & (1, 1) & (1, 2) \\
(2, 0) & (2, 1) & (2, 2)
\end{bmatrix}
$$

:::

### Exercício 2

Responda as perguntados considerando a seguinte matriz (e utilizando indexação de python):

$$
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9 
\end{bmatrix}
$$

1. Qual elemento está na posição $(0, 0)$?

::: {.callout-tip collapse="true" title="Ver Solução"}

$(0, 0)$ se refere ao elemento $1$.

:::

2. Qual elemento está na posição $(2, 1)$?

::: {.callout-tip collapse="true" title="Ver Solução"}

$(2, 1)$ se refere ao elemento $8$

:::

3. Qual é a posição do elemento $9$?

::: {.callout-tip collapse="true" title="Ver Solução"}

$(2, 2)$

:::

### Exercício 3

Escreva em Python a seguinte matriz:

$$
\begin{bmatrix}
10 & 20 & 30 \\
40 & 50 & 60 \\
70 & 80 & 90
\end{bmatrix}
$$

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
matriz = [
    [10, 20, 30],
    [40, 50, 60],
    [70, 80, 90]
]
```

:::

### Exercício 4

Em uma matriz $n \times n$, responda (considerando indexação de Python):

1. Qual é o índice do elemento localizado na posição mais à direita e mais embaixo da matriz?

2. Qual é o índice do elemento localizado na posição mais à esquerda e mais acima da matriz?

::: {.callout-tip collapse="true" title="Ver Solução"}

Uma matriz $n \times n$ em Python possui a seguinte indexação:

$$
\begin{bmatrix}
a_{00} & a_{01} & \cdots & a_{0(n-1)} \\
a_{10} & a_{11} & \cdots & a_{1(n-1)} \\
\vdots & \vdots & \ddots & \vdots \\
a_{(n-1)0} & a_{(n-1)1} & \cdots & a_{(n-1)(n-1)}
\end{bmatrix}
$$

Portanto, as respostas são:

1. O elemento mais a direita e mais embaixo é o elemento com índice $((n-1), (n-1))$:

$$
\begin{bmatrix}
a_{00} & a_{01} & \cdots & a_{0(n-1)} \\
a_{10} & a_{11} & \cdots & a_{1(n-1)} \\
\vdots & \vdots & \ddots & \vdots \\
a_{(n-1)0} & a_{(n-1)1} & \cdots & \boxed{a_{(n-1)(n-1)}}
\end{bmatrix}
$$

2. O elemento mais a esquerda e mais acima da matriz é o elemento com índice $(0, 0)$:

$$
\begin{bmatrix}
\boxed{a_{00}} & a_{01} & \cdots & a_{0(n-1)} \\
a_{10} & a_{11} & \cdots & a_{1(n-1)} \\
\vdots & \vdots & \ddots & \vdots \\
a_{(n-1)0} & a_{(n-1)1} & \cdots & a_{(n-1)(n-1)}
\end{bmatrix}
$$

:::

### Exercício 5

Considerando a seguinte matriz:

$$
\text{A} = \begin{bmatrix}
1 & 0 & 0 & 0 & 1\\
0 & 1 & 1 & 0 & 1\\
1 & 0 & 0 & 1 & 1
\end{bmatrix}
$$

1. Declare esta matriz em Python

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
A = [
    [1, 0, 0, 0, 1],
    [0, 1, 1, 0, 1],
    [1, 0, 0, 1, 1]
]
```

:::

2. Escreva o código em Python que seja capaz de acessar a matriz A na posição $(0, 0)$:

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
A[0][0]
```

:::

3. Escreva o código que seja capaz de acessar a matriz A na posição $(1, 3)$:

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
A[1][3]
```

:::

### Exercício 6

Considere a seguinte matriz em Python:

```{python}
#| eval: false
M = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]
```

1. Indique o resultado da expressão: `M[1][2]`
2. Indique o resultado da expressão: `M[2][3]`
3. Indique o resultado da expressão: `M[0][3]`
4. Indique o resultado da expressão: `M[2][0]`

::: {.callout-tip collapse="true" title="Ver Solução"}

Considerando que esta é a matriz M representada:

$$
M = \begin{bmatrix}
1 & 2 & 3 & 4 \\
5 & 6 & 7 & 8 \\
9 & 10 & 11 & 12
\end{bmatrix}
$$

Aqui estão os índices corretos da matriz:

$$
M = \begin{bmatrix}
1_{00} & 2_{01} & 3_{02} & 4_{03} \\
5_{10} & 6_{11} & 7_{12} & 8_{13} \\
9_{20} & 10_{21} & 11_{22} & 12_{23}
\end{bmatrix}
$$

1. Acessar `M[1][2]` significa acessar a matriz na linha 1 (começando de 0) e coluna 2 (começando de 0). Aqui está este elemeto:

$$
M = \begin{bmatrix}
1_{00} & 2_{01} & 3_{02} & 4_{03} \\
5_{10} & 6_{11} & \boxed{7_{12}} & 8_{13} \\
9_{20} & 10_{21} & 11_{22} & 12_{23}
\end{bmatrix}
$$

Ou seja, acessar `M[1][2]` significa acessar o elemento igual a $7$.

2. Acessar `M[2][3]` significa acessar a matriz na linha 2 (começando de 0) e coluna 3 (começando de 0). Aqui está este elemeto:

$$
M = \begin{bmatrix}
1_{00} & 2_{01} & 3_{02} & 4_{03} \\
5_{10} & 6_{11} & 7_{12} & 8_{13} \\
9_{20} & 10_{21} & 11_{22} & \boxed{12_{23}}
\end{bmatrix}
$$

Ou seja, acessar `M[2][3]` significa acessar o elemento igual a $12$.

3. Acessar `M[0][3]` significa acessar a matriz na linha 2 (começando de 0) e coluna 3 (começando de 0). Aqui está este elemeto:

$$
M = \begin{bmatrix}
1_{00} & 2_{01} & 3_{02} & \boxed{4_{03}} \\
5_{10} & 6_{11} & 7_{12} & 8_{13} \\
9_{20} & 10_{21} & 11_{22} & 12_{23}
\end{bmatrix}
$$

Ou seja, acessar `M[0][3]` significa acessar o elemento igual a $4$.

4. Acessar `M[2][0]` significa acessar a matriz na linha 2 (começando de 0) e coluna 3 (começando de 0). Aqui está este elemeto:

$$
M = \begin{bmatrix}
1_{00} & 2_{01} & 3_{02} & 4_{03} \\
5_{10} & 6_{11} & 7_{12} & 8_{13} \\
\boxed{9_{20}} & 10_{21} & 11_{22} & 12_{23}
\end{bmatrix}
$$

Ou seja, acessar `M[2][0]` significa acessar o elemento igual a $9$.

:::

5. Qual será o resultado do seguinte código:

```{python}
#| eval: false
print(M[1])
```

::: {.callout-tip collapse="true" title="Ver Solução"}

Como na programação uma matriz é nada mais que uma lista de listas (pelo menos por enquanto), acessar a matriz M na posição 1, sem especificar um segundo índice, siginifica acessar uma lista inteira da lista de listas.

Ou seja, o resultado deste código é:

```{python}
#| eval: false
[5, 6, 7, 8]
```

**Execute o código na sua máquina!**

:::

6. Escreva o código de python que altere o elemento $(0, 0)$ da matriz M para o valor de 90.

::: {.callout-tip collapse="true" title="Ver Solução"}

Para alterar um elemento da matriz, basta acessá-lo e alterar seu valor, portanto, este é o código que altera o elemento $(0, 0)$ para 90:

```{python}
#| eval: false
M[0][0] = 90
```

**Execute o código na sua máquina!**

:::

### Exercício 7

Considere a seguinte matriz:

```{python}
#| eval: false
M = [
    [1, 2],
    [3, 4]
]
```

1. Escreva um código que, utilizando duas estruturas de repetição do tipo for com range(), seja capaz de imprimir todos os elementos, ou seja, a saída deve ser: 

```{python}
#| eval: false
1
2
3
4
```

::: {.callout-tip collapse="true" title="Ver Solução"}

Aqui está o código capaz de realizar isto:

```{python}
#| eval: false
# declaração da matriz
M = [
    [1, 2],
    [3, 4]
]

# declaração de variáveis auxiliares
quantidade_de_linhas: int = 2
quantidade_de_colunas: int = 2

# estrutura de repetição para as linhas
for i in range(quantidade_de_colunas):
    # estrutura de repetição para as colunas
    for j in range(quantidade_de_colunas):
        # impressão dos elementos
        print(M[i][j])
```

**Execute este código na sua máquina!**

:::

2. Agora adapte o código para funcionar com duas estruturas de repetição do tipo *for each*.

::: {.callout-tip collapse="true" title="Ver Solução"}

Aqui está o código adaptado:

```{python}
#| eval: false
# declaração da matriz
M = [
    [1, 2],
    [3, 4]
]

# estrutura de repetição para as linhas
for linha in M:
    # estrutura de repetição para os elementos das linhas
    for elemento in linha:
        # impressão dos elementos
        print(elemento)
```

**Execute este código na sua máquina!**

:::

### Exercício 8

Considerando a seguinte matriz:

```{python}
A = [
    [5, 6, 7],
    [8, 9, 10]
]
```

Escreva um código que seja capaz de passar linha a linha desta matriz, imprimindo uma linha inteira cada vez.

::: {.callout-tip collapse="true" title="Ver Solução"}

Aqui está o código capaz de realizar isto:

```{python}
#| eval: false
# declaração da matriz
A = [
    [5, 6, 7],
    [8, 9, 10]
]

# estrutura para passar pelas linhas da matriz
for linha in A:
    # impressão das linhas
    print(linha)
```

**Execute este código na sua máquina!**

:::

### Exercício 9

Considerando a seguinte matriz:

```{python}
#| eval: false
matriz_valores = [
    [0, 1],
    [2, 3]
]
```

1. Utilizando estruturas de repetição do tipo for com a função range(), escreva um código que seja capaz de percorrer cada posição da matriz e somar todos os seus valores (ou seja, o resutlado deve ser $6$).

::: {.callout-tip collapse="true" title="Ver Solução"}

Aqui está um código capaz de realizar isto:

```{python}
#| eval: false
# declaração da matriz
matriz_valores = [
    [0, 1],
    [2, 3],
]

# variáveis auxiliares para clareza do código
quantidade_de_linhas: int = 2
quantidade_de_colunas: int = 2
soma_total: int = 0

# estrutura de repetição para linhas
for i in range(quantidade_de_linhas):
    # estrutura de repetição para colunas
    for j in range(quantidade_de_colunas):
        # adicionar o valor de cada elemento à soma
        soma_total += matriz_valores[i][j]

# imprimir o valor final da soma
print(soma_total)
```

**Execute este código na sua máquina!**

:::

2. Agora adapte o código para que ao ínves de somar todos os números, ele multiplique todos os números (ou seja, o resultado deve ser $0$).


::: {.callout-tip collapse="true" title="Ver Solução"}

As únicas modificações necessárias são a troca do valor inicial da variável de multiplicação para 1 e a troca do operador `+=` para `*=`. Aqui está o código adaptado:

```{python}
#| eval: false
# declaração da matriz
matriz_valores = [
    [0, 1],
    [2, 3],
]

# variáveis auxiliares para clareza do código
quantidade_de_linhas: int = 2
quantidade_de_colunas: int = 2
multiplicacao_total: int = 1

# estrutura de repetição para linhas
for i in range(quantidade_de_linhas):
    # estrutura de repetição para colunas
    for j in range(quantidade_de_colunas):
        # multiplicar o valor de cada elemento
        multiplicacao_total *= matriz_valores[i][j]

# imprimir o valor final da soma
print(multiplicacao_total)
```

**Execute este código na sua máquina!**

:::

3. Adapte o código do item 2 para utilizar estruturas do tipo *for each*:

::: {.callout-tip collapse="true" title="Ver Solução"}

Aqui está o código adaptado:

```{python}
#| eval: false
# declaração da matriz
matriz_valores = [
    [0, 1],
    [2, 3],
]

# variáveis auxiliares
multiplicacao_total: int = 1

# estrutura de repetição para as linhas
for linha in matriz_valores:
    # estrutura de repetição para os elementos das linhas
    for elemento in linha:
        # multiplicação dos elementos
        multiplicacao_total *= elemento

# imprimir o valor final da soma
print(multiplicacao_total)
```

**Execute este código na sua máquina!**

:::

## Desafio

Uma matriz transposta é obtida ao trocar suas linhas por colunas. Em termos formais, cada elemento $a_{ij}$ da matriz original passa a ocupar a posição $a_{ji}$ na matriz transposta.

Por exemplo, para a matriz:

$$
M = \begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6  \\
7 & 8 & 9
\end{bmatrix}
$$

A matriz transposta é:

$$
M = \begin{bmatrix}
1 & 4 & 7 \\
2 & 5 & 8  \\
3 & 6 & 9
\end{bmatrix}
$$

Gere um código que seja capaz de ler os valores de uma matriz $3 \times 3$, calcular sua transposta e corretamente imprimir ambas.

::: {.callout-tip collapse="true" title="Ver Solução"}

Aqui segue uma possível solução simples:

```{python}
#| eval: false
# declaração da matriz original
matriz_original = [
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0]
]

# variáveis auxiliares
quantidade_de_linhas: int = 3
quantidade_de_colunas: int = 3

# estrutura de repetição para percorrer as linhas da matriz original
for i in range(quantidade_de_linhas):
    # estrutura de repetição para percorrer as colunas da matriz original
    for j in range(quantidade_de_colunas):
        # ler um valor para a posição (i, j)
        matriz_original[i][j] = int(input('Insira um número: '))

# declaração da matriz que recebera os valores da transposta
matriz_transposta = [
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0]
]

# estrutura de repetição para percorrer as linhas da matriz original
for i in range(quantidade_de_linhas):
    # estrutura de repetição para percorrer as colunas da matriz original
    for j in range(quantidade_de_colunas):
        # colocar, na posição (j, i) da transposta cada elemento (i, j) da matriz original
        matriz_transposta[j][i] = matriz_original[i][j]

# percorrer todas as linhas da matriz original
for linha in matriz_original:
    # imprimir cada linha
    print(linha)

# percorrer todas as linhas da matriz transposta
for linha in matriz_transposta:
    # imprimir cada linha
    print(linha)
```

:::