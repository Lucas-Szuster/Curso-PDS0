---
title: "Exercícios"
toc: true
toc-title: "Secções de exercícios"
---

## Exercícios de variáveis

### Exercício 1

Defina o melhor tipo de variável para se utilizar nos seguintes casos:

1. A quantidade de pessoas que existem no planeta;

::: {.callout-tip collapse="true" title="Ver Solução"}

`int` - pois o número de pessoas que existem no planeta é inteiro.

:::

2. O nome de uma pessoa;

::: {.callout-tip collapse="true" title="Ver Solução"}

`string` - pois um nome é uma sequência de caracteres.

:::

3. O peso (medido com alta precisão) de um prego;

::: {.callout-tip collapse="true" title="Ver Solução"}

`float` - pois um peso medido com alta precisão, idependente da unidade de medição (kg, g, etc), muito provavelmente terá casas decimais.

:::

4. Uma lista que contém todas as notas de alunos associadas aos seus nomes;

::: {.callout-tip collapse="true" title="Ver Solução"}

`dict` - pois queremos associas pares de chave (nome) com valor (nota do aluno).

:::

5. A média entre dois números;

::: {.callout-tip collapse="true" title="Ver Solução"}

`float` - pois a média entre quaisquer dois números tem alta probabilidade de conter casas decimais.

:::

### Exercício 2 

Leia os valores abaixo e diga qual seria o tipo de variável ideal para armazenar cada um deles:

1. 42

::: {.callout-tip collapse="true" title="Ver Solução"}

`int` - pois é um número inteiro.

:::

2. "Olá, mundo!"

::: {.callout-tip collapse="true" title="Ver Solução"}

`string` - pois é uma sequência de caracteres.

:::

3. 3.1415

::: {.callout-tip collapse="true" title="Ver Solução"}

`float` - pois é um número não-inteiro.

:::

4. True

::: {.callout-tip collapse="true" title="Ver Solução"}

`bool` - pois é um valor booleano.

:::

5. -1200

::: {.callout-tip collapse="true" title="Ver Solução"}

`int` - pois é um número inteiro.

:::

### Exercício 3 

Leia as sentenças e separe o nome da variável e o valor armazenado:

1. cidade = "Recife"

::: {.callout-tip collapse="true" title="Ver Solução"}

cidade é o nome da variável e a `string` "Recife" é seu valor.

:::

2. populacao = 1600000

::: {.callout-tip collapse="true" title="Ver Solução"}

populacao é o nome da variável e o seu valor é 1600000 (tipo `int`).

:::

3. capital = True

::: {.callout-tip collapse="true" title="Ver Solução"}

capital é o nome da variável e o seu valor é True (tipo `bool`).

:::

### Exercício 4

Explique o que acontece se tentarmos somar "5" (string) com 5 (inteiro). Como você poderia corrigir o código para que a soma funcione corretamente?

::: {.callout-tip collapse="true" title="Ver Solução"}

A operação `"5" + 5` não funciona porque os dois elementos são de tipos diferentes, e a operação de somar um `int` a uma `string` não está definida. Para corrigir o erro, ambos os valores devem ser do mesmo tipo. Para isso, podem ser feitas duas correções diferentes:

* `"5" + "5"` -> resulta em `"55"`

* `5 + 5` -> resulta em `10` 

:::

### Exercício 5 

Sem executar, diga qual tipo de dado cada variável deve ter no código abaixo:

```{python}
nome = "Maria"
idade = 17
altura = 1.63
maior_de_idade = False
```

::: {.callout-tip collapse="true" title="Ver Solução"}

* nome: `string`, pois é uma sequência de caracteres
* idade: `int`, pois é um número inteiro
* altura: `float`, pois é um número não inteiro
* maior_de_idade: `bool`, pois é um valor booleano

:::

### Exercício 6 

Observe os exemplos abaixo e diga se cada um representa uma lista ou um dicionário:

1. ["maçã", "banana", "uva"]

::: {.callout-tip collapse="true" title="Ver Solução"}

`list` - pois não temos pares de chave e valor, somente valores.

:::

2. {"nome": "Maria", "idade": 20}

::: {.callout-tip collapse="true" title="Ver Solução"}

`dict` - pois temos pares de chave e valor.

:::

3. [10, 20, 30, 40, 50]

::: {.callout-tip collapse="true" title="Ver Solução"}

`list` - pois não temos pares de chave e valor, somente valores.

:::

4. {"cor": "azul", "tamanho": "M", "estoque": 12}

::: {.callout-tip collapse="true" title="Ver Solução"}

`dict` - pois temos pares de chave e valor.

:::

5. [True, False, True, False]

::: {.callout-tip collapse="true" title="Ver Solução"}

`list` - pois não temos pares de chave e valor, somente valores.

:::

### Exercício 7 

Analise a seguinte estrutura e responda os items 1, 2 e 3:

```{python}
animais = ["gato", "cachorro", "papagaio", "peixe"]
```

1. Quantos elementos essa lista possui?

::: {.callout-tip collapse="true" title="Ver Solução"}

4 elementos.

:::

2. Qual elemento está na posição 0?

::: {.callout-tip collapse="true" title="Ver Solução"}

"gato".

:::

3. Qual elemento está na última posição?

::: {.callout-tip collapse="true" title="Ver Solução"}

"peixe".

:::

### Exercício 8 

Observe o dicionário abaixo e responda os items 1, 2 e 3:

```{python}
aluno = {"nome": "Pedro", "idade": 19, "curso": "Física"}
```

Responda:
1. Quantas chaves ele possui?

::: {.callout-tip collapse="true" title="Ver Solução"}

3 chaves - "nome", "idade" e "curso".

:::

2. Quais são os valores associados a essas chaves?

::: {.callout-tip collapse="true" title="Ver Solução"}

o valor associado a "nome" é "Pedro", o valor associado a "idade" é 19 e o valor associado a "curso" é "Física".

:::

3. Quais são os tipos dos valores deste `dict`?

::: {.callout-tip collapse="true" title="Ver Solução"}

* o tipo do valor "Pedro" é `string`, pois "Pedro" é uma sequência de caracteres.
* o tipo do valor 19 é `int`, pois 19 é um número inteiro.
* o tipo do valor "Física" é `string`, pois "Física" é uma sequência de caracteres.

:::

### Exercício 9

Leia as situações e identifique se seria mais adequado usar uma lista ou um dicionário:

1. Guardar as notas de uma prova em ordem (sem nomes, apenas os valores).

::: {.callout-tip collapse="true" title="Ver Solução"}

`list` - pois não queremos associar valores a uma chave.

:::

2. Armazenar o nome e a nota de cada aluno em uma turma.

::: {.callout-tip collapse="true" title="Ver Solução"}

`dict` - pois queremos associar valores (os nomes dos alunos) a chaves (as notas).

:::

3. Guardar uma sequência de números sorteados em um jogo.

::: {.callout-tip collapse="true" title="Ver Solução"}

`list` - pois não queremos associar valores a uma chave.

:::

4. Representar as informações de um produto (nome, preço, categoria).

::: {.callout-tip collapse="true" title="Ver Solução"}

`dict` - pois queremos associar valores (os atributos do produto) a chaves (os valores destes atributos).

Por exemplo:

```{python}
# produto carro
produto_carro = {"modelo" : "Polo", "marca" : "Volkswagen", "ano" : 2019}

# produto celular
produto_celular = {"modelo" : "A12", "marca" : "Samsung", "ano" : 2021}
```

:::

5. Armazenar todas as cidades que uma pessoa já visitou.

::: {.callout-tip collapse="true" title="Ver Solução"}

`list` - pois não queremos associar valores a uma chave.

:::


## Exercícios de interpretação de fluxograma

### Exercício 1 

Descreva o funcionamento do algoritmo representado neste fluxograma:

```{mermaid}
flowchart LR
    A([Início]) --> B[/Ler valor de a e b/]
    B --> C[c = a + b]
    C --> D[Imprimir c]
    D --> E([Término])
```


::: {.callout-tip collapse="true" title="Ver Solução"}

O fluxograma descreve um algorítmo que primeiramente lê valores de duas variáveis, a e b. Com estas variáveis, o algorítmo calcula um terceiro valor, a soma de a e b, armazenado em c. Por fim, o algorítmo imprime a variável c e termina.

:::

### Exercício 2 

Descreva o funcionamento do algoritmo representado neste fluxograma:

```{mermaid}
flowchart LR
    A([Início]) --> B[/Ler valor de a e b/]
    B --> C["média = (a + b) / 2"]
    C --> D[Imprimir média]
    D --> E([Término]) 
```

::: {.callout-warning title="Observação importante"}

No fluxograma acima, é utilizada uma variável cahamada "média", com acento em seu nome. Para a implementação deste fluxograma em código, é correto alterar seu nome para "media", sem acento, pois nomes de variáveis em programas não devem conter caracteres especiais.

:::

::: {.callout-tip collapse="true" title="Ver Solução"}

O fluxograma descreve um algorítmo que primeiramente lê valores de duas variáveis, a e b. Com estas variáveis, o algorítmo calcula um terceiro valor, a média entre a e b, armazenado na varíavel média. Por fim, o algorítmo imprime a variável média e termina.

:::

### Exercício 3

Descreva o funcionamento do algoritmo representado neste fluxograma:

```{mermaid}
flowchart LR
    A([Início]) --> B[/ler a e b/]
    B --> C[temp = a]
    C --> D[a = b]
    D --> E[b = temp]
    E --> F[Imprimir a e b]
    F --> G([Término])
```

::: {.callout-tip collapse="true" title="Ver Solução"}

O fluxograma descreve um algorítmo que troca os valores de duas variáveis. Para isto, o alogrítmo inicialmente lê dois valores para variáveis a e b. Após isto, uma nova variável chamada temp é declarada com o valor de a. Isto permite que a tenha seu valor alterado para o valor de b, e depois que b tenha seu valor alterado para o valor guardado em temp (que é o valor inicial de a). Após isto, os valores de a e b são impressos e o algorítmo termina.

:::

## Exercícios de implementação simples (sem condicional)

### Exercício 1 

Implemente um algoritmo que leia uma temperatura em Celsius e converta para Kelvin usando a fórmula: $K = C + 273$, onde $K$ é a temperatura em graus Kelvin e $C$ é a temperatura em graus celsius.

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
C: float = float(input('Insira a temperatura em graus Celsius: '))
K: float = C + 273

print('A temperatura em graus Kelvin é: ', K)
```

Neste bloco de código, uma variável chamada C é inicializada com um valor lido do terminal, através da função input(). Após ler a entrada, é feito o cálculo de conversão dos graus Celsius para Kelvin e o valor da conversão é armazenado em uma variável chamada K. Por fim, o valor de K é impresso na tela.

::: {.callout-note title="Observação"}

* Neste código, os nomes das variáveis são pouco descritíveis, e foram escolhidos somente para exemplificar com clareza o que o enunciado pede. Nomes melhores de variáveis seriam "temperaturaEmGrausCelsius" ao invés de "C" e "temperaturaEmGrausKelvin" ao invés de K. 

* Nomes de variáveis inteiramente escritos em letras maiúsculas são geralmente reservados para constantes, assim há um outro motivo pelo qual os nomes "C" e "K" não são boas escolhas.

:::

:::

### Exercício 2

Implemente o código que realiza o algorítmo descrito pelo seguinte fluxograma:

```{mermaid}
    flowchart LR
        A([Início]) --> B[/Ler largura e altura/]
        B --> C[area = largura * altura]
        C --> D[Imprimir area]
        D --> E([Término])
```

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
largura: float = float(input('Insira a largura: '))
altura: float = float(input('Insira a altura: '))

area: float = largura * altura

print('A área do retangulo é: ', area)
```

Neste bloco de código, são declaradas duas variáveis do tipo float, largura e altura, e ambas são inicializadas com valores lidos do terminal. Após ler valores para largura e altura, a fórmula de área de um retângulo ($A = B \times h$) é aplicada e o novo valor calculado é salvo em uma variavel chamada area. Por fim, o valor da área é impresso e algorítmo termina sua execução.

::: {.callout-note title="Observação"}

É importante observar que o nome da variável que guarda a área do retângulo descrito no código é area e não área. Isto se deve porque não é uma boa prática de programação implementar variáveis que possuam nomes com caracteres especiais (neste caso o "á").

:::

:::

### Exercício 3

Implemente o código que realiza o algorítmo descrito pelo seguinte fluxograma:

```{mermaid}
flowchart LR
    A([Início]) --> B[/Ler valor de raio/]
    B --> C[area = 3.1416 * raio * raio]
    C --> D[Imprimir area]
    D --> E([Término])
```

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
raio: float = float(input('Insira o valor do raio do círculo: '))
pi: float = 3.14

area: float = pi * raio * raio

print('A área do retangulo é: ', area)
```

Neste bloco de código, são declaradas duas variáveis, raio e pi. A variável pi é incializada com uma aproximação de $\pi$ para duas casas decimais, enquanto a variável raio é inicializada com um valor lido do terminal. Após obter os valores de $\pi$ e raio, basta aplicar a fórmula de cálculo de área de um círculo ($A = \pi r^2$) e armazenar o resultado em uma variável chamada area. Por fim, o valor da área é impresso e o programa termina sua execução

::: {.callout-note title="Observação"}

* É importante observar que o nome da variável que guarda a área do círculo descrito no código é area e não área. Isto se deve porque não é uma boa prática de programação implementar variáveis que possuam nomes com caracteres especiais (neste caso o "á").

* Uma melhoria a este código é utilizar uma definição de $\pi$ que venha de algum módulo (como o módulo *math*), entretanto isto não foi estudado ainda, então será relevado.

:::

:::

### Exercício 4 

Implemente o código que realiza o algorítmo descrito pelo seguinte fluxograma: 

```{mermaid}
flowchart LR
    A([Início]) --> B[/Ler quantidade de horas/]
    B --> C[minutos = horas * 60]
    C --> D[Imprimir minutos]
    D --> E([Término])
```

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
horas: int = int(input('Insira a quantidade de horas: '))

minutos: int = horas * 60

print('A quantidade de minutos é: ', minutos)
```

Neste bloco de código, é declarada uma variável horas, do tipo inteiro (*int*), que é incializada com um valor lido do terminal. Após isto, outra variável, minutos, é definida como a $\text{horas} \times 60$. Por fim, o valor de minutos é impresso e o programa termina sua execução.

::: {.callout-note title="Observação"}

Para imprimir a quantidade de minutos, foi utilizado uma forma da função print() que imprime os parâmetros passados em ordem. Entretanto, para imprimir uma resposta mais completa, seria mais adequado a utilização de [f-string](https://www.w3schools.com/python/python_string_formatting.asp), como descrito abaixo:

```{python}
#| eval: false
print(f'Em {horas} horas são {minutos} minutos')
```

:::

:::

### Exercício 5

Implemente o código que realiza o algorítmo descrito pelo seguinte fluxograma: 

```{mermaid}
flowchart LR
    A([Início]) --> B[/Ler valor de n/]
    B --> C[soma = 1 + 2 + ... + n]
    C --> D[Imprimir soma]
    D --> E([Término])
```

::: {.callout-tip title="Dica"}
Lembre-se da [soma de Gauss](https://letstalkscience.ca/educational-resources/backgrounders/gauss-summation)

:::

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
n: int = int(input('Insira o valor de n: '))
soma: int = (n * (n + 1)) / 2

print('A soma dos números até n é: ', soma)
```

Neste bloco de código, é declarada uma variável n (do tipo *int*), inicializada com um valor lido do terminal. Com este valor estabelecido, a soma de todos os números inteiros começando de 1 até n é calculada com base na soma de Gauss. Após calcular a soma, o valor é impreso na tela e o programa termina sua execução.


::: {.callout-note title="Observação"}

Para imprimir a soma, foi utilizado uma forma da função print() que imprime os parâmetros passados em ordem. Entretanto, para imprimir uma resposta mais completa, seria mais adequado a utilização de [f-string](https://www.w3schools.com/python/python_string_formatting.asp), como descrito abaixo:

```{python}
#| eval: false
print(f'A soma de 1 até {n} é: {soma}')
```

:::

:::

## Exercícios de implementação com condicional

### Exercício 1 

Com base no fluxograma abaixo, faça o que se pede:

```{mermaid}
flowchart TD
    A([Início]) --> B[/Ler valor de n/]
    B --> C{n >= 0}
    C -->|Verdadeiro| D["Imprimir: Número positivo"]
    C -->|Falso| E["Imprimir: Número negativo"]
    D --> F([Término])
    E --> F

```

1. Descreva o que este algorítmo faz;

::: {.callout-tip collapse="true" title="Ver Solução"}

O algorítmo descrito recebe um número n como entrada e descobre se este número é negativo ou positivo, indicando o resultado na saída

:::

2. Implemente em código o algorítmo descrito pelo fluxograma.

::: {.callout-tip collapse="true" title="Ver Solução"}

Abaixo está a implementação do algorítmo descrita no item 1:

```{python}
#| eval: false
n: int = int(input('Insira o valor de n: '))

if(n >= 0):
    print('Número positivo')
else:
    print('Número negativo')
```

:::

### Exercício 2 

Com base no fluxograma abaixo, faça o que se pede: 

```{mermaid}
flowchart TD
    A([Início]) --> B[/Ler valor de n/]
    B --> C{n % 2 == 0?}
    C -->|Verdadeiro| D["Imprimir: Número par"]
    C -->|Falso| E["Imprimir: Número ímpar"]
    D --> F([Término])
    E --> F
```

::: {.callout-note title="Observação"}

O operador módulo "%" retorna o resto de uma divisão. Por exemplo: 7 % 5 = 2, pois 2 é o resto que sobra ao realizar a divisão inteira de 7 por 5.

:::

1. Descreva o que este algorítmo faz;

::: {.callout-tip collapse="true" title="Ver Solução"}

O algorítmo descrito recebe um número n como entrada e descobre se este número é part ou ímpar, indicando o resultado na saída.

:::

2. Implemente em código o algorítmo descrito pelo fluxograma.

::: {.callout-tip collapse="true" title="Ver Solução"}

Abaixo está a implementação do algorítmo descrita no item 1:

```{python}
#| eval: false
n: int = int(input('Insira o valor de n: '))

if(n % 2 == 0):
    print('Número par')
else:
    print('Número ímpar')
```

:::

### Exercício 3 

Com base no fluxograma abaixo, faça o que se pede:

```{mermaid}
flowchart TD
    A([Início]) --> B[/Ler valores a e b/]
    B --> C{a > b?}
    C -->|Verdadeiro| D["Imprimir: a é maior"]
    C -->|Falso| E["Imprimir: b é maior ou igual a a"]
    D --> F([Término])
    E --> F
```

::: {.callout-note title="Observação"}

O operador maior ">" retorna verdadeiro caso o número a esquerda seja estritamente maior que o número a direita e falso caso contrário.

:::

1. Descreva o que este algorítmo faz;

::: {.callout-tip collapse="true" title="Ver Solução"}

O algorítmo descrito recebe dois números na entrada, a e b, e descobre qual deles é o maior, indicando o resultado na saída.

:::

2. Implemente em código o algorítmo descrito pelo fluxograma.

::: {.callout-tip collapse="true" title="Ver Solução"}

Abaixo está a implementação do algorítmo descrita no item 1:

```{python}
#| eval: false
a: int = int(input('Insira o valor de a: '))
b: int = int(input('Insira o valor de b: '))

if(a > b):
    print('a é maior')
else:
    print('b é maior ou igual a a')
```

:::

### Exercício 4 

Com base no fluxograma abaixo, faça o que se pede:

```{mermaid}
flowchart TD
    A([Início]) --> B[/Ler valor de n/]
    B --> C{n > 0?}
    C -->|Verdadeiro| D["Imprimir: Número positivo"]
    C -->|Falso| E{n < 0}
    E -->|Verdadeiro| F["Imprimir: Número negativo"]
    E -->|Falso| G["Imprimir: Zero"]
    D --> H([Término])
    F --> H
    G --> H
```

::: {.callout-note title="Observação"}

O operador maior ">" retorna verdadeiro caso o número a esquerda seja estritamente maior que o número a direita e falso caso contrário.

Da mesma forma, o operador "<" retorna verdadeiro caso o número a direita seja estritamente maior que o número a direita e falso caso contrário.

:::

1. Descreva o que este algorítmo faz;

::: {.callout-tip collapse="true" title="Ver Solução"}

O algorítmo descrito recebe um valor n e descobre se ele é maior, menor ou igual a 0, indicando o resultado na saída.

:::

2. Implemente em código o algorítmo descrito pelo fluxograma.

::: {.callout-tip collapse="true" title="Ver Solução"}

Abaixo está a implementação do algorítmo descrita no item 1:

```{python}
#| eval: false
n: int = int(input('Insira o valor de n: '))

if(n > 0):
    print('Número postivo')
else:
    if(n < 0):
        print('Número negativo')
    else:
        print('Zero')
```

:::

## Exercícios de implementação com estruturas de repetição

### Exercício 1

1. Implemente um programa capaz de descorbrir qual o menor número da seguinte lista:

```{python}
#| eval: false
lista_de_numeros: list = [
    29538, 690188, 189130, 821693, 876709, 906758, 470392, 485388, 308468, 358734, 
    736021, 893093, 559598, 157302, 21169, 151670, 179671, 395737, 109068, 608474, 
    8834, 668804, 509309, 977665, 46269, 844234, 542512, 873743, 500626, 43145, 
    207760, 521203, 52495, 100116, 321994, 678868, 647870, 598770, 50196, 5788, 
    792648, 863580, 962660, 372296, 465603, 408959, 608872, 137921, 52691, 756749, 
    833649, 875620, 329003, 499386, 658702, 267697, 378477, 504649, 202723, 580527, 
    799994, 675131, 841086, 302652, 16883, 68415, 746637, 453785, 626416, 654378, 
    307983, 457009, 915016, 152660, 44970, 652553, 121578, 139873, 123397, 563729, 
    574961, 399038, 343754, 551352, 215971, 998233, 750942, 162020, 863550, 462764, 
    636779, 972026, 690119, 461144, 87993, 177373, 553780, 603819, 818041, 229354, 
    48977, 794853, 61516, 370125, 731722, 442370, 555879, 864091, 22676, 415990, 
    404694, 416344, 113914, 785038, 550040, 473795, 640780, 488974, 348732, 449737, 
    766278, 759026, 809038, 14067, 289346, 73367, 788195, 85030, 245709, 408662, 
    903062, 831203, 176081, 361461, 635253, 346009, 53793, 627915, 83270, 331645, 
    991272, 712993, 78923, 79192, 427915, 794353, 784351, 2539, 902578, 363842, 
    727225, 27119, 804767, 334035, 572588, 897345, 655959, 732571, 535572, 751019, 
    87471, 973329, 831712, 192522, 834351, 241419, 882584, 635873, 613729, 490420, 
    396933, 380870, 613703, 553085, 751105, 358317, 122963, 548258, 879365, 889973, 
    43490, 382880, 442714, 814620, 552297, 168440, 418645, 569276, 835422, 297848, 
    334135, 440719, 540715, 961237, 388975, 484085, 365913, 1981, 790582, 773419, 
    522185, 278268, 997634, 998177, 517327, 304668, 206865, 76881, 772722, 971523, 
    396772, 855841, 34457, 671187, 458553, 561998, 626902, 891487, 172414, 499531, 
    279322, 54756, 691627, 912780, 938099, 549712, 938935, 590838, 788957, 633722, 
    56790, 452098, 38593, 282537, 475976, 98557, 339994, 632560, 536765, 477451, 
    199454, 690299, 127693, 48996, 215104, 27642, 239176, 467254, 755925, 486141, 
    253652, 673829, 955175, 962887, 311204, 657762, 788094, 260058, 646517, 362195, 
    973905, 388880, 254755, 62596, 372918, 981823, 224710, 54201, 253300, 494449, 
    645978, 863709, 931999, 755168, 525438, 856061, 172433, 948532, 80574, 173558, 
    809081, 8077, 735774, 634550, 70281, 276278, 709129, 547582, 391112, 314708, 
    227784, 481930, 249334, 415812, 792262, 947268, 760126, 101050, 277101, 86843, 
    527732, 223484, 434561, 969175, 760014, 757129, 191310, 335110, 453691, 128553, 
    301166, 720735, 774016, 756493, 686196, 93010, 497685, 379519, 251289, 895478, 
    106476, 968691, 51699, 371735, 146722, 981127, 250081, 750656, 822654, 377045, 
    641145, 990371, 144640, 213590, 110928, 837007, 890954, 855145, 405597, 501804, 
    257052, 862515, 147926, 357943, 877228, 588392, 313815, 315918, 284764, 82996, 
    479385, 816499, 811963, 976932, 100996, 237383, 109445, 17323, 86089, 344436, 
    878771, 980391, 291757, 337436, 439249, 24480, 535983, 112648, 538992, 882008, 
    923466, 319375, 948980, 49509, 611170, 864493, 40572, 994879, 651593, 783901, 
    773933, 470141, 837146, 170007, 829159, 72428, 857317, 983024, 46168, 577194, 
    585984, 68233, 453116, 24810, 259509, 834995, 593532, 542972, 231104, 32445, 
    624728, 569817, 408435, 727863, 253922, 19400, 327184, 629941, 435299, 396098, 
    165033, 288672, 481066, 601372, 138629, 626699, 644927, 158747, 749832, 935174, 
    625334, 611345, 943720, 636633, 445088, 884968, 842825, 173404, 537110, 329647, 
    826025, 280898, 548809, 333624, 579421, 466274, 860556, 696633, 787785, 150485, 
    995366, 603049, 443859, 497678, 524307, 36557, 609436, 810786, 154741, 624142, 
    989263, 250184, 134475, 481695, 166283, 46286, 915657, 962874, 273302, 604806, 
    733960, 598313, 633854, 409712, 909271, 100721, 406834, 546354, 694382, 47899, 
    795204, 808265, 24947, 169639, 595883, 140971, 778032, 993410, 447277, 224293, 
    382644, 737537, 834688, 802061, 502282, 670140, 848397, 484884, 371584, 980658, 
    727561, 591138, 569087, 331409, 664209, 355817, 64219, 36037, 727985, 712134
]
```

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
# declarar a lista de números que será utilizada
lista_de_numeros: list = [
    29538, 690188, 189130, 821693, 876709, 906758, 470392, 485388, 308468, 358734, 
    736021, 893093, 559598, 157302, 21169, 151670, 179671, 395737, 109068, 608474, 
    8834, 668804, 509309, 977665, 46269, 844234, 542512, 873743, 500626, 43145, 
    207760, 521203, 52495, 100116, 321994, 678868, 647870, 598770, 50196, 5788, 
    792648, 863580, 962660, 372296, 465603, 408959, 608872, 137921, 52691, 756749, 
    833649, 875620, 329003, 499386, 658702, 267697, 378477, 504649, 202723, 580527, 
    799994, 675131, 841086, 302652, 16883, 68415, 746637, 453785, 626416, 654378, 
    307983, 457009, 915016, 152660, 44970, 652553, 121578, 139873, 123397, 563729, 
    574961, 399038, 343754, 551352, 215971, 998233, 750942, 162020, 863550, 462764, 
    636779, 972026, 690119, 461144, 87993, 177373, 553780, 603819, 818041, 229354, 
    48977, 794853, 61516, 370125, 731722, 442370, 555879, 864091, 22676, 415990, 
    404694, 416344, 113914, 785038, 550040, 473795, 640780, 488974, 348732, 449737, 
    766278, 759026, 809038, 14067, 289346, 73367, 788195, 85030, 245709, 408662, 
    903062, 831203, 176081, 361461, 635253, 346009, 53793, 627915, 83270, 331645, 
    991272, 712993, 78923, 79192, 427915, 794353, 784351, 2539, 902578, 363842, 
    727225, 27119, 804767, 334035, 572588, 897345, 655959, 732571, 535572, 751019, 
    87471, 973329, 831712, 192522, 834351, 241419, 882584, 635873, 613729, 490420, 
    396933, 380870, 613703, 553085, 751105, 358317, 122963, 548258, 879365, 889973, 
    43490, 382880, 442714, 814620, 552297, 168440, 418645, 569276, 835422, 297848, 
    334135, 440719, 540715, 961237, 388975, 484085, 365913, 1981, 790582, 773419, 
    522185, 278268, 997634, 998177, 517327, 304668, 206865, 76881, 772722, 971523, 
    396772, 855841, 34457, 671187, 458553, 561998, 626902, 891487, 172414, 499531, 
    279322, 54756, 691627, 912780, 938099, 549712, 938935, 590838, 788957, 633722, 
    56790, 452098, 38593, 282537, 475976, 98557, 339994, 632560, 536765, 477451, 
    199454, 690299, 127693, 48996, 215104, 27642, 239176, 467254, 755925, 486141, 
    253652, 673829, 955175, 962887, 311204, 657762, 788094, 260058, 646517, 362195, 
    973905, 388880, 254755, 62596, 372918, 981823, 224710, 54201, 253300, 494449, 
    645978, 863709, 931999, 755168, 525438, 856061, 172433, 948532, 80574, 173558, 
    809081, 8077, 735774, 634550, 70281, 276278, 709129, 547582, 391112, 314708, 
    227784, 481930, 249334, 415812, 792262, 947268, 760126, 101050, 277101, 86843, 
    527732, 223484, 434561, 969175, 760014, 757129, 191310, 335110, 453691, 128553, 
    301166, 720735, 774016, 756493, 686196, 93010, 497685, 379519, 251289, 895478, 
    106476, 968691, 51699, 371735, 146722, 981127, 250081, 750656, 822654, 377045, 
    641145, 990371, 144640, 213590, 110928, 837007, 890954, 855145, 405597, 501804, 
    257052, 862515, 147926, 357943, 877228, 588392, 313815, 315918, 284764, 82996, 
    479385, 816499, 811963, 976932, 100996, 237383, 109445, 17323, 86089, 344436, 
    878771, 980391, 291757, 337436, 439249, 24480, 535983, 112648, 538992, 882008, 
    923466, 319375, 948980, 49509, 611170, 864493, 40572, 994879, 651593, 783901, 
    773933, 470141, 837146, 170007, 829159, 72428, 857317, 983024, 46168, 577194, 
    585984, 68233, 453116, 24810, 259509, 834995, 593532, 542972, 231104, 32445, 
    624728, 569817, 408435, 727863, 253922, 19400, 327184, 629941, 435299, 396098, 
    165033, 288672, 481066, 601372, 138629, 626699, 644927, 158747, 749832, 935174, 
    625334, 611345, 943720, 636633, 445088, 884968, 842825, 173404, 537110, 329647, 
    826025, 280898, 548809, 333624, 579421, 466274, 860556, 696633, 787785, 150485, 
    995366, 603049, 443859, 497678, 524307, 36557, 609436, 810786, 154741, 624142, 
    989263, 250184, 134475, 481695, 166283, 46286, 915657, 962874, 273302, 604806, 
    733960, 598313, 633854, 409712, 909271, 100721, 406834, 546354, 694382, 47899, 
    795204, 808265, 24947, 169639, 595883, 140971, 778032, 993410, 447277, 224293, 
    382644, 737537, 834688, 802061, 502282, 670140, 848397, 484884, 371584, 980658, 
    727561, 591138, 569087, 331409, 664209, 355817, 64219, 36037, 727985, 712134
]

# declarar uma variável que irá guardar o menor valor, incialmente a 1a posição da lista
menor_valor: int = lista_de_numeros[0]

# passar por todos os números da lista
for num in lista_de_numeros:
    # checar se o número é menor que o menor valor
    if(num < menor_valor):
        # caso seja, atualizar o menor valor
        menor_valor = num

# exibir o resultado
print(menor_valor)
```

:::

2. Agora, sabendo que esta lista possui 500 números, adapte o código que você implementou para o item 1 a fim de descobrir a posição (com indexação em python) do menor valor.

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
# declarar a lista de números que será utilizada
lista_de_numeros: list = [
    29538, 690188, 189130, 821693, 876709, 906758, 470392, 485388, 308468, 358734, 
    736021, 893093, 559598, 157302, 21169, 151670, 179671, 395737, 109068, 608474, 
    8834, 668804, 509309, 977665, 46269, 844234, 542512, 873743, 500626, 43145, 
    207760, 521203, 52495, 100116, 321994, 678868, 647870, 598770, 50196, 5788, 
    792648, 863580, 962660, 372296, 465603, 408959, 608872, 137921, 52691, 756749, 
    833649, 875620, 329003, 499386, 658702, 267697, 378477, 504649, 202723, 580527, 
    799994, 675131, 841086, 302652, 16883, 68415, 746637, 453785, 626416, 654378, 
    307983, 457009, 915016, 152660, 44970, 652553, 121578, 139873, 123397, 563729, 
    574961, 399038, 343754, 551352, 215971, 998233, 750942, 162020, 863550, 462764, 
    636779, 972026, 690119, 461144, 87993, 177373, 553780, 603819, 818041, 229354, 
    48977, 794853, 61516, 370125, 731722, 442370, 555879, 864091, 22676, 415990, 
    404694, 416344, 113914, 785038, 550040, 473795, 640780, 488974, 348732, 449737, 
    766278, 759026, 809038, 14067, 289346, 73367, 788195, 85030, 245709, 408662, 
    903062, 831203, 176081, 361461, 635253, 346009, 53793, 627915, 83270, 331645, 
    991272, 712993, 78923, 79192, 427915, 794353, 784351, 2539, 902578, 363842, 
    727225, 27119, 804767, 334035, 572588, 897345, 655959, 732571, 535572, 751019, 
    87471, 973329, 831712, 192522, 834351, 241419, 882584, 635873, 613729, 490420, 
    396933, 380870, 613703, 553085, 751105, 358317, 122963, 548258, 879365, 889973, 
    43490, 382880, 442714, 814620, 552297, 168440, 418645, 569276, 835422, 297848, 
    334135, 440719, 540715, 961237, 388975, 484085, 365913, 1981, 790582, 773419, 
    522185, 278268, 997634, 998177, 517327, 304668, 206865, 76881, 772722, 971523, 
    396772, 855841, 34457, 671187, 458553, 561998, 626902, 891487, 172414, 499531, 
    279322, 54756, 691627, 912780, 938099, 549712, 938935, 590838, 788957, 633722, 
    56790, 452098, 38593, 282537, 475976, 98557, 339994, 632560, 536765, 477451, 
    199454, 690299, 127693, 48996, 215104, 27642, 239176, 467254, 755925, 486141, 
    253652, 673829, 955175, 962887, 311204, 657762, 788094, 260058, 646517, 362195, 
    973905, 388880, 254755, 62596, 372918, 981823, 224710, 54201, 253300, 494449, 
    645978, 863709, 931999, 755168, 525438, 856061, 172433, 948532, 80574, 173558, 
    809081, 8077, 735774, 634550, 70281, 276278, 709129, 547582, 391112, 314708, 
    227784, 481930, 249334, 415812, 792262, 947268, 760126, 101050, 277101, 86843, 
    527732, 223484, 434561, 969175, 760014, 757129, 191310, 335110, 453691, 128553, 
    301166, 720735, 774016, 756493, 686196, 93010, 497685, 379519, 251289, 895478, 
    106476, 968691, 51699, 371735, 146722, 981127, 250081, 750656, 822654, 377045, 
    641145, 990371, 144640, 213590, 110928, 837007, 890954, 855145, 405597, 501804, 
    257052, 862515, 147926, 357943, 877228, 588392, 313815, 315918, 284764, 82996, 
    479385, 816499, 811963, 976932, 100996, 237383, 109445, 17323, 86089, 344436, 
    878771, 980391, 291757, 337436, 439249, 24480, 535983, 112648, 538992, 882008, 
    923466, 319375, 948980, 49509, 611170, 864493, 40572, 994879, 651593, 783901, 
    773933, 470141, 837146, 170007, 829159, 72428, 857317, 983024, 46168, 577194, 
    585984, 68233, 453116, 24810, 259509, 834995, 593532, 542972, 231104, 32445, 
    624728, 569817, 408435, 727863, 253922, 19400, 327184, 629941, 435299, 396098, 
    165033, 288672, 481066, 601372, 138629, 626699, 644927, 158747, 749832, 935174, 
    625334, 611345, 943720, 636633, 445088, 884968, 842825, 173404, 537110, 329647, 
    826025, 280898, 548809, 333624, 579421, 466274, 860556, 696633, 787785, 150485, 
    995366, 603049, 443859, 497678, 524307, 36557, 609436, 810786, 154741, 624142, 
    989263, 250184, 134475, 481695, 166283, 46286, 915657, 962874, 273302, 604806, 
    733960, 598313, 633854, 409712, 909271, 100721, 406834, 546354, 694382, 47899, 
    795204, 808265, 24947, 169639, 595883, 140971, 778032, 993410, 447277, 224293, 
    382644, 737537, 834688, 802061, 502282, 670140, 848397, 484884, 371584, 980658, 
    727561, 591138, 569087, 331409, 664209, 355817, 64219, 36037, 727985, 712134
]

# declarar o tamanho da lista
tamanho_da_lista: int = 500

# declarar uma variável que irá guardar o menor valor, incialmente a 1a posição da lista
menor_valor: int = lista_de_numeros[0]

# declarar uma variável que guara o índice do menor valor, inicializada com 0
posicao_do_menor_valor: int = 0

# passar por todos os números da lista
for i in range(tamanho_da_lista):
    # checar se o número é menor que o menor valor
    if(lista_de_numeros[i] < menor_valor):
        # caso seja, atualizar o menor valor
        menor_valor = lista_de_numeros[i]

        # atualizar o índice do menor valor
        posicao_do_menor_valor = i

# exibir o resultado
print(posicao_do_menor_valor)
```

:::

### Exercício 2

Peça um número ao usuário e gere sua tabuada de 1 a 10.

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
# obter o número do usuário
num: int = int(input('Insira um número: '))

# gerar uma seuquência de 1 a 10
for i in range(1, 11):
    # exibir o número escolhido vezes o i
    print(i * num)
```

:::

### Exercício 3

Dada a seguinte lista de idades:

```{python}
#| eval: false
lista_idades = [
    33, 87, 62, 100, 26, 56, 47, 79, 20, 33, 54, 9, 28, 
    81, 4, 88, 56, 51, 23, 55, 35, 99, 31, 30, 33, 81, 
    81, 43, 24, 60, 41, 5, 21, 61, 79, 94, 87, 41, 60, 
    6, 64, 97, 86, 71, 6, 66, 91, 35, 94, 48, 22, 23, 
    13, 35, 58, 54, 86, 85, 36, 73, 18, 55, 97, 8, 74, 
    42, 85, 59, 48, 78, 93, 10, 88, 70, 57, 53, 14, 53, 
    57, 98, 73, 73, 83, 62, 36, 14, 56, 61, 40, 2, 77, 
    52, 93, 23, 24, 67, 4, 25, 86, 11, 3, 56, 23, 18, 5
]
```

Percorra toda a lista e identifique a quantidade de crianças, adolescentes, adultos e idosos com base nos seguintes critérios:

* A idade é de uma criança se for menor que 12.

* A idade é de um adolescente se for menor que 18.

* A idade é de um adulto se for menor que 60.

* A idade é de um idoso se for maior que 60.

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
# lista de com as idades
lista_idades = [
    33, 87, 62, 100, 26, 56, 47, 79, 20, 33, 54, 9, 28, 
    81, 4, 88, 56, 51, 23, 55, 35, 99, 31, 30, 33, 81, 
    81, 43, 24, 60, 41, 5, 21, 61, 79, 94, 87, 41, 60, 
    6, 64, 97, 86, 71, 6, 66, 91, 35, 94, 48, 22, 23, 
    13, 35, 58, 54, 86, 85, 36, 73, 18, 55, 97, 8, 74, 
    42, 85, 59, 48, 78, 93, 10, 88, 70, 57, 53, 14, 53, 
    57, 98, 73, 73, 83, 62, 36, 14, 56, 61, 40, 2, 77, 
    52, 93, 23, 24, 67, 4, 25, 86, 11, 3, 56, 23, 18, 5
]

# declarar os diferentes contadores (todos inicializados com 0)
contador_criancas: int = 0
contador_adolescentes: int = 0
contador_adultos: int = 0
contador_idosos: int = 0

# percorrer toda a lista de idades
for idade in lista_idades:
    # fazer checagems
    if(idade < 12):
        # se idade < 12, é uma criança
        contador_criancas += 1
    elif(idade < 18):
        # se idade > 12 E idade < 18, é um adolescente
        contador_adolescentes += 1
    elif(idade < 60):
        # se idade > 18 E idade < 60 é um adulto
        contador_adultos += 1
    else:
        # se idade > 60 é um idoso
        contador_idosos += 1

# exibir resultados
print('quantidade de crianças:', contador_criancas)
print('quantidade de adolescentes:', contador_adolescentes)
print('quantidade de adultos:', contador_adultos)
print('quantidade de idosos:', contador_idosos)
```

:::

### Exercício 4

Peça ao usuário uma palavra e busque nela a letra "k" ou "K". Caso a encontre, imprima "Kaio Jorge", caso contrário, apenas imprima a palavra que o usuário inseriu.

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
# obter a palavra
palavra: str = input('Insira uma palavra: ')

# declarar um bool que indica se a palavra tem 'k' ou 'K'
palavra_tem_k: bool = False

# passar pela palavra toda e checar
for letra in palavra:
    # checar se a palavra tem k
    if(letra == 'k' or letra == 'K'):
        # se tiver, ativar a flag palavra_tem_k
        palavra_tem_k = True
        
# exibir resultado com base na flag palavra_tem_k
if(palavra_tem_k == True):
    print('Kaio Jorge')
else:
    print(palavra)
```

:::

### Exercício 5

Peça ao usuário uma palavra e verifique se todas as letras da palavra são maiúsculas. Caso forem, imprima "Todas as letras maiúsculas", caso contrário imprima "Talvez alguma(s) letra(s) maiúscula(s)".

::: {.callout-tip title="Dica"}

Lembre-se do operador `in` para o tipo `str`, e que você pode gerar uma `string` com todas as letras minúsculas.

:::

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
# obter a palavra
palavra: str = input('Insira uma palavra: ')

# declarar todas as letras minúsculas
minusculas: str = 'abcdefghijklmopqrstuvwxyz'

# declarar uma flag para todas as letras maiúsculas como verdadeira
todas_as_letras_maiusculas = True

# checar todas as letras
for letra in palavra:
    # checar se a letra está no conjunto de minúsculas
    if(letra in minusculas):
        # se estiver, alterar a flag para falsa
        todas_as_letras_maiusculas = False
    
if(todas_as_letras_maiusculas):
    print('Todas as letras maiúsculas')
else:
    print('Talvez alguma(s) letra(s) maiúscula(s)')
```

:::

## Exercícios complexos

### Exercício 1

Aproximação do número $e$ usando a Série de Taylor

O número $e$ e é uma das constantes mais importantes da matemática, assim como $\pi$. Ele aparece naturalmente em várias áreas: crescimento populacional, juros compostos, probabilidade, estatística, equações diferenciais, física, computação e muito mais.

Seu valor começa com:

$$
e \approx 2,718281828459 \dots
$$

Um fato interessante sobre $e$ é que ele é um número irracional — isso significa que não pode ser expresso como uma fração exata e que sua expansão decimal não termina e não se repete. Por essa razão, o valor exato de $e$ não pode ser escrito diretamente, mas pode ser calculado com aproximações cada vez melhores.

Uma forma clássica de aproximar $e$ vem da série de Taylor da função $e^x$. Quando avaliamos essa série no ponto $x = 1$, obtemos:

$$
e = \sum_{n = 0}^{\infty} \frac{1}{n!}
$$

Que corresponde à soma:

$$
e = \frac{1}{0!} + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + \frac{1}{4!} + \dots
$$

Essa série é especialmente interessante porque converge rapidamente, e é simples de implementar computacionalmente.

Com estas informações, sua tarefa é implementar um programa que calcule uma aproximação para o número $e$ usando a série acima.

Seu programa deve:

1. Pedir ao usuário um número inteiro $N$, representando quantos termos da série devem ser somados.

2. Usar uma estrutura de repetição (por exemplo: for ou while) para somar os termos até $N$

3. Calcular o fatorial de cada $n$ durante o processo.

4. Exibir a aproximação final de $e$.

Exemplos de resultado:

* Quando o número de termos é 1, a soma é definida como:

  $$
  e \approx \sum_{n = 0}^{0} \frac{1}{n!}
  $$

  E esta aproximação se da como:

  $$
  \sum_{n = 0}^{0} \frac{1}{n!} = \frac{1}{0!} = \frac{1}{1} = 1
  $$

* Quando o número de termos é 2, a soma é definida como:

  $$
  e \approx \sum_{n = 0}^{1} \frac{1}{n!}
  $$

  E esta aproximação se da como:

  $$
  \sum_{n = 0}^{1} \frac{1}{n!} = \frac{1}{0!} + \frac{1}{1!} = \frac{1}{1} + \frac{1}{1} = 1 + 1 = 2
  $$

* Quando o número de termos é 3, a soma é definida como:

  $$
  e \approx \sum_{n = 0}^{2} \frac{1}{n!}
  $$

  E esta aproximação se da como:

  $$
  \sum_{n = 0}^{2} \frac{1}{n!} = \frac{1}{0!} + \frac{1}{1!} + \frac{1}{2!} = \frac{1}{1} + \frac{1}{1} + \frac{1}{2} = 1 + 1 + 0.5 = 2.5
  $$

* Quando o número de termos é 4, a aproximação de $e$ deve ser $2.6666666666666665$

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
# declarar e aproximado como 0
e_aprox: float = 0

# ler o valor de n
qtd_de_termos_da_aproximacao: int = int(input('Insira a quantidade de termos da aproximação: '))

# estrutura de repetição que vai de 0 até n - 1
for n in range(0, qtd_de_termos_da_aproximacao):
    # declarar n fatoria
    n_fatorial: int = 1
    
    # calcular n fatorial
    for i in range(n, 0, -1):
        n_fatorial *= i

    # somar o termo (1 / n!) à aproximação de e
    e_aprox += (1 / n_fatorial)

# exibir o resultado
print(e_aprox)
```

::: 

### Exercício 2

A cidade de Mazochilândia acaba de eleger um novo prefeito: Doutor Élcio Moloccini, conhecido por suas ideias ousadas sobre urbanismo ecológico. Logo no primeiro mês de mandato, ele aprovou um documento chamado "O Ato Mazochal das Ruas".

Segundo o prefeito, as ruas da cidade andavam "cinzentas demais", e era necessário reorganizar tudo para trazer mais verde, melhor convivência urbana e menos conflitos entre vizinhos e atividades econômicas.

Para isso, ele estabeleceu duas novas leis municipais que passam a valer imediatamente:

#### Lei 1 — Equilíbrio Ambiental

> “Toda rua deve possuir verde suficiente para compensar seus usos urbanos.”

Em termos práticos, isso significa que, dado uma rua com um certo número $A$ de árvores, um número $C$ de comércios e um número $R$ de residências, estes números devem seguir a seguinte relação:

$$
A \ge C + R
$$

#### Lei 2 — Separação de Usos Sensíveis

> “Para evitar barulho, conflitos e reclamações oficiais, comércios não podem ficar colados em residências.”

Ou seja, em uma rua, não pode haver nenhum comércio ao lado de uma casa ou casa ao lado de um comércio.

#### O Problema

Você faz parte da equipe de análise urbana da prefeitura e precisa criar um programa simples que verifique se uma rua está em conformidade com o Ato Mazochal das Ruas.

A rua será representada por uma `string` onde cada caractere significa:

* A = árvore

* C = comércio

* R = residência

O programa deve:

1. Receber a string da rua.

2. Receber a quantidade de elementos da rua.

3. Contar quantos A, C e R existem.

4. Verificar se a rua cumpre a Lei 1.

5. Verificar se cumpre a Lei 2.

6. Exibir:

    - “Lei 1: SIM/NÃO”

    - “Lei 2: SIM/NÃO”

    - “RUA APROVADA” se cumprir ambas

    - “RUA REPROVADA” caso contrário

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
# receber a string
rua: str = input('Insira a string que representa a rua: ')

# receber quantidade de elementos da rua
qnt_elementos_da_rua: int = int(input('Insira quantidade de elementos da rua: '))

# declarar variáveis das leis
lei_um: bool = False
lei_dois: bool = True

# declarar contadores
contador_arvores: int = 0
contador_comercios: int = 0
contador_residencias: int = 0

# contar arvores, comercios e residencias
for elemento in rua:
    if(elemento == 'A'):
        contador_arvores += 1
    elif(elemento == 'C'):
        contador_comercios += 1
    elif(elemento == 'R'):
        contador_residencias += 1

# checar lei um
if(contador_arvores >= (contador_residencias + contador_comercios)):
    lei_um = True

# checar lei dois
for i in range(qnt_elementos_da_rua - 1):
    # checar comércio depois residência
    if(rua[i] == 'C' and rua[(i + 1)] == 'R'):
        lei_dois = False

    # checar residência depois comércio
    if(rua[i] == 'R' and rua[(i + 1)] == 'C'):
        lei_dois = False

# relatório final
if(lei_um == True):
    print('Lei 1: Sim')
else:
    print('Lei 1: Não')

if(lei_dois == True):
    print('Lei 2: Sim')
else:
    print('Lei 2: Não')

if(lei_um == True and lei_dois == True):
    print('RUA APROVADA')
else:
    print('RUA REPROVADA')
```

:::

### Exercício 3

O município de Mazochilândia, localizado em uma vasta região agropecuária, tornou-se referência na produção de carne e no manejo extensivo de gado. Suas fazendas ocupam grandes áreas abertas, e a pecuária é o pilar econômico da cidade, movimentando tanto o comércio local quanto a exportação.

Nos últimos anos, porém, técnicos ambientais e agrônomos passaram a alertar para um problema crescente: o uso intensivo do pasto sem controle adequado da carga animal. A superlotação compromete a regeneração da vegetação nativa, aumenta processos de erosão e reduz a capacidade produtiva futura das terras.

Diante dessas preocupações, o prefeito Dr. Élcio Moloccini implementou uma nova política pública de gestão sustentável da pecuária. A medida central dessa política é a criação do Imposto Pecuário Sustentável, um tributo regulamentado para estimular boas práticas de criação e prevenir a degradação do solo. O imposto incide apenas sobre as propriedades que mantêm densidade de gado acima do limite ambientalmente recomendado para a área total da fazenda.

Essa política exige um método objetivo e padronizado para avaliar cada fazenda, levando à necessidade de um sistema computacional capaz de auxiliar na análise.

#### Estrutura do sistema computacional

Para automatizar o processo de fiscalização e garantir imparcialidade no cálculo, o sistema adotará uma representação matricial das fazendas. Nessa modelagem:

* Cada linha da matriz corresponde a uma fazenda registrada no município.

* Cada coluna representa um setor interno da fazenda, como se a propriedade fosse dividida em áreas menores para facilitar o acompanhamento.

* A célula $(i, j)$ armazena o número de cabeças de gado presentes no setor $j$ da fazenda $i$.

* Todas as fazendas possuem a mesma área total, definida pelos critérios da secretaria de agricultura municipal.

Esse formato permite que o sistema compute rapidamente a quantidade total de gado, calcule densidades e identifique eventuais irregularidades.


#### Regra do imposto

Regra do Imposto

A cobrança do imposto depende da densidade de gado de cada fazenda, calculada por:

$$
\sigma = \frac{\text{Quantidade de cabeças de gado}}{\text{Área total da fazenda}}
$$

O valor máximo permitido, chamado de limite de densidade ($\sigma_{\text{max}}$), é estabelecido pela prefeitura com base em estudos ambientais, recomendações técnicas e índices de sustentabilidade rural.

As regras de cobrança são:

Se a densidade $\sigma$ for maior que $\sigma_{\text{max}}$, a fazenda deve pagar o Imposto Pecuário Sustentável.

Se for menor ou igual, a fazenda fica isenta, como forma de incentivo às boas práticas e ao manejo responsável.

#### Tarefa

Você deverá desenvolver um programa que:

* Leia a matriz que representa as fazendas e seus setores (no caso serão 4 fazendas, cada uma com 4 setores).

* Leia a área total (mesma para todas as propriedades) e o valor do limite $\sigma_{\text{max}}$.

* Calcule a densidade pecuária de cada fazenda.

* Indique quais fazendas (identificadas pelo índice da linha na matriz) estão sujeitas ao pagamento do imposto.

#### Exemplo

Dado $\sigma_{max} = 2$, a área de cada fazenda é igual a $4$ e a disposição das fazendas é a seguinte:

$$
\begin{bmatrix}
1 & 1 & 1 & 1 \\
2 & 2 & 2 & 2 \\
3 & 3 & 3 & 3 \\
4 & 4 & 4 & 4
\end{bmatrix}
$$

As fazendas identificadas pelos valores 2 e 3 (considerando a indexação padrão do Python) são aquelas que devem pagar imposto.

::: {.callout-note title="Dica"} 

Utilize [f-strings](https://www.geeksforgeeks.org/python/formatted-string-literals-f-strings-python/) para conseguir ler facilmente dados para a matriz.

:::

::: {.callout-tip collapse="true" title="Ver Solução"}

```{python}
#| eval: false
# declarar dados
qnt_fazendas: int = 4
qnt_setores_por_fazenda: int = 4

# declarar a matriz de dados
matriz: list = [
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0]
]

# declarar a lista de fazendas com sigma maior que sigma_max (inicialmente todas falsas)
fazendas_com_sigma_maior_que_permitido: list = [False, False, False, False]

# passar por todas as fazendas
for i in range(qnt_fazendas):
    # passar por todos os setores
    for j in range(qnt_setores_por_fazenda):
        # coletar dados
        matriz[i][j] = int(input(f'Insira a quantidade de gado no setor {j} da fazenda {i}: '))

# coletar sigma_max
sigma_max: int = int(input('Insira sigma_max: '))

# coletar a área das fazendas
area_fazenda: int = int(input('Insira a área: '))

# passar por todas as fazendas
for i in range(qnt_fazendas):   
    # quantidade de gado
    qnt_gado_da_fazenda: int = 0

    # passar por todos os setores
    for j in range(qnt_setores_por_fazenda):
        # adicionar o gado no setor ao total
        qnt_gado_da_fazenda += matriz[i][j]

    # calcular sigma da fazenda
    sigma: float = qnt_gado_da_fazenda / area_fazenda

    # checar se é maior que sigma max
    if(sigma > sigma_max):
        # alterar no vetor de fazendas com sigma impróprio
        fazendas_com_sigma_maior_que_permitido[i] = True

# passar pelo vetor de fazendas com sigma errado e indicar quais estão fora da lei
for i in range(qnt_fazendas):
    if(fazendas_com_sigma_maior_que_permitido[i] == True):
        print(f'Fazenda {i} deve pagar imposto!')
```

:::